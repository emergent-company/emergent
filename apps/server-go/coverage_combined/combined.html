
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>apitoken: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/emergent/emergent-core/domain/apitoken/entity.go (100.0%)</option>
				
				<option value="file1">github.com/emergent/emergent-core/domain/apitoken/handler.go (79.2%)</option>
				
				<option value="file2">github.com/emergent/emergent-core/domain/apitoken/repository.go (80.6%)</option>
				
				<option value="file3">github.com/emergent/emergent-core/domain/apitoken/routes.go (100.0%)</option>
				
				<option value="file4">github.com/emergent/emergent-core/domain/apitoken/service.go (84.7%)</option>
				
				<option value="file5">github.com/emergent/emergent-core/domain/chat/handler.go (73.7%)</option>
				
				<option value="file6">github.com/emergent/emergent-core/domain/chat/module.go (0.0%)</option>
				
				<option value="file7">github.com/emergent/emergent-core/domain/chat/repository.go (54.8%)</option>
				
				<option value="file8">github.com/emergent/emergent-core/domain/chat/routes.go (100.0%)</option>
				
				<option value="file9">github.com/emergent/emergent-core/domain/chat/service.go (63.3%)</option>
				
				<option value="file10">github.com/emergent/emergent-core/domain/chunks/entity.go (100.0%)</option>
				
				<option value="file11">github.com/emergent/emergent-core/domain/chunks/handler.go (79.7%)</option>
				
				<option value="file12">github.com/emergent/emergent-core/domain/chunks/repository.go (55.8%)</option>
				
				<option value="file13">github.com/emergent/emergent-core/domain/chunks/routes.go (100.0%)</option>
				
				<option value="file14">github.com/emergent/emergent-core/domain/chunks/service.go (46.9%)</option>
				
				<option value="file15">github.com/emergent/emergent-core/domain/datasource/config.go (100.0%)</option>
				
				<option value="file16">github.com/emergent/emergent-core/domain/datasource/entity.go (100.0%)</option>
				
				<option value="file17">github.com/emergent/emergent-core/domain/datasource/jobs_service.go (42.0%)</option>
				
				<option value="file18">github.com/emergent/emergent-core/domain/datasource/module.go (0.0%)</option>
				
				<option value="file19">github.com/emergent/emergent-core/domain/datasource/provider.go (100.0%)</option>
				
				<option value="file20">github.com/emergent/emergent-core/domain/datasource/providers/clickup/client.go (23.9%)</option>
				
				<option value="file21">github.com/emergent/emergent-core/domain/datasource/providers/clickup/provider.go (21.0%)</option>
				
				<option value="file22">github.com/emergent/emergent-core/domain/datasource/worker.go (13.5%)</option>
				
				<option value="file23">github.com/emergent/emergent-core/domain/devtools/handler.go (0.0%)</option>
				
				<option value="file24">github.com/emergent/emergent-core/domain/devtools/module.go (0.0%)</option>
				
				<option value="file25">github.com/emergent/emergent-core/domain/documents/handler.go (82.8%)</option>
				
				<option value="file26">github.com/emergent/emergent-core/domain/documents/repository.go (56.7%)</option>
				
				<option value="file27">github.com/emergent/emergent-core/domain/documents/routes.go (100.0%)</option>
				
				<option value="file28">github.com/emergent/emergent-core/domain/documents/service.go (66.7%)</option>
				
				<option value="file29">github.com/emergent/emergent-core/domain/documents/upload_handler.go (7.3%)</option>
				
				<option value="file30">github.com/emergent/emergent-core/domain/email/config.go (100.0%)</option>
				
				<option value="file31">github.com/emergent/emergent-core/domain/email/jobs.go (79.5%)</option>
				
				<option value="file32">github.com/emergent/emergent-core/domain/email/mailgun.go (22.4%)</option>
				
				<option value="file33">github.com/emergent/emergent-core/domain/email/module.go (34.6%)</option>
				
				<option value="file34">github.com/emergent/emergent-core/domain/email/template.go (10.1%)</option>
				
				<option value="file35">github.com/emergent/emergent-core/domain/email/worker.go (34.4%)</option>
				
				<option value="file36">github.com/emergent/emergent-core/domain/events/handler.go (0.0%)</option>
				
				<option value="file37">github.com/emergent/emergent-core/domain/events/module.go (0.0%)</option>
				
				<option value="file38">github.com/emergent/emergent-core/domain/events/service.go (0.0%)</option>
				
				<option value="file39">github.com/emergent/emergent-core/domain/extraction/agents/entity_extractor.go (50.6%)</option>
				
				<option value="file40">github.com/emergent/emergent-core/domain/extraction/agents/pipeline.go (21.0%)</option>
				
				<option value="file41">github.com/emergent/emergent-core/domain/extraction/agents/prompts.go (100.0%)</option>
				
				<option value="file42">github.com/emergent/emergent-core/domain/extraction/agents/quality_checker.go (50.0%)</option>
				
				<option value="file43">github.com/emergent/emergent-core/domain/extraction/agents/relationship_builder.go (40.2%)</option>
				
				<option value="file44">github.com/emergent/emergent-core/domain/extraction/agents/schemas.go (100.0%)</option>
				
				<option value="file45">github.com/emergent/emergent-core/domain/extraction/chunk_embedding_jobs.go (80.2%)</option>
				
				<option value="file46">github.com/emergent/emergent-core/domain/extraction/chunk_embedding_worker.go (73.7%)</option>
				
				<option value="file47">github.com/emergent/emergent-core/domain/extraction/document_parsing_jobs.go (80.6%)</option>
				
				<option value="file48">github.com/emergent/emergent-core/domain/extraction/document_parsing_worker.go (0.0%)</option>
				
				<option value="file49">github.com/emergent/emergent-core/domain/extraction/entity.go (100.0%)</option>
				
				<option value="file50">github.com/emergent/emergent-core/domain/extraction/graph_embedding_jobs.go (80.8%)</option>
				
				<option value="file51">github.com/emergent/emergent-core/domain/extraction/graph_embedding_worker.go (81.5%)</option>
				
				<option value="file52">github.com/emergent/emergent-core/domain/extraction/module.go (3.6%)</option>
				
				<option value="file53">github.com/emergent/emergent-core/domain/extraction/object_extraction_jobs.go (83.4%)</option>
				
				<option value="file54">github.com/emergent/emergent-core/domain/extraction/object_extraction_worker.go (24.8%)</option>
				
				<option value="file55">github.com/emergent/emergent-core/domain/extraction/template_pack_schema_provider.go (66.4%)</option>
				
				<option value="file56">github.com/emergent/emergent-core/domain/graph/dto.go (100.0%)</option>
				
				<option value="file57">github.com/emergent/emergent-core/domain/graph/handler.go (69.3%)</option>
				
				<option value="file58">github.com/emergent/emergent-core/domain/graph/repository.go (76.8%)</option>
				
				<option value="file59">github.com/emergent/emergent-core/domain/graph/routes.go (100.0%)</option>
				
				<option value="file60">github.com/emergent/emergent-core/domain/graph/service.go (65.3%)</option>
				
				<option value="file61">github.com/emergent/emergent-core/domain/health/handler.go (77.8%)</option>
				
				<option value="file62">github.com/emergent/emergent-core/domain/health/metrics_handler.go (0.0%)</option>
				
				<option value="file63">github.com/emergent/emergent-core/domain/health/routes.go (0.0%)</option>
				
				<option value="file64">github.com/emergent/emergent-core/domain/invites/handler.go (0.0%)</option>
				
				<option value="file65">github.com/emergent/emergent-core/domain/invites/module.go (0.0%)</option>
				
				<option value="file66">github.com/emergent/emergent-core/domain/invites/service.go (0.0%)</option>
				
				<option value="file67">github.com/emergent/emergent-core/domain/mcp/handler.go (78.2%)</option>
				
				<option value="file68">github.com/emergent/emergent-core/domain/mcp/jsonrpc.go (100.0%)</option>
				
				<option value="file69">github.com/emergent/emergent-core/domain/mcp/routes.go (100.0%)</option>
				
				<option value="file70">github.com/emergent/emergent-core/domain/mcp/service.go (71.6%)</option>
				
				<option value="file71">github.com/emergent/emergent-core/domain/mcp/sse_handler.go (5.6%)</option>
				
				<option value="file72">github.com/emergent/emergent-core/domain/orgs/entity.go (100.0%)</option>
				
				<option value="file73">github.com/emergent/emergent-core/domain/orgs/handler.go (88.9%)</option>
				
				<option value="file74">github.com/emergent/emergent-core/domain/orgs/repository.go (63.2%)</option>
				
				<option value="file75">github.com/emergent/emergent-core/domain/orgs/routes.go (100.0%)</option>
				
				<option value="file76">github.com/emergent/emergent-core/domain/orgs/service.go (84.8%)</option>
				
				<option value="file77">github.com/emergent/emergent-core/domain/projects/entity.go (100.0%)</option>
				
				<option value="file78">github.com/emergent/emergent-core/domain/projects/handler.go (84.6%)</option>
				
				<option value="file79">github.com/emergent/emergent-core/domain/projects/repository.go (59.5%)</option>
				
				<option value="file80">github.com/emergent/emergent-core/domain/projects/routes.go (100.0%)</option>
				
				<option value="file81">github.com/emergent/emergent-core/domain/projects/service.go (76.0%)</option>
				
				<option value="file82">github.com/emergent/emergent-core/domain/scheduler/config.go (100.0%)</option>
				
				<option value="file83">github.com/emergent/emergent-core/domain/scheduler/module.go (0.0%)</option>
				
				<option value="file84">github.com/emergent/emergent-core/domain/scheduler/scheduler.go (93.6%)</option>
				
				<option value="file85">github.com/emergent/emergent-core/domain/scheduler/tasks.go (73.0%)</option>
				
				<option value="file86">github.com/emergent/emergent-core/domain/search/handler.go (75.0%)</option>
				
				<option value="file87">github.com/emergent/emergent-core/domain/search/repository.go (13.9%)</option>
				
				<option value="file88">github.com/emergent/emergent-core/domain/search/routes.go (100.0%)</option>
				
				<option value="file89">github.com/emergent/emergent-core/domain/search/service.go (75.9%)</option>
				
				<option value="file90">github.com/emergent/emergent-core/domain/useraccess/handler.go (0.0%)</option>
				
				<option value="file91">github.com/emergent/emergent-core/domain/useraccess/module.go (0.0%)</option>
				
				<option value="file92">github.com/emergent/emergent-core/domain/useraccess/service.go (0.0%)</option>
				
				<option value="file93">github.com/emergent/emergent-core/domain/userprofile/entity.go (100.0%)</option>
				
				<option value="file94">github.com/emergent/emergent-core/domain/userprofile/handler.go (85.7%)</option>
				
				<option value="file95">github.com/emergent/emergent-core/domain/userprofile/repository.go (56.1%)</option>
				
				<option value="file96">github.com/emergent/emergent-core/domain/userprofile/routes.go (100.0%)</option>
				
				<option value="file97">github.com/emergent/emergent-core/domain/userprofile/service.go (57.9%)</option>
				
				<option value="file98">github.com/emergent/emergent-core/domain/users/handler.go (91.7%)</option>
				
				<option value="file99">github.com/emergent/emergent-core/domain/users/repository.go (44.0%)</option>
				
				<option value="file100">github.com/emergent/emergent-core/domain/users/routes.go (100.0%)</option>
				
				<option value="file101">github.com/emergent/emergent-core/domain/users/service.go (80.0%)</option>
				
				<option value="file102">github.com/emergent/emergent-core/internal/config/config.go (95.5%)</option>
				
				<option value="file103">github.com/emergent/emergent-core/internal/database/database.go (25.0%)</option>
				
				<option value="file104">github.com/emergent/emergent-core/internal/jobs/queue.go (6.2%)</option>
				
				<option value="file105">github.com/emergent/emergent-core/internal/jobs/worker.go (28.6%)</option>
				
				<option value="file106">github.com/emergent/emergent-core/internal/storage/storage.go (37.9%)</option>
				
				<option value="file107">github.com/emergent/emergent-core/internal/testutil/auth.go (72.0%)</option>
				
				<option value="file108">github.com/emergent/emergent-core/internal/testutil/database.go (62.4%)</option>
				
				<option value="file109">github.com/emergent/emergent-core/internal/testutil/server.go (97.2%)</option>
				
				<option value="file110">github.com/emergent/emergent-core/internal/testutil/suite.go (92.0%)</option>
				
				<option value="file111">github.com/emergent/emergent-core/internal/version/version.go (0.0%)</option>
				
				<option value="file112">github.com/emergent/emergent-core/pkg/adk/model.go (70.0%)</option>
				
				<option value="file113">github.com/emergent/emergent-core/pkg/apperror/error.go (100.0%)</option>
				
				<option value="file114">github.com/emergent/emergent-core/pkg/apperror/handler.go (100.0%)</option>
				
				<option value="file115">github.com/emergent/emergent-core/pkg/auth/middleware.go (76.1%)</option>
				
				<option value="file116">github.com/emergent/emergent-core/pkg/auth/user_profile.go (40.3%)</option>
				
				<option value="file117">github.com/emergent/emergent-core/pkg/auth/zitadel.go (52.5%)</option>
				
				<option value="file118">github.com/emergent/emergent-core/pkg/embeddings/client.go (100.0%)</option>
				
				<option value="file119">github.com/emergent/emergent-core/pkg/embeddings/module.go (11.4%)</option>
				
				<option value="file120">github.com/emergent/emergent-core/pkg/embeddings/vertex/client.go (11.8%)</option>
				
				<option value="file121">github.com/emergent/emergent-core/pkg/encryption/service.go (15.9%)</option>
				
				<option value="file122">github.com/emergent/emergent-core/pkg/kreuzberg/client.go (24.7%)</option>
				
				<option value="file123">github.com/emergent/emergent-core/pkg/llm/vertex/client.go (13.2%)</option>
				
				<option value="file124">github.com/emergent/emergent-core/pkg/logger/logger.go (24.4%)</option>
				
				<option value="file125">github.com/emergent/emergent-core/pkg/mathutil/math.go (100.0%)</option>
				
				<option value="file126">github.com/emergent/emergent-core/pkg/pgutils/errors.go (100.0%)</option>
				
				<option value="file127">github.com/emergent/emergent-core/pkg/pgutils/vector.go (100.0%)</option>
				
				<option value="file128">github.com/emergent/emergent-core/pkg/sse/events.go (100.0%)</option>
				
				<option value="file129">github.com/emergent/emergent-core/pkg/sse/writer.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package apitoken

import (
        "time"

        "github.com/uptrace/bun"
)

// ApiToken represents an API token from core.api_tokens
type ApiToken struct {
        bun.BaseModel `bun:"table:core.api_tokens,alias:at"`

        ID          string     `bun:"id,pk,type:uuid,default:uuid_generate_v4()"`
        ProjectID   string     `bun:"project_id,notnull,type:uuid"`
        UserID      string     `bun:"user_id,notnull,type:uuid"`
        Name        string     `bun:"name,notnull"`
        TokenHash   string     `bun:"token_hash,notnull"`
        TokenPrefix string     `bun:"token_prefix,notnull"`
        Scopes      []string   `bun:"scopes,array"`
        CreatedAt   time.Time  `bun:"created_at,notnull,default:now()"`
        LastUsedAt  *time.Time `bun:"last_used_at"`
        RevokedAt   *time.Time `bun:"revoked_at"`
}

// ApiTokenDTO is the response DTO for API token endpoints (without sensitive data)
type ApiTokenDTO struct {
        ID          string     `json:"id"`
        Name        string     `json:"name"`
        TokenPrefix string     `json:"tokenPrefix"`
        Scopes      []string   `json:"scopes"`
        CreatedAt   time.Time  `json:"createdAt"`
        LastUsedAt  *time.Time `json:"lastUsedAt,omitempty"`
        IsRevoked   bool       `json:"isRevoked"`
}

// CreateApiTokenResponseDTO extends ApiTokenDTO with the full token value (only at creation)
type CreateApiTokenResponseDTO struct {
        ApiTokenDTO
        Token string `json:"token"`
}

// ApiTokenListResponseDTO is the response for listing tokens
type ApiTokenListResponseDTO struct {
        Tokens []ApiTokenDTO `json:"tokens"`
        Total  int           `json:"total"`
}

// CreateApiTokenRequest is the request body for creating a token
type CreateApiTokenRequest struct {
        Name   string   `json:"name" validate:"required,min=1,max=255"`
        Scopes []string `json:"scopes" validate:"required,min=1,dive,oneof=schema:read data:read data:write"`
}

// Available scopes for API tokens
var ValidApiTokenScopes = []string{
        "schema:read",
        "data:read",
        "data:write",
}

// ToDTO converts an ApiToken entity to ApiTokenDTO
func (t *ApiToken) ToDTO() ApiTokenDTO <span class="cov8" title="1">{
        return ApiTokenDTO{
                ID:          t.ID,
                Name:        t.Name,
                TokenPrefix: t.TokenPrefix,
                Scopes:      t.Scopes,
                CreatedAt:   t.CreatedAt,
                LastUsedAt:  t.LastUsedAt,
                IsRevoked:   t.RevokedAt != nil,
        }
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package apitoken

import (
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

// Handler handles HTTP requests for API tokens
type Handler struct {
        svc *Service
}

// NewHandler creates a new API token handler
func NewHandler(svc *Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{svc: svc}
}</span>

// Create creates a new API token
// POST /api/v2/projects/:projectId/tokens
func (h *Handler) Create(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID := c.Param("projectId")
        if projectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("projectId is required")
        }</span>

        <span class="cov8" title="1">var req CreateApiTokenRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        // Validate request
        <span class="cov8" title="1">if req.Name == "" </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("name is required")
        }</span>
        <span class="cov8" title="1">if len(req.Name) &gt; 255 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("name must be at most 255 characters")
        }</span>
        <span class="cov8" title="1">if len(req.Scopes) == 0 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("at least one scope is required")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.Create(c.Request().Context(), projectID, user.ID, req.Name, req.Scopes)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, result)</span>
}

// List returns all API tokens for a project
// GET /api/v2/projects/:projectId/tokens
func (h *Handler) List(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID := c.Param("projectId")
        if projectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("projectId is required")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.ListByProject(c.Request().Context(), projectID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// Get returns a single API token by ID
// GET /api/v2/projects/:projectId/tokens/:tokenId
func (h *Handler) Get(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID := c.Param("projectId")
        tokenID := c.Param("tokenId")

        if projectID == "" || tokenID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("projectId and tokenId are required")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.GetByID(c.Request().Context(), tokenID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if result == nil </span><span class="cov8" title="1">{
                return apperror.ErrNotFound.WithMessage("Token not found")
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// Revoke revokes an API token
// DELETE /api/v2/projects/:projectId/tokens/:tokenId
func (h *Handler) Revoke(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID := c.Param("projectId")
        tokenID := c.Param("tokenId")

        if projectID == "" || tokenID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("projectId and tokenId are required")
        }</span>

        <span class="cov8" title="1">if err := h.svc.Revoke(c.Request().Context(), tokenID, projectID, user.ID); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, map[string]string{"status": "revoked"})</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package apitoken

import (
        "context"
        "database/sql"
        "log/slog"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Repository handles data access for API tokens
type Repository struct {
        db  bun.IDB
        log *slog.Logger
}

// NewRepository creates a new API token repository
func NewRepository(db bun.IDB, log *slog.Logger) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                db:  db,
                log: log.With(logger.Scope("apitoken.repo")),
        }
}</span>

// Create creates a new API token
func (r *Repository) Create(ctx context.Context, token *ApiToken) error <span class="cov8" title="1">{
        _, err := r.db.NewInsert().
                Model(token).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// FindByProjectAndName finds a token by project ID and name (for uniqueness check)
// Includes ALL tokens (even revoked) since the database constraint is project-wide
func (r *Repository) FindByProjectAndName(ctx context.Context, projectID, name string) (*ApiToken, error) <span class="cov8" title="1">{
        var token ApiToken
        err := r.db.NewSelect().
                Model(&amp;token).
                Where("project_id = ?", projectID).
                Where("name = ?", name).
                Scan(ctx)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil // Not found is not an error
                }</span>
                <span class="cov0" title="0">return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }
        <span class="cov8" title="1">return &amp;token, nil</span>
}

// ListByProject returns all tokens for a project
func (r *Repository) ListByProject(ctx context.Context, projectID string) ([]ApiToken, error) <span class="cov8" title="1">{
        var tokens []ApiToken
        err := r.db.NewSelect().
                Model(&amp;tokens).
                Where("project_id = ?", projectID).
                Order("created_at DESC").
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">return tokens, nil</span>
}

// GetByID returns a token by ID and project ID
func (r *Repository) GetByID(ctx context.Context, tokenID, projectID string) (*ApiToken, error) <span class="cov8" title="1">{
        var token ApiToken
        err := r.db.NewSelect().
                Model(&amp;token).
                Where("id = ?", tokenID).
                Where("project_id = ?", projectID).
                Scan(ctx)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }
        <span class="cov8" title="1">return &amp;token, nil</span>
}

// Revoke sets the revoked_at timestamp on a token
func (r *Repository) Revoke(ctx context.Context, tokenID, projectID string) (bool, error) <span class="cov8" title="1">{
        result, err := r.db.NewUpdate().
                Model((*ApiToken)(nil)).
                Set("revoked_at = NOW()").
                Where("id = ?", tokenID).
                Where("project_id = ?", projectID).
                Where("revoked_at IS NULL").
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return false, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return false, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return rows &gt; 0, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package apitoken

import (
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/auth"
)

// RegisterRoutes registers API token routes
func RegisterRoutes(e *echo.Echo, h *Handler, authMiddleware *auth.Middleware) <span class="cov8" title="1">{
        // All routes require authentication and project:read scope
        g := e.Group("/api/v2/projects/:projectId/tokens")
        g.Use(authMiddleware.RequireAuth())
        g.Use(authMiddleware.RequireScopes("project:read"))

        g.POST("", h.Create)
        g.GET("", h.List)
        g.GET("/:tokenId", h.Get)
        g.DELETE("/:tokenId", h.Revoke)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package apitoken

import (
        "context"
        "crypto/rand"
        "crypto/sha256"
        "encoding/hex"
        "log/slog"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

const (
        // TokenPrefix for Emergent API tokens
        TokenPrefix = "emt_"
        // TokenRandomBytes is the number of random bytes in a token
        TokenRandomBytes = 32
)

// Service handles business logic for API tokens
type Service struct {
        repo *Repository
        log  *slog.Logger
}

// NewService creates a new API token service
func NewService(repo *Repository, log *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: repo,
                log:  log.With(logger.Scope("apitoken.svc")),
        }
}</span>

// generateToken creates a new API token
// Format: emt_&lt;32-byte-hex&gt; = 4 + 64 = 68 characters
func generateToken() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, TokenRandomBytes)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return TokenPrefix + hex.EncodeToString(bytes), nil</span>
}

// hashToken creates a SHA-256 hash of a token
func hashToken(token string) string <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(token))
        return hex.EncodeToString(hash[:])
}</span>

// getTokenPrefix extracts the first 12 characters of a token
func getTokenPrefix(token string) string <span class="cov8" title="1">{
        if len(token) &lt; 12 </span><span class="cov8" title="1">{
                return token
        }</span>
        <span class="cov8" title="1">return token[:12]</span>
}

// Create creates a new API token
func (s *Service) Create(ctx context.Context, projectID, userID, name string, scopes []string) (*CreateApiTokenResponseDTO, error) <span class="cov8" title="1">{
        // Validate scopes
        for _, scope := range scopes </span><span class="cov8" title="1">{
                valid := false
                for _, validScope := range ValidApiTokenScopes </span><span class="cov8" title="1">{
                        if scope == validScope </span><span class="cov8" title="1">{
                                valid = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !valid </span><span class="cov8" title="1">{
                        return nil, apperror.ErrBadRequest.WithMessage("invalid scope: " + scope)
                }</span>
        }

        // Check for duplicate name
        <span class="cov8" title="1">existing, err := s.repo.FindByProjectAndName(ctx, projectID, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if existing != nil </span><span class="cov8" title="1">{
                return nil, apperror.New(409, "token_name_exists", "A token named \""+name+"\" already exists for this project")
        }</span>

        // Generate token
        <span class="cov8" title="1">rawToken, err := generateToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrInternal.WithInternal(err)
        }</span>

        // Create token record
        <span class="cov8" title="1">token := &amp;ApiToken{
                ProjectID:   projectID,
                UserID:      userID,
                Name:        name,
                TokenHash:   hashToken(rawToken),
                TokenPrefix: getTokenPrefix(rawToken),
                Scopes:      scopes,
        }

        if err := s.repo.Create(ctx, token); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s.log.Info("created API token",
                slog.String("name", name),
                slog.String("tokenPrefix", token.TokenPrefix),
                slog.String("projectID", projectID))

        return &amp;CreateApiTokenResponseDTO{
                ApiTokenDTO: token.ToDTO(),
                Token:       rawToken, // Only returned at creation time
        }, nil</span>
}

// ListByProject returns all tokens for a project
func (s *Service) ListByProject(ctx context.Context, projectID string) (*ApiTokenListResponseDTO, error) <span class="cov8" title="1">{
        tokens, err := s.repo.ListByProject(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">dtos := make([]ApiTokenDTO, len(tokens))
        for i, t := range tokens </span><span class="cov8" title="1">{
                dtos[i] = t.ToDTO()
        }</span>

        <span class="cov8" title="1">return &amp;ApiTokenListResponseDTO{
                Tokens: dtos,
                Total:  len(dtos),
        }, nil</span>
}

// GetByID returns a token by ID
func (s *Service) GetByID(ctx context.Context, tokenID, projectID string) (*ApiTokenDTO, error) <span class="cov8" title="1">{
        token, err := s.repo.GetByID(ctx, tokenID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if token == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">dto := token.ToDTO()
        return &amp;dto, nil</span>
}

// Revoke revokes a token
func (s *Service) Revoke(ctx context.Context, tokenID, projectID, userID string) error <span class="cov8" title="1">{
        // Check if token exists
        token, err := s.repo.GetByID(ctx, tokenID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if token == nil </span><span class="cov8" title="1">{
                return apperror.ErrNotFound.WithMessage("Token not found")
        }</span>

        // Check if already revoked
        <span class="cov8" title="1">if token.RevokedAt != nil </span><span class="cov8" title="1">{
                return apperror.New(409, "token_already_revoked", "Token is already revoked")
        }</span>

        // Revoke
        <span class="cov8" title="1">revoked, err := s.repo.Revoke(ctx, tokenID, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !revoked </span><span class="cov0" title="0">{
                return apperror.ErrNotFound.WithMessage("Token not found")
        }</span>

        <span class="cov8" title="1">s.log.Info("revoked API token",
                slog.String("name", token.Name),
                slog.String("tokenPrefix", token.TokenPrefix),
                slog.String("userID", userID))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package chat

import (
        "net/http"
        "os"
        "strconv"
        "strings"

        "github.com/google/uuid"
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
        "github.com/emergent/emergent-core/pkg/llm/vertex"
        "github.com/emergent/emergent-core/pkg/sse"
)

// Handler handles chat HTTP requests
type Handler struct {
        svc       *Service
        llmClient *vertex.Client
}

// NewHandler creates a new chat handler
func NewHandler(svc *Service, llmClient *vertex.Client) *Handler <span class="cov8" title="1">{
        return &amp;Handler{svc: svc, llmClient: llmClient}
}</span>

// ListConversations handles GET /api/v2/chat/conversations
func (h *Handler) ListConversations(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        // Parse query parameters
        <span class="cov8" title="1">limit := 50
        if limitStr := c.QueryParam("limit"); limitStr != "" </span><span class="cov8" title="1">{
                parsed, err := strconv.Atoi(limitStr)
                if err != nil || parsed &lt; 1 || parsed &gt; 100 </span><span class="cov0" title="0">{
                        return apperror.ErrBadRequest.WithMessage("limit must be between 1 and 100")
                }</span>
                <span class="cov8" title="1">limit = parsed</span>
        }

        <span class="cov8" title="1">offset := 0
        if offsetStr := c.QueryParam("offset"); offsetStr != "" </span><span class="cov8" title="1">{
                parsed, err := strconv.Atoi(offsetStr)
                if err != nil || parsed &lt; 0 </span><span class="cov0" title="0">{
                        return apperror.ErrBadRequest.WithMessage("offset must be a non-negative integer")
                }</span>
                <span class="cov8" title="1">offset = parsed</span>
        }

        // Pass user ID for filtering private conversations (user.ID is the UUID from user_profiles)
        <span class="cov8" title="1">result, err := h.svc.ListConversations(c.Request().Context(), user.ProjectID, &amp;user.ID, limit, offset)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// GetConversation handles GET /api/v2/chat/:id
func (h *Handler) GetConversation(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        <span class="cov8" title="1">conversationID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("invalid conversation id")
        }</span>

        // Get conversation with messages
        <span class="cov8" title="1">conv, err := h.svc.GetConversationWithMessages(c.Request().Context(), user.ProjectID, conversationID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, conv)</span>
}

// CreateConversation handles POST /api/v2/chat/conversations
func (h *Handler) CreateConversation(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        <span class="cov8" title="1">var req CreateConversationRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        // Validate
        <span class="cov8" title="1">if err := validateCreateConversationRequest(&amp;req); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // user.ID is the UUID from user_profiles, not user.Sub (Zitadel ID)
        <span class="cov8" title="1">conv, err := h.svc.CreateConversation(c.Request().Context(), user.ProjectID, user.ID, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, conv)</span>
}

// UpdateConversation handles PATCH /api/v2/chat/:id
func (h *Handler) UpdateConversation(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        <span class="cov8" title="1">conversationID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid conversation id")
        }</span>

        <span class="cov8" title="1">var req UpdateConversationRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        // Validate
        <span class="cov8" title="1">if err := validateUpdateConversationRequest(&amp;req); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">conv, err := h.svc.UpdateConversation(c.Request().Context(), user.ProjectID, conversationID, req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, conv)</span>
}

// DeleteConversation handles DELETE /api/v2/chat/:id
func (h *Handler) DeleteConversation(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        <span class="cov8" title="1">conversationID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid conversation id")
        }</span>

        <span class="cov8" title="1">if err := h.svc.DeleteConversation(c.Request().Context(), user.ProjectID, conversationID); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, map[string]string{"status": "deleted"})</span>
}

// AddMessage handles POST /api/v2/chat/:id/messages
func (h *Handler) AddMessage(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        <span class="cov8" title="1">conversationID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid conversation id")
        }</span>

        <span class="cov8" title="1">var req AddMessageRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        // Validate
        <span class="cov8" title="1">if err := validateAddMessageRequest(&amp;req); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">msg, err := h.svc.AddMessage(c.Request().Context(), user.ProjectID, conversationID, req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, msg)</span>
}

// Validation helpers

func validateCreateConversationRequest(req *CreateConversationRequest) error <span class="cov8" title="1">{
        if req.Title == "" </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("title is required")
        }</span>
        <span class="cov8" title="1">if len(req.Title) &gt; 512 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("title must be at most 512 characters")
        }</span>
        <span class="cov8" title="1">if req.Message == "" </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("message is required")
        }</span>
        <span class="cov8" title="1">if len(req.Message) &gt; 100000 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("message must be at most 100000 characters")
        }</span>
        <span class="cov8" title="1">if req.CanonicalID != nil </span><span class="cov8" title="1">{
                if _, err := uuid.Parse(*req.CanonicalID); err != nil </span><span class="cov8" title="1">{
                        return apperror.ErrBadRequest.WithMessage("invalid canonicalId format")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func validateUpdateConversationRequest(req *UpdateConversationRequest) error <span class="cov8" title="1">{
        if req.Title != nil &amp;&amp; len(*req.Title) &gt; 512 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("title must be at most 512 characters")
        }</span>
        <span class="cov8" title="1">if req.DraftText != nil &amp;&amp; len(*req.DraftText) &gt; 100000 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("draftText must be at most 100000 characters")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateAddMessageRequest(req *AddMessageRequest) error <span class="cov8" title="1">{
        validRoles := map[string]bool{
                RoleUser:      true,
                RoleAssistant: true,
                RoleSystem:    true,
        }
        if !validRoles[req.Role] </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("role must be one of: user, assistant, system")
        }</span>
        <span class="cov8" title="1">if req.Content == "" </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("content is required")
        }</span>
        <span class="cov8" title="1">if len(req.Content) &gt; 100000 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("content must be at most 100000 characters")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func validateStreamRequest(req *StreamRequest) error <span class="cov8" title="1">{
        if strings.TrimSpace(req.Message) == "" </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("message is required")
        }</span>
        <span class="cov8" title="1">if len(req.Message) &gt; 100000 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("message must be at most 100000 characters")
        }</span>
        <span class="cov8" title="1">if req.ConversationID != nil </span><span class="cov8" title="1">{
                if _, err := uuid.Parse(*req.ConversationID); err != nil </span><span class="cov8" title="1">{
                        return apperror.ErrBadRequest.WithMessage("invalid conversationId format")
                }</span>
        }
        <span class="cov8" title="1">if req.CanonicalID != nil </span><span class="cov8" title="1">{
                if _, err := uuid.Parse(*req.CanonicalID); err != nil </span><span class="cov8" title="1">{
                        return apperror.ErrBadRequest.WithMessage("invalid canonicalId format")
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// StreamChat handles POST /api/v2/chat/stream
// This is the SSE streaming endpoint for chat completions
func (h *Handler) StreamChat(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        // Parse and validate request BEFORE setting SSE headers
        // This allows us to return proper JSON errors for bad requests
        <span class="cov8" title="1">var req StreamRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>
        <span class="cov8" title="1">if err := validateStreamRequest(&amp;req); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">ctx := c.Request().Context()
        message := strings.TrimSpace(req.Message)

        // Get or create conversation
        var convID uuid.UUID
        if req.ConversationID != nil </span><span class="cov8" title="1">{
                // Use existing conversation
                parsed, _ := uuid.Parse(*req.ConversationID) // Already validated
                conv, err := h.svc.GetConversation(ctx, user.ProjectID, parsed)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">convID = conv.ID

                // Persist the user message
                _, err = h.svc.AddMessage(ctx, user.ProjectID, convID, AddMessageRequest{
                        Role:    RoleUser,
                        Content: message,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                // Create new conversation
                title := message
                if len(title) &gt; 50 </span><span class="cov8" title="1">{
                        title = title[:50] + "..."
                }</span>

                <span class="cov8" title="1">createReq := CreateConversationRequest{
                        Title:       title,
                        Message:     message,
                        CanonicalID: req.CanonicalID,
                }
                conv, err := h.svc.CreateConversation(ctx, user.ProjectID, user.ID, createReq)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">convID = conv.ID</span>
        }

        // Now that validation is done and conversation is ready, start SSE streaming
        <span class="cov8" title="1">w := c.Response().Writer
        sseWriter := sse.NewWriter(w)
        if err := sseWriter.Start(); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrInternal.WithMessage("failed to start SSE stream")
        }</span>

        // Emit meta event first
        <span class="cov8" title="1">metaEvent := sse.NewMetaEvent(convID.String())
        if err := sseWriter.WriteData(metaEvent); err != nil </span><span class="cov0" title="0">{
                // SSE already started, can't return error - just log and continue
                return nil
        }</span>

        // Check for deterministic test mode
        <span class="cov8" title="1">if os.Getenv("CHAT_TEST_DETERMINISTIC") == "1" </span><span class="cov0" title="0">{
                // Emit synthetic tokens for testing
                for i := 0; i &lt; 5; i++ </span><span class="cov0" title="0">{
                        sseWriter.WriteData(sse.NewTokenEvent("token-" + strconv.Itoa(i)))
                        if i &lt; 4 </span><span class="cov0" title="0">{
                                sseWriter.WriteData(sse.NewTokenEvent(" "))
                        }</span>
                }
                <span class="cov0" title="0">sseWriter.WriteData(sse.NewDoneEvent())
                sseWriter.Close()
                return nil</span>
        }

        // Check if LLM client is available
        <span class="cov8" title="1">if h.llmClient == nil || !h.llmClient.IsAvailable() </span><span class="cov8" title="1">{
                // Emit error and synthetic response
                sseWriter.WriteData(sse.NewErrorEvent("LLM service not configured"))
                sseWriter.WriteData(sse.NewTokenEvent("I'm sorry, but the chat service is not currently available. Please try again later."))
                sseWriter.WriteData(sse.NewDoneEvent())
                sseWriter.Close()
                return nil
        }</span>

        // Build prompt
        <span class="cov0" title="0">systemPrompt := os.Getenv("CHAT_SYSTEM_PROMPT")
        if systemPrompt == "" </span><span class="cov0" title="0">{
                systemPrompt = "You are a helpful assistant specialized in knowledge graphs and data schemas. Answer questions clearly using markdown formatting."
        }</span>

        // Stream tokens from LLM
        <span class="cov0" title="0">var fullResponse strings.Builder
        err := h.llmClient.GenerateStreaming(ctx, vertex.GenerateRequest{
                Prompt:       message,
                SystemPrompt: systemPrompt,
        }, func(token string) </span><span class="cov0" title="0">{
                fullResponse.WriteString(token)
                sseWriter.WriteData(sse.NewTokenEvent(token))
        }</span>)

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                // Emit error event
                sseWriter.WriteData(sse.NewErrorEvent(err.Error()))
        }</span> else<span class="cov0" title="0"> {
                // Persist assistant response
                go func() </span><span class="cov0" title="0">{
                        // Use a background context since the request context may be cancelled
                        _, _ = h.svc.AddMessage(ctx, user.ProjectID, convID, AddMessageRequest{
                                Role:    RoleAssistant,
                                Content: fullResponse.String(),
                        })
                }</span>()
        }

        // Emit done event
        <span class="cov0" title="0">sseWriter.WriteData(sse.NewDoneEvent())
        sseWriter.Close()

        return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package chat

import (
        "context"
        "log/slog"

        "go.uber.org/fx"

        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/pkg/llm/vertex"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Module provides chat functionality
var Module = fx.Module("chat",
        fx.Provide(
                NewRepository,
                NewService,
                NewLLMClient,
                NewHandler,
        ),
        fx.Invoke(RegisterRoutes),
)

// NewLLMClient creates a Vertex AI chat client if configured
func NewLLMClient(cfg *config.Config, log *slog.Logger) (*vertex.Client, error) <span class="cov0" title="0">{
        scopedLog := log.With(logger.Scope("chat.llm"))

        if !cfg.LLM.IsEnabled() </span><span class="cov0" title="0">{
                scopedLog.Warn("LLM client disabled or not configured")
                return nil, nil
        }</span>

        <span class="cov0" title="0">client, err := vertex.NewClient(context.Background(), vertex.Config{
                ProjectID:       cfg.LLM.GCPProjectID,
                Location:        cfg.LLM.VertexAILocation,
                Model:           cfg.LLM.Model,
                Timeout:         cfg.LLM.Timeout,
                Temperature:     cfg.LLM.Temperature,
                MaxOutputTokens: cfg.LLM.MaxOutputTokens,
        }, vertex.WithLogger(scopedLog))

        if err != nil </span><span class="cov0" title="0">{
                scopedLog.Error("failed to create LLM client", slog.String("error", err.Error()))
                // Return nil client instead of error to allow server to start without LLM
                return nil, nil
        }</span>

        <span class="cov0" title="0">scopedLog.Info("LLM client initialized",
                slog.String("project", cfg.LLM.GCPProjectID),
                slog.String("location", cfg.LLM.VertexAILocation),
                slog.String("model", cfg.LLM.Model),
        )

        return client, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package chat

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"

        "github.com/google/uuid"
        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
        "github.com/emergent/emergent-core/pkg/pgutils"
)

// Repository handles chat database operations
type Repository struct {
        db  bun.IDB
        log *slog.Logger
}

// NewRepository creates a new chat repository
func NewRepository(db bun.IDB, log *slog.Logger) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                db:  db,
                log: log.With(logger.Scope("chat.repo")),
        }
}</span>

// ListConversations retrieves conversations with pagination
func (r *Repository) ListConversations(ctx context.Context, params ListConversationsParams) (*ListConversationsResult, error) <span class="cov8" title="1">{
        // Default and max limits
        if params.Limit &lt;= 0 </span><span class="cov0" title="0">{
                params.Limit = 50
        }</span>
        <span class="cov8" title="1">if params.Limit &gt; 100 </span><span class="cov0" title="0">{
                params.Limit = 100
        }</span>

        // Build query with RLS context via project_id
        <span class="cov8" title="1">query := r.db.NewSelect().
                Model((*Conversation)(nil)).
                Where("project_id = ?", params.ProjectID)

        // Apply owner filter if provided
        if params.OwnerUserID != nil </span><span class="cov8" title="1">{
                query = query.Where("(owner_user_id = ? OR is_private = false)", *params.OwnerUserID)
        }</span>

        // Get total count
        <span class="cov8" title="1">total, err := r.db.NewSelect().
                Model((*Conversation)(nil)).
                Where("project_id = ?", params.ProjectID).
                Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("count conversations: %w", err)
        }</span>

        // Order by updated_at DESC (most recent first)
        <span class="cov8" title="1">query = query.Order("updated_at DESC").
                Offset(params.Offset).
                Limit(params.Limit)

        conversations := []Conversation{}
        if err := query.Scan(ctx, &amp;conversations); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list conversations: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ListConversationsResult{
                Conversations: conversations,
                Total:         total,
        }, nil</span>
}

// GetByID retrieves a conversation by ID
func (r *Repository) GetByID(ctx context.Context, projectID string, conversationID uuid.UUID) (*Conversation, error) <span class="cov8" title="1">{
        var conv Conversation
        err := r.db.NewSelect().
                Model(&amp;conv).
                Where("id = ?", conversationID).
                Where("project_id = ?", projectID).
                Scan(ctx)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get conversation: %w", err)</span>
        }

        <span class="cov8" title="1">return &amp;conv, nil</span>
}

// GetByIDWithMessages retrieves a conversation with all its messages
func (r *Repository) GetByIDWithMessages(ctx context.Context, projectID string, conversationID uuid.UUID) (*Conversation, error) <span class="cov8" title="1">{
        var conv Conversation
        err := r.db.NewSelect().
                Model(&amp;conv).
                Relation("Messages", func(q *bun.SelectQuery) *bun.SelectQuery </span><span class="cov8" title="1">{
                        return q.Order("created_at ASC")
                }</span>).
                Where("conversation.id = ?", conversationID).
                Where("conversation.project_id = ?", projectID).
                Scan(ctx)

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get conversation with messages: %w", err)</span>
        }

        <span class="cov8" title="1">return &amp;conv, nil</span>
}

// GetByCanonicalID retrieves a conversation by canonical ID (for object refinement chats)
func (r *Repository) GetByCanonicalID(ctx context.Context, projectID string, canonicalID uuid.UUID) (*Conversation, error) <span class="cov8" title="1">{
        var conv Conversation
        err := r.db.NewSelect().
                Model(&amp;conv).
                Where("canonical_id = ?", canonicalID).
                Where("project_id = ?", projectID).
                Scan(ctx)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get conversation by canonical ID: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;conv, nil</span>
}

// Create creates a new conversation
func (r *Repository) Create(ctx context.Context, conv *Conversation) error <span class="cov0" title="0">{
        _, err := r.db.NewInsert().
                Model(conv).
                Returning("*").
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if pgutils.IsUniqueViolation(err) </span><span class="cov0" title="0">{
                        return apperror.New(409, "duplicate", "A conversation with this canonical ID already exists")
                }</span>
                <span class="cov0" title="0">if pgutils.IsForeignKeyViolation(err) </span><span class="cov0" title="0">{
                        return apperror.New(400, "invalid-reference", "Referenced project or object not found")
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to create conversation", logger.Error(err))
                return apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Update updates a conversation
func (r *Repository) Update(ctx context.Context, projectID string, conv *Conversation) error <span class="cov8" title="1">{
        result, err := r.db.NewUpdate().
                Model(conv).
                WherePK().
                Where("project_id = ?", projectID).
                Returning("*").
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to update conversation", logger.Error(err))
                return apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                return apperror.ErrNotFound.WithMessage("Conversation not found")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Delete deletes a conversation (cascades to messages via FK)
func (r *Repository) Delete(ctx context.Context, projectID string, conversationID uuid.UUID) (bool, error) <span class="cov8" title="1">{
        result, err := r.db.NewDelete().
                Model((*Conversation)(nil)).
                Where("id = ?", conversationID).
                Where("project_id = ?", projectID).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to delete conversation", logger.Error(err))
                return false, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()
        return rowsAffected &gt; 0, nil</span>
}

// AddMessage adds a message to a conversation
func (r *Repository) AddMessage(ctx context.Context, msg *Message) error <span class="cov8" title="1">{
        _, err := r.db.NewInsert().
                Model(msg).
                Returning("*").
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if pgutils.IsForeignKeyViolation(err) </span><span class="cov0" title="0">{
                        return apperror.ErrNotFound.WithMessage("Conversation not found")
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to add message", logger.Error(err))
                return apperror.ErrDatabase.WithInternal(err)</span>
        }

        // Update conversation's updated_at
        <span class="cov8" title="1">_, err = r.db.NewUpdate().
                Model((*Conversation)(nil)).
                Set("updated_at = NOW()").
                Where("id = ?", msg.ConversationID).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Warn("failed to update conversation timestamp", logger.Error(err))
                // Don't fail the operation for this
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GetMessages retrieves messages for a conversation
func (r *Repository) GetMessages(ctx context.Context, conversationID uuid.UUID, limit int) ([]Message, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>
        <span class="cov0" title="0">if limit &gt; 1000 </span><span class="cov0" title="0">{
                limit = 1000
        }</span>

        <span class="cov0" title="0">messages := []Message{}
        err := r.db.NewSelect().
                Model(&amp;messages).
                Where("conversation_id = ?", conversationID).
                Order("created_at ASC").
                Limit(limit).
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get messages: %w", err)
        }</span>

        <span class="cov0" title="0">return messages, nil</span>
}

// CreateConversationWithMessage creates a conversation and its first message in a transaction
func (r *Repository) CreateConversationWithMessage(ctx context.Context, conv *Conversation, msg *Message) error <span class="cov8" title="1">{
        return r.db.RunInTx(ctx, nil, func(ctx context.Context, tx bun.Tx) error </span><span class="cov8" title="1">{
                // Create conversation
                _, err := tx.NewInsert().
                        Model(conv).
                        Returning("*").
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        if pgutils.IsUniqueViolation(err) </span><span class="cov0" title="0">{
                                return apperror.New(409, "duplicate", "A conversation with this canonical ID already exists")
                        }</span>
                        <span class="cov0" title="0">if pgutils.IsForeignKeyViolation(err) </span><span class="cov0" title="0">{
                                return apperror.New(400, "invalid-reference", "Referenced project or object not found")
                        }</span>
                        <span class="cov0" title="0">return apperror.ErrDatabase.WithInternal(err)</span>
                }

                // Set conversation ID on message
                <span class="cov8" title="1">msg.ConversationID = conv.ID

                // Create message
                _, err = tx.NewInsert().
                        Model(msg).
                        Returning("*").
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return apperror.ErrDatabase.WithInternal(err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package chat

import (
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/auth"
)

// RegisterRoutes registers chat routes with the Echo router
func RegisterRoutes(e *echo.Echo, h *Handler, authMiddleware *auth.Middleware) <span class="cov8" title="1">{
        // Base group for chat - all routes require authentication and project ID
        g := e.Group("/api/v2/chat")
        g.Use(authMiddleware.RequireAuth())
        g.Use(authMiddleware.RequireProjectID())

        // All chat operations require chat:use scope
        g.Use(authMiddleware.RequireScopes("chat:use"))

        // Streaming endpoint - POST /api/v2/chat/stream
        g.POST("/stream", h.StreamChat)

        // Conversation CRUD
        g.GET("/conversations", h.ListConversations)
        g.POST("/conversations", h.CreateConversation)
        g.GET("/:id", h.GetConversation)

        // Admin operations - require chat:admin scope
        adminGroup := g.Group("")
        adminGroup.Use(authMiddleware.RequireScopes("chat:admin"))
        adminGroup.PATCH("/:id", h.UpdateConversation)
        adminGroup.DELETE("/:id", h.DeleteConversation)

        // Message operations
        g.POST("/:id/messages", h.AddMessage)
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package chat

import (
        "context"
        "log/slog"
        "time"

        "github.com/google/uuid"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Service provides business logic for chat operations
type Service struct {
        repo *Repository
        log  *slog.Logger
}

// NewService creates a new chat service
func NewService(repo *Repository, log *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: repo,
                log:  log.With(logger.Scope("chat.svc")),
        }
}</span>

// ListConversations returns a paginated list of conversations for a project
func (s *Service) ListConversations(ctx context.Context, projectID string, ownerUserID *string, limit, offset int) (*ListConversationsResult, error) <span class="cov8" title="1">{
        return s.repo.ListConversations(ctx, ListConversationsParams{
                ProjectID:   projectID,
                OwnerUserID: ownerUserID,
                Limit:       limit,
                Offset:      offset,
        })
}</span>

// GetConversation retrieves a conversation by ID
func (s *Service) GetConversation(ctx context.Context, projectID string, conversationID uuid.UUID) (*Conversation, error) <span class="cov8" title="1">{
        conv, err := s.repo.GetByID(ctx, projectID, conversationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if conv == nil </span><span class="cov8" title="1">{
                return nil, apperror.ErrNotFound.WithMessage("Conversation not found")
        }</span>
        <span class="cov8" title="1">return conv, nil</span>
}

// GetConversationWithMessages retrieves a conversation with all its messages
func (s *Service) GetConversationWithMessages(ctx context.Context, projectID string, conversationID uuid.UUID) (*Conversation, error) <span class="cov8" title="1">{
        conv, err := s.repo.GetByIDWithMessages(ctx, projectID, conversationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if conv == nil </span><span class="cov8" title="1">{
                return nil, apperror.ErrNotFound.WithMessage("Conversation not found")
        }</span>
        <span class="cov8" title="1">return conv, nil</span>
}

// CreateConversation creates a new conversation with an initial message
func (s *Service) CreateConversation(ctx context.Context, projectID, ownerUserID string, req CreateConversationRequest) (*Conversation, error) <span class="cov8" title="1">{
        projectUUID, err := uuid.Parse(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.New(400, "invalid-project-id", "Invalid project ID format")
        }</span>

        // Parse canonical ID if provided
        <span class="cov8" title="1">var canonicalID *uuid.UUID
        if req.CanonicalID != nil </span><span class="cov8" title="1">{
                parsed, err := uuid.Parse(*req.CanonicalID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.New(400, "invalid-canonical-id", "Invalid canonical ID format")
                }</span>
                <span class="cov8" title="1">canonicalID = &amp;parsed

                // Check if conversation already exists for this canonical ID
                existing, err := s.repo.GetByCanonicalID(ctx, projectID, parsed)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if existing != nil </span><span class="cov0" title="0">{
                        // Return existing conversation instead of creating duplicate
                        return existing, nil
                }</span>
        }

        <span class="cov8" title="1">now := time.Now()
        conv := &amp;Conversation{
                Title:       req.Title,
                OwnerUserID: &amp;ownerUserID,
                IsPrivate:   true,
                ProjectID:   &amp;projectUUID,
                CanonicalID: canonicalID,
                CreatedAt:   now,
                UpdatedAt:   now,
        }

        // Create the initial user message
        msg := &amp;Message{
                Role:      RoleUser,
                Content:   req.Message,
                CreatedAt: now,
        }

        if err := s.repo.CreateConversationWithMessage(ctx, conv, msg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Return conversation with the initial message
        <span class="cov8" title="1">conv.Messages = []Message{*msg}
        return conv, nil</span>
}

// UpdateConversation updates a conversation's title or draft text
func (s *Service) UpdateConversation(ctx context.Context, projectID string, conversationID uuid.UUID, req UpdateConversationRequest) (*Conversation, error) <span class="cov8" title="1">{
        // First, get the existing conversation
        conv, err := s.repo.GetByID(ctx, projectID, conversationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if conv == nil </span><span class="cov8" title="1">{
                return nil, apperror.ErrNotFound.WithMessage("Conversation not found")
        }</span>

        // Apply updates
        <span class="cov8" title="1">if req.Title != nil </span><span class="cov8" title="1">{
                conv.Title = *req.Title
        }</span>
        <span class="cov8" title="1">if req.DraftText != nil </span><span class="cov0" title="0">{
                conv.DraftText = req.DraftText
        }</span>
        <span class="cov8" title="1">conv.UpdatedAt = time.Now()

        if err := s.repo.Update(ctx, projectID, conv); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return conv, nil</span>
}

// DeleteConversation deletes a conversation and all its messages
func (s *Service) DeleteConversation(ctx context.Context, projectID string, conversationID uuid.UUID) error <span class="cov8" title="1">{
        deleted, err := s.repo.Delete(ctx, projectID, conversationID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !deleted </span><span class="cov8" title="1">{
                return apperror.ErrNotFound.WithMessage("Conversation not found")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AddMessage adds a message to a conversation
func (s *Service) AddMessage(ctx context.Context, projectID string, conversationID uuid.UUID, req AddMessageRequest) (*Message, error) <span class="cov8" title="1">{
        // Verify conversation exists
        conv, err := s.repo.GetByID(ctx, projectID, conversationID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if conv == nil </span><span class="cov8" title="1">{
                return nil, apperror.ErrNotFound.WithMessage("Conversation not found")
        }</span>

        <span class="cov8" title="1">msg := &amp;Message{
                ConversationID: conversationID,
                Role:           req.Role,
                Content:        req.Content,
                CreatedAt:      time.Now(),
        }

        if err := s.repo.AddMessage(ctx, msg); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return msg, nil</span>
}

// GetOrCreateConversation gets an existing conversation by canonical ID or creates a new one
func (s *Service) GetOrCreateConversation(ctx context.Context, projectID, ownerUserID string, canonicalID string, title string) (*Conversation, bool, error) <span class="cov0" title="0">{
        projectUUID, err := uuid.Parse(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, apperror.New(400, "invalid-project-id", "Invalid project ID format")
        }</span>

        <span class="cov0" title="0">canonicalUUID, err := uuid.Parse(canonicalID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, apperror.New(400, "invalid-canonical-id", "Invalid canonical ID format")
        }</span>

        // Try to get existing
        <span class="cov0" title="0">existing, err := s.repo.GetByCanonicalID(ctx, projectID, canonicalUUID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                return existing, false, nil
        }</span>

        // Create new
        <span class="cov0" title="0">now := time.Now()
        conv := &amp;Conversation{
                Title:       title,
                OwnerUserID: &amp;ownerUserID,
                IsPrivate:   false, // Refinement chats are shared
                ProjectID:   &amp;projectUUID,
                CanonicalID: &amp;canonicalUUID,
                CreatedAt:   now,
                UpdatedAt:   now,
        }

        if err := s.repo.Create(ctx, conv); err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">return conv, true, nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package chunks

import (
        "encoding/json"
        "time"

        "github.com/google/uuid"
        "github.com/uptrace/bun"
)

// Chunk represents a chunk of text from a document in the kb.chunks table
type Chunk struct {
        bun.BaseModel `bun:"table:kb.chunks,alias:c"`

        ID          uuid.UUID        `bun:"id,pk,type:uuid,default:uuid_generate_v4()" json:"id"`
        DocumentID  uuid.UUID        `bun:"document_id,type:uuid,notnull" json:"documentId"`
        ChunkIndex  int              `bun:"chunk_index,notnull" json:"chunkIndex"`
        Text        string           `bun:"text,notnull" json:"text"`
        Embedding   []byte           `bun:"embedding,type:vector(768)" json:"-"` // pgvector stored as bytes
        TSV         string           `bun:"tsv,type:tsvector" json:"-"`          // Full-text search vector
        Metadata    *ChunkMetadata   `bun:"metadata,type:jsonb" json:"metadata,omitempty"`
        CreatedAt   time.Time        `bun:"created_at,notnull,default:now()" json:"createdAt"`
        UpdatedAt   time.Time        `bun:"updated_at,notnull,default:now()" json:"updatedAt"`
}

// ChunkMetadata contains metadata about how the chunk was created
type ChunkMetadata struct {
        Strategy     string `json:"strategy,omitempty"`     // character, sentence, paragraph
        StartOffset  int    `json:"startOffset,omitempty"`  // Character offset in original document
        EndOffset    int    `json:"endOffset,omitempty"`    // Character offset in original document
        BoundaryType string `json:"boundaryType,omitempty"` // sentence, paragraph, character, section
}

// ChunkDTO is the response format for chunks
type ChunkDTO struct {
        ID             string         `json:"id"`
        DocumentID     string         `json:"documentId"`
        DocumentTitle  string         `json:"documentTitle,omitempty"`
        Index          int            `json:"index"`
        Size           int            `json:"size"`          // Size in characters
        HasEmbedding   bool           `json:"hasEmbedding"`
        Text           string         `json:"text"`
        CreatedAt      string         `json:"createdAt,omitempty"`
        Metadata       *ChunkMetadata `json:"metadata,omitempty"`
        TotalChars     *int           `json:"totalChars,omitempty"`     // Total chars across all doc chunks
        ChunkCount     *int           `json:"chunkCount,omitempty"`     // Total chunks in document
        EmbeddedChunks *int           `json:"embeddedChunks,omitempty"` // Chunks with embeddings in document
}

// ChunkWithDocInfo is used for queries that join with documents table
type ChunkWithDocInfo struct {
        Chunk
        DocumentFilename  *string `bun:"document_filename"`
        DocumentSourceURL *string `bun:"document_source_url"`
        TotalChars        *int    `bun:"total_chars"`
        ChunkCount        *int    `bun:"chunk_count"`
        EmbeddedChunks    *int    `bun:"embedded_chunks"`
}

// ToDTO converts a ChunkWithDocInfo to a ChunkDTO
func (c *ChunkWithDocInfo) ToDTO() *ChunkDTO <span class="cov8" title="1">{
        // Determine document title from filename or source_url
        title := ""
        if c.DocumentFilename != nil &amp;&amp; *c.DocumentFilename != "" </span><span class="cov8" title="1">{
                title = *c.DocumentFilename
        }</span> else<span class="cov8" title="1"> if c.DocumentSourceURL != nil &amp;&amp; *c.DocumentSourceURL != "" </span><span class="cov8" title="1">{
                title = *c.DocumentSourceURL
        }</span>

        <span class="cov8" title="1">return &amp;ChunkDTO{
                ID:             c.ID.String(),
                DocumentID:     c.DocumentID.String(),
                DocumentTitle:  title,
                Index:          c.ChunkIndex,
                Size:           len(c.Text),
                HasEmbedding:   len(c.Embedding) &gt; 0,
                Text:           c.Text,
                CreatedAt:      c.CreatedAt.Format(time.RFC3339),
                Metadata:       c.Metadata,
                TotalChars:     c.TotalChars,
                ChunkCount:     c.ChunkCount,
                EmbeddedChunks: c.EmbeddedChunks,
        }</span>
}

// ListChunksResponse is the response for listing chunks
type ListChunksResponse struct {
        Data       []*ChunkDTO `json:"data"`
        TotalCount int         `json:"totalCount"`
}

// BulkDeleteRequest is the request for bulk deleting chunks
type BulkDeleteRequest struct {
        IDs []string `json:"ids" validate:"required,min=1"`
}

// BulkDeleteByDocumentsRequest is the request for bulk deleting chunks by documents
type BulkDeleteByDocumentsRequest struct {
        DocumentIDs []string `json:"documentIds" validate:"required,min=1"`
}

// DeletionResult represents the result of a single deletion
type DeletionResult struct {
        ID      string `json:"id"`
        Success bool   `json:"success"`
        Error   string `json:"error,omitempty"`
}

// BulkDeletionSummary is the response for bulk deletion
type BulkDeletionSummary struct {
        TotalRequested int               `json:"totalRequested"`
        TotalDeleted   int               `json:"totalDeleted"`
        TotalFailed    int               `json:"totalFailed"`
        Results        []*DeletionResult `json:"results"`
}

// DocumentChunksDeletionResult is the result of deleting all chunks for a document
type DocumentChunksDeletionResult struct {
        DocumentID   string `json:"documentId"`
        ChunksDeleted int    `json:"chunksDeleted"`
        Success      bool   `json:"success"`
        Error        string `json:"error,omitempty"`
}

// BulkDocumentChunksDeletionSummary is the response for bulk document chunks deletion
type BulkDocumentChunksDeletionSummary struct {
        TotalDocuments int                           `json:"totalDocuments"`
        TotalChunks    int                           `json:"totalChunks"`
        Results        []*DocumentChunksDeletionResult `json:"results"`
}

// CreateChunkRequest is the request for creating a chunk (used internally)
type CreateChunkRequest struct {
        DocumentID string         `json:"documentId" validate:"required,uuid"`
        ChunkIndex int            `json:"chunkIndex" validate:"gte=0"`
        Text       string         `json:"text" validate:"required"`
        Metadata   *ChunkMetadata `json:"metadata,omitempty"`
}

// Scan implements the sql.Scanner interface for ChunkMetadata
func (m *ChunkMetadata) Scan(src interface{}) error <span class="cov8" title="1">{
        if src == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">switch v := src.(type) </span>{
        case []byte:<span class="cov8" title="1">
                return json.Unmarshal(v, m)</span>
        case string:<span class="cov8" title="1">
                return json.Unmarshal([]byte(v), m)</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package chunks

import (
        "net/http"

        "github.com/google/uuid"
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

// Handler handles HTTP requests for chunks
type Handler struct {
        svc *Service
}

// NewHandler creates a new chunks handler
func NewHandler(svc *Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{svc: svc}
}</span>

// getProjectID extracts and parses the project ID from the request context.
func getProjectID(c echo.Context) (uuid.UUID, error) <span class="cov8" title="1">{
        projectIDStr, err := auth.GetProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, err
        }</span>

        <span class="cov8" title="1">projectID, err := uuid.Parse(projectIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.ErrBadRequest.WithMessage("invalid project ID")
        }</span>

        <span class="cov8" title="1">return projectID, nil</span>
}

// List handles GET /chunks
// @Summary List chunks
// @Description List all chunks for the project, optionally filtered by document ID
// @Tags chunks
// @Accept json
// @Produce json
// @Param documentId query string false "Filter by document ID"
// @Success 200 {object} ListChunksResponse
// @Failure 400 {object} apperror.Error
// @Failure 401 {object} apperror.Error
// @Failure 403 {object} apperror.Error
// @Router /chunks [get]
func (h *Handler) List(c echo.Context) error <span class="cov8" title="1">{
        projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Parse optional document ID filter
        <span class="cov8" title="1">var documentID *uuid.UUID
        if docIDStr := c.QueryParam("documentId"); docIDStr != "" </span><span class="cov8" title="1">{
                parsed, err := uuid.Parse(docIDStr)
                if err != nil </span><span class="cov8" title="1">{
                        return apperror.ErrBadRequest.WithMessage("invalid document ID")
                }</span>
                <span class="cov8" title="1">documentID = &amp;parsed</span>
        }

        <span class="cov8" title="1">response, err := h.svc.List(c.Request().Context(), projectID, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, response)</span>
}

// Delete handles DELETE /chunks/:id
// @Summary Delete a chunk
// @Description Delete a single chunk by ID
// @Tags chunks
// @Accept json
// @Produce json
// @Param id path string true "Chunk ID"
// @Success 204
// @Failure 400 {object} apperror.Error
// @Failure 401 {object} apperror.Error
// @Failure 403 {object} apperror.Error
// @Failure 404 {object} apperror.Error
// @Router /chunks/{id} [delete]
func (h *Handler) Delete(c echo.Context) error <span class="cov8" title="1">{
        projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">chunkID, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("invalid chunk ID")
        }</span>

        <span class="cov8" title="1">if err := h.svc.Delete(c.Request().Context(), projectID, chunkID); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.NoContent(http.StatusNoContent)</span>
}

// BulkDelete handles DELETE /chunks
// @Summary Bulk delete chunks
// @Description Delete multiple chunks by IDs
// @Tags chunks
// @Accept json
// @Produce json
// @Param body body BulkDeleteRequest true "Chunk IDs to delete"
// @Success 200 {object} BulkDeletionSummary
// @Failure 400 {object} apperror.Error
// @Failure 401 {object} apperror.Error
// @Failure 403 {object} apperror.Error
// @Router /chunks [delete]
func (h *Handler) BulkDelete(c echo.Context) error <span class="cov8" title="1">{
        projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var req BulkDeleteRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        <span class="cov8" title="1">if len(req.IDs) == 0 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("ids array cannot be empty")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.BulkDelete(c.Request().Context(), projectID, req.IDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// DeleteByDocument handles DELETE /chunks/by-document/:documentId
// @Summary Delete chunks by document
// @Description Delete all chunks for a specific document
// @Tags chunks
// @Accept json
// @Produce json
// @Param documentId path string true "Document ID"
// @Success 200 {object} DocumentChunksDeletionResult
// @Failure 400 {object} apperror.Error
// @Failure 401 {object} apperror.Error
// @Failure 403 {object} apperror.Error
// @Router /chunks/by-document/{documentId} [delete]
func (h *Handler) DeleteByDocument(c echo.Context) error <span class="cov8" title="1">{
        projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">documentID, err := uuid.Parse(c.Param("documentId"))
        if err != nil </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("invalid document ID")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.DeleteByDocument(c.Request().Context(), projectID, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// BulkDeleteByDocuments handles DELETE /chunks/by-documents
// @Summary Bulk delete chunks by documents
// @Description Delete all chunks for multiple documents
// @Tags chunks
// @Accept json
// @Produce json
// @Param body body BulkDeleteByDocumentsRequest true "Document IDs"
// @Success 200 {object} BulkDocumentChunksDeletionSummary
// @Failure 400 {object} apperror.Error
// @Failure 401 {object} apperror.Error
// @Failure 403 {object} apperror.Error
// @Router /chunks/by-documents [delete]
func (h *Handler) BulkDeleteByDocuments(c echo.Context) error <span class="cov8" title="1">{
        projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var req BulkDeleteByDocumentsRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        <span class="cov8" title="1">if len(req.DocumentIDs) == 0 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("documentIds array cannot be empty")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.BulkDeleteByDocuments(c.Request().Context(), projectID, req.DocumentIDs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package chunks

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"

        "github.com/google/uuid"
        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Repository handles database operations for chunks
type Repository struct {
        db  bun.IDB
        log *slog.Logger
}

// NewRepository creates a new chunks repository
func NewRepository(db bun.IDB, log *slog.Logger) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                db:  db,
                log: log.With(logger.Scope("chunks.repo")),
        }
}</span>

// ListByProject returns all chunks for a project, optionally filtered by document ID
func (r *Repository) ListByProject(ctx context.Context, projectID uuid.UUID, documentID *uuid.UUID) ([]*ChunkWithDocInfo, error) <span class="cov8" title="1">{
        var chunks []*ChunkWithDocInfo

        // Build query with join to documents for document info and RLS
        // Use a subquery for aggregate stats to avoid cartesian product
        query := r.db.NewSelect().
                TableExpr("kb.chunks AS c").
                ColumnExpr("c.*").
                ColumnExpr("d.filename AS document_filename").
                ColumnExpr("d.source_url AS document_source_url").
                ColumnExpr("stats.total_chars").
                ColumnExpr("stats.chunk_count").
                ColumnExpr("stats.embedded_chunks").
                Join("INNER JOIN kb.documents AS d ON d.id = c.document_id").
                Join(`LEFT JOIN LATERAL (
                        SELECT 
                                SUM(LENGTH(text)) AS total_chars,
                                COUNT(*) AS chunk_count,
                                COUNT(embedding) FILTER (WHERE embedding IS NOT NULL) AS embedded_chunks
                        FROM kb.chunks 
                        WHERE document_id = c.document_id
                ) AS stats ON true`).
                Where("d.project_id = ?", projectID).
                Order("c.document_id", "c.chunk_index")

        if documentID != nil </span><span class="cov8" title="1">{
                query = query.Where("c.document_id = ?", *documentID)
        }</span>

        <span class="cov8" title="1">err := query.Scan(ctx, &amp;chunks)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to list chunks", "error", err, "projectId", projectID)
                return nil, apperror.NewInternal("failed to list chunks", err)
        }</span>

        <span class="cov8" title="1">return chunks, nil</span>
}

// GetByID retrieves a single chunk by ID within a project
func (r *Repository) GetByID(ctx context.Context, projectID, chunkID uuid.UUID) (*ChunkWithDocInfo, error) <span class="cov0" title="0">{
        var chunk ChunkWithDocInfo

        err := r.db.NewSelect().
                TableExpr("kb.chunks AS c").
                ColumnExpr("c.*").
                ColumnExpr("d.filename AS document_filename").
                ColumnExpr("d.source_url AS document_source_url").
                Join("INNER JOIN kb.documents AS d ON d.id = c.document_id").
                Where("c.id = ?", chunkID).
                Where("d.project_id = ?", projectID).
                Scan(ctx, &amp;chunk)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, apperror.NewNotFound("chunk", chunkID.String())
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to get chunk", "error", err, "chunkId", chunkID)
                return nil, apperror.NewInternal("failed to get chunk", err)</span>
        }

        <span class="cov0" title="0">return &amp;chunk, nil</span>
}

// Create creates a new chunk
func (r *Repository) Create(ctx context.Context, chunk *Chunk) error <span class="cov0" title="0">{
        _, err := r.db.NewInsert().
                Model(chunk).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to create chunk", "error", err, "documentId", chunk.DocumentID)
                return apperror.NewInternal("failed to create chunk", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateBatch creates multiple chunks in a single transaction
func (r *Repository) CreateBatch(ctx context.Context, chunks []*Chunk) error <span class="cov0" title="0">{
        if len(chunks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">_, err := r.db.NewInsert().
                Model(&amp;chunks).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to create chunks batch", "error", err, "count", len(chunks))
                return apperror.NewInternal("failed to create chunks", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Delete deletes a chunk by ID within a project (RLS enforced via document join)
func (r *Repository) Delete(ctx context.Context, projectID, chunkID uuid.UUID) error <span class="cov8" title="1">{
        // First verify the chunk exists and belongs to the project
        var count int
        count, err := r.db.NewSelect().
                TableExpr("kb.chunks AS c").
                Join("INNER JOIN kb.documents AS d ON d.id = c.document_id").
                Where("c.id = ?", chunkID).
                Where("d.project_id = ?", projectID).
                Count(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to check chunk existence", "error", err, "chunkId", chunkID)
                return apperror.NewInternal("failed to delete chunk", err)
        }</span>

        <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                return apperror.NewNotFound("chunk", chunkID.String())
        }</span>

        // Delete the chunk
        <span class="cov8" title="1">_, err = r.db.NewDelete().
                Model((*Chunk)(nil)).
                Where("id = ?", chunkID).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to delete chunk", "error", err, "chunkId", chunkID)
                return apperror.NewInternal("failed to delete chunk", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// BulkDelete deletes multiple chunks by IDs within a project
func (r *Repository) BulkDelete(ctx context.Context, projectID uuid.UUID, chunkIDs []uuid.UUID) (*BulkDeletionSummary, error) <span class="cov8" title="1">{
        results := make([]*DeletionResult, 0, len(chunkIDs))
        totalDeleted := 0
        totalFailed := 0

        for _, chunkID := range chunkIDs </span><span class="cov8" title="1">{
                err := r.Delete(ctx, projectID, chunkID)
                if err != nil </span><span class="cov8" title="1">{
                        results = append(results, &amp;DeletionResult{
                                ID:      chunkID.String(),
                                Success: false,
                                Error:   err.Error(),
                        })
                        totalFailed++
                }</span> else<span class="cov8" title="1"> {
                        results = append(results, &amp;DeletionResult{
                                ID:      chunkID.String(),
                                Success: true,
                        })
                        totalDeleted++
                }</span>
        }

        <span class="cov8" title="1">return &amp;BulkDeletionSummary{
                TotalRequested: len(chunkIDs),
                TotalDeleted:   totalDeleted,
                TotalFailed:    totalFailed,
                Results:        results,
        }, nil</span>
}

// DeleteByDocument deletes all chunks for a document within a project
func (r *Repository) DeleteByDocument(ctx context.Context, projectID, documentID uuid.UUID) (*DocumentChunksDeletionResult, error) <span class="cov8" title="1">{
        // First verify document belongs to project and count chunks
        var count int
        count, err := r.db.NewSelect().
                TableExpr("kb.chunks AS c").
                Join("INNER JOIN kb.documents AS d ON d.id = c.document_id").
                Where("c.document_id = ?", documentID).
                Where("d.project_id = ?", projectID).
                Count(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to count document chunks", "error", err, "documentId", documentID)
                return &amp;DocumentChunksDeletionResult{
                        DocumentID:    documentID.String(),
                        ChunksDeleted: 0,
                        Success:       false,
                        Error:         "failed to count chunks",
                }, nil
        }</span>

        <span class="cov8" title="1">if count == 0 </span><span class="cov8" title="1">{
                // No chunks found - could be document doesn't exist or has no chunks
                return &amp;DocumentChunksDeletionResult{
                        DocumentID:    documentID.String(),
                        ChunksDeleted: 0,
                        Success:       true,
                }, nil
        }</span>

        // Delete all chunks for this document
        <span class="cov8" title="1">result, err := r.db.NewDelete().
                Model((*Chunk)(nil)).
                Where("document_id = ?", documentID).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to delete document chunks", "error", err, "documentId", documentID)
                return &amp;DocumentChunksDeletionResult{
                        DocumentID:    documentID.String(),
                        ChunksDeleted: 0,
                        Success:       false,
                        Error:         "failed to delete chunks",
                }, nil
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()

        return &amp;DocumentChunksDeletionResult{
                DocumentID:    documentID.String(),
                ChunksDeleted: int(rowsAffected),
                Success:       true,
        }, nil</span>
}

// BulkDeleteByDocuments deletes all chunks for multiple documents within a project
func (r *Repository) BulkDeleteByDocuments(ctx context.Context, projectID uuid.UUID, documentIDs []uuid.UUID) (*BulkDocumentChunksDeletionSummary, error) <span class="cov8" title="1">{
        results := make([]*DocumentChunksDeletionResult, 0, len(documentIDs))
        totalChunks := 0

        for _, docID := range documentIDs </span><span class="cov8" title="1">{
                result, err := r.DeleteByDocument(ctx, projectID, docID)
                if err != nil </span><span class="cov0" title="0">{
                        results = append(results, &amp;DocumentChunksDeletionResult{
                                DocumentID:    docID.String(),
                                ChunksDeleted: 0,
                                Success:       false,
                                Error:         err.Error(),
                        })
                }</span> else<span class="cov8" title="1"> {
                        results = append(results, result)
                        totalChunks += result.ChunksDeleted
                }</span>
        }

        <span class="cov8" title="1">return &amp;BulkDocumentChunksDeletionSummary{
                TotalDocuments: len(documentIDs),
                TotalChunks:    totalChunks,
                Results:        results,
        }, nil</span>
}

// UpdateEmbedding updates the embedding vector for a chunk
func (r *Repository) UpdateEmbedding(ctx context.Context, chunkID uuid.UUID, embedding []float32) error <span class="cov0" title="0">{
        // Convert float32 slice to PostgreSQL vector literal format
        vecLiteral := floatsToVectorLiteral(embedding)

        _, err := r.db.NewRaw(
                "UPDATE kb.chunks SET embedding = ?::vector, updated_at = now() WHERE id = ?",
                vecLiteral, chunkID,
        ).Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to update chunk embedding", "error", err, "chunkId", chunkID)
                return apperror.NewInternal("failed to update embedding", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// floatsToVectorLiteral converts a slice of float32 to PostgreSQL vector literal format
func floatsToVectorLiteral(vec []float32) string <span class="cov8" title="1">{
        if len(vec) == 0 </span><span class="cov8" title="1">{
                return "[]"
        }</span>

        <span class="cov8" title="1">result := "["
        for i, v := range vec </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        result += ","
                }</span>
                <span class="cov8" title="1">result += fmt.Sprintf("%g", v)</span>
        }
        <span class="cov8" title="1">result += "]"
        return result</span>
}

// CountByDocument returns the number of chunks for a document
func (r *Repository) CountByDocument(ctx context.Context, documentID uuid.UUID) (int, error) <span class="cov0" title="0">{
        count, err := r.db.NewSelect().
                Model((*Chunk)(nil)).
                Where("document_id = ?", documentID).
                Count(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to count chunks", "error", err, "documentId", documentID)
                return 0, apperror.NewInternal("failed to count chunks", err)
        }</span>

        <span class="cov0" title="0">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package chunks

import (
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/auth"
)

// RegisterRoutes registers the chunks routes
func RegisterRoutes(e *echo.Echo, handler *Handler, authMiddleware *auth.Middleware) <span class="cov8" title="1">{
        // All chunks routes require authentication and project ID
        chunks := e.Group("/api/v2/chunks")
        chunks.Use(authMiddleware.RequireAuth())
        chunks.Use(authMiddleware.RequireProjectID())

        // List chunks (requires chunks:read scope)
        chunksRead := chunks.Group("")
        chunksRead.Use(authMiddleware.RequireScopes("chunks:read"))
        chunksRead.GET("", handler.List)

        // Write operations (requires chunks:write scope)
        chunksWrite := chunks.Group("")
        chunksWrite.Use(authMiddleware.RequireScopes("chunks:write"))
        chunksWrite.DELETE("/:id", handler.Delete)
        chunksWrite.DELETE("", handler.BulkDelete)
        chunksWrite.DELETE("/by-document/:documentId", handler.DeleteByDocument)
        chunksWrite.DELETE("/by-documents", handler.BulkDeleteByDocuments)
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package chunks

import (
        "context"
        "log/slog"

        "github.com/google/uuid"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Service handles business logic for chunks
type Service struct {
        repo *Repository
        log  *slog.Logger
}

// NewService creates a new chunks service
func NewService(repo *Repository, log *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: repo,
                log:  log.With(logger.Scope("chunks.svc")),
        }
}</span>

// List returns all chunks for a project, optionally filtered by document ID
func (s *Service) List(ctx context.Context, projectID uuid.UUID, documentID *uuid.UUID) (*ListChunksResponse, error) <span class="cov8" title="1">{
        chunks, err := s.repo.ListByProject(ctx, projectID, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert to DTOs
        <span class="cov8" title="1">dtos := make([]*ChunkDTO, 0, len(chunks))
        for _, chunk := range chunks </span><span class="cov8" title="1">{
                dtos = append(dtos, chunk.ToDTO())
        }</span>

        <span class="cov8" title="1">return &amp;ListChunksResponse{
                Data:       dtos,
                TotalCount: len(dtos),
        }, nil</span>
}

// GetByID retrieves a single chunk by ID
func (s *Service) GetByID(ctx context.Context, projectID, chunkID uuid.UUID) (*ChunkDTO, error) <span class="cov0" title="0">{
        chunk, err := s.repo.GetByID(ctx, projectID, chunkID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return chunk.ToDTO(), nil</span>
}

// Delete deletes a chunk by ID
func (s *Service) Delete(ctx context.Context, projectID, chunkID uuid.UUID) error <span class="cov8" title="1">{
        return s.repo.Delete(ctx, projectID, chunkID)
}</span>

// BulkDelete deletes multiple chunks by IDs
func (s *Service) BulkDelete(ctx context.Context, projectID uuid.UUID, chunkIDs []string) (*BulkDeletionSummary, error) <span class="cov8" title="1">{
        if len(chunkIDs) == 0 </span><span class="cov0" title="0">{
                return nil, apperror.NewBadRequest("ids array cannot be empty")
        }</span>

        // Parse UUIDs
        <span class="cov8" title="1">uuids := make([]uuid.UUID, 0, len(chunkIDs))
        for _, id := range chunkIDs </span><span class="cov8" title="1">{
                parsed, err := uuid.Parse(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.NewBadRequest("invalid chunk ID: " + id)
                }</span>
                <span class="cov8" title="1">uuids = append(uuids, parsed)</span>
        }

        <span class="cov8" title="1">return s.repo.BulkDelete(ctx, projectID, uuids)</span>
}

// DeleteByDocument deletes all chunks for a document
func (s *Service) DeleteByDocument(ctx context.Context, projectID, documentID uuid.UUID) (*DocumentChunksDeletionResult, error) <span class="cov8" title="1">{
        return s.repo.DeleteByDocument(ctx, projectID, documentID)
}</span>

// BulkDeleteByDocuments deletes all chunks for multiple documents
func (s *Service) BulkDeleteByDocuments(ctx context.Context, projectID uuid.UUID, documentIDs []string) (*BulkDocumentChunksDeletionSummary, error) <span class="cov8" title="1">{
        if len(documentIDs) == 0 </span><span class="cov0" title="0">{
                return nil, apperror.NewBadRequest("documentIds array cannot be empty")
        }</span>

        // Parse UUIDs
        <span class="cov8" title="1">uuids := make([]uuid.UUID, 0, len(documentIDs))
        for _, id := range documentIDs </span><span class="cov8" title="1">{
                parsed, err := uuid.Parse(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.NewBadRequest("invalid document ID: " + id)
                }</span>
                <span class="cov8" title="1">uuids = append(uuids, parsed)</span>
        }

        <span class="cov8" title="1">return s.repo.BulkDeleteByDocuments(ctx, projectID, uuids)</span>
}

// Create creates a new chunk (used internally, e.g., by extraction pipeline)
func (s *Service) Create(ctx context.Context, req *CreateChunkRequest) (*Chunk, error) <span class="cov0" title="0">{
        docID, err := uuid.Parse(req.DocumentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.NewBadRequest("invalid document ID")
        }</span>

        <span class="cov0" title="0">chunk := &amp;Chunk{
                ID:         uuid.New(),
                DocumentID: docID,
                ChunkIndex: req.ChunkIndex,
                Text:       req.Text,
                Metadata:   req.Metadata,
        }

        if err := s.repo.Create(ctx, chunk); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return chunk, nil</span>
}

// CreateBatch creates multiple chunks in a batch (used by extraction pipeline)
func (s *Service) CreateBatch(ctx context.Context, documentID uuid.UUID, chunks []CreateChunkRequest) error <span class="cov0" title="0">{
        if len(chunks) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">entities := make([]*Chunk, 0, len(chunks))
        for _, req := range chunks </span><span class="cov0" title="0">{
                entities = append(entities, &amp;Chunk{
                        ID:         uuid.New(),
                        DocumentID: documentID,
                        ChunkIndex: req.ChunkIndex,
                        Text:       req.Text,
                        Metadata:   req.Metadata,
                })
        }</span>

        <span class="cov0" title="0">return s.repo.CreateBatch(ctx, entities)</span>
}

// UpdateEmbedding updates the embedding for a chunk
func (s *Service) UpdateEmbedding(ctx context.Context, chunkID uuid.UUID, embedding []float32) error <span class="cov0" title="0">{
        if len(embedding) != 768 </span><span class="cov0" title="0">{
                return apperror.NewBadRequest("embedding must be 768 dimensions")
        }</span>

        <span class="cov0" title="0">return s.repo.UpdateEmbedding(ctx, chunkID, embedding)</span>
}

// CountByDocument returns the number of chunks for a document
func (s *Service) CountByDocument(ctx context.Context, documentID uuid.UUID) (int, error) <span class="cov0" title="0">{
        return s.repo.CountByDocument(ctx, documentID)
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package datasource

import (
        "os"
        "strconv"
        "time"
)

// Config holds data source sync configuration
type Config struct {
        // Enabled controls whether the sync worker runs
        Enabled bool

        // WorkerIntervalMs is the polling interval in milliseconds
        WorkerIntervalMs int

        // WorkerBatchSize is the number of jobs to process per batch
        WorkerBatchSize int

        // StaleJobMinutes is how long a job can be running before it's considered stale
        StaleJobMinutes int

        // SyncTimeoutMinutes is the max time a single sync can run
        SyncTimeoutMinutes int
}

// NewConfig creates a new Config from environment variables
func NewConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Enabled:            getEnvBool("DATASOURCE_SYNC_WORKER_ENABLED", true),
                WorkerIntervalMs:   getEnvInt("DATASOURCE_SYNC_WORKER_INTERVAL_MS", 30000),
                WorkerBatchSize:    getEnvInt("DATASOURCE_SYNC_WORKER_BATCH_SIZE", 5),
                StaleJobMinutes:    getEnvInt("DATASOURCE_SYNC_STALE_JOB_MINUTES", 10),
                SyncTimeoutMinutes: getEnvInt("DATASOURCE_SYNC_TIMEOUT_MINUTES", 30),
        }
}</span>

// WorkerInterval returns the polling interval as a duration
func (c *Config) WorkerInterval() time.Duration <span class="cov8" title="1">{
        return time.Duration(c.WorkerIntervalMs) * time.Millisecond
}</span>

// SyncTimeout returns the sync timeout as a duration
func (c *Config) SyncTimeout() time.Duration <span class="cov8" title="1">{
        return time.Duration(c.SyncTimeoutMinutes) * time.Minute
}</span>

// getEnvBool returns a boolean from an environment variable
func getEnvBool(key string, defaultVal bool) bool <span class="cov8" title="1">{
        if val := os.Getenv(key); val != "" </span><span class="cov8" title="1">{
                if b, err := strconv.ParseBool(val); err == nil </span><span class="cov8" title="1">{
                        return b
                }</span>
        }
        <span class="cov8" title="1">return defaultVal</span>
}

// getEnvInt returns an integer from an environment variable
func getEnvInt(key string, defaultVal int) int <span class="cov8" title="1">{
        if val := os.Getenv(key); val != "" </span><span class="cov8" title="1">{
                if i, err := strconv.Atoi(val); err == nil </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return defaultVal</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package datasource

import (
        "database/sql/driver"
        "encoding/json"
        "time"

        "github.com/uptrace/bun"
)

// ------------------------------------------------------------------
// Status and Type Enums
// ------------------------------------------------------------------

// JobStatus represents the processing status of a sync job
type JobStatus string

const (
        JobStatusPending    JobStatus = "pending"
        JobStatusRunning    JobStatus = "running"
        JobStatusCompleted  JobStatus = "completed"
        JobStatusFailed     JobStatus = "failed"
        JobStatusCancelled  JobStatus = "cancelled"
        JobStatusDeadLetter JobStatus = "dead_letter" // Permanently failed after max retries
)

// TriggerType represents what triggered the sync
type TriggerType string

const (
        TriggerTypeManual    TriggerType = "manual"
        TriggerTypeScheduled TriggerType = "scheduled"
        TriggerTypeWebhook   TriggerType = "webhook"
)

// IntegrationStatus represents the status of an integration
type IntegrationStatus string

const (
        IntegrationStatusActive   IntegrationStatus = "active"
        IntegrationStatusError    IntegrationStatus = "error"
        IntegrationStatusDisabled IntegrationStatus = "disabled"
)

// SyncMode represents how syncing is triggered
type SyncMode string

const (
        SyncModeManual    SyncMode = "manual"
        SyncModeRecurring SyncMode = "recurring"
)

// ------------------------------------------------------------------
// DataSourceIntegration - External data source configuration
// ------------------------------------------------------------------

// DataSourceIntegration represents an integration with an external data source.
// Maps to kb.data_source_integrations table.
type DataSourceIntegration struct {
        bun.BaseModel `bun:"table:kb.data_source_integrations,alias:dsi"`

        ID                  string            `bun:"id,pk,type:uuid,default:gen_random_uuid()"`
        OrganizationID      string            `bun:"organization_id,notnull,type:uuid"`
        ProjectID           string            `bun:"project_id,notnull,type:uuid"`
        Name                string            `bun:"name,notnull"`
        Description         *string           `bun:"description"`
        ProviderType        string            `bun:"provider_type,notnull"` // 'imap', 'gmail_oauth', 'google_drive', 'clickup'
        SourceType          string            `bun:"source_type,notnull"`   // 'email', 'drive', 'clickup-document'
        ConfigEncrypted     *string           `bun:"config_encrypted"`      // AES-256-GCM encrypted config
        SyncMode            SyncMode          `bun:"sync_mode,notnull,default:'manual'"`
        SyncIntervalMinutes *int              `bun:"sync_interval_minutes"`
        LastSyncedAt        *time.Time        `bun:"last_synced_at"`
        NextSyncAt          *time.Time        `bun:"next_sync_at"`
        Status              IntegrationStatus `bun:"status,notnull,default:'active'"`
        ErrorMessage        *string           `bun:"error_message"`
        ErrorCount          int               `bun:"error_count,notnull,default:0"`
        Metadata            JSON              `bun:"metadata,type:jsonb,notnull,default:'{}'"`
        CreatedBy           *string           `bun:"created_by,type:uuid"`
        CreatedAt           time.Time         `bun:"created_at,notnull,default:now()"`
        UpdatedAt           time.Time         `bun:"updated_at,notnull,default:now()"`
}

// ------------------------------------------------------------------
// DataSourceSyncJob - Tracks async sync operations
// ------------------------------------------------------------------

// DataSourceSyncJob represents a data source sync job in kb.data_source_sync_jobs.
// These jobs sync data from external integrations (ClickUp, Gmail, etc.).
type DataSourceSyncJob struct {
        bun.BaseModel `bun:"table:kb.data_source_sync_jobs,alias:dssj"`

        ID                string      `bun:"id,pk,type:uuid,default:gen_random_uuid()"`
        IntegrationID     string      `bun:"integration_id,notnull,type:uuid"`
        ProjectID         string      `bun:"project_id,notnull,type:uuid"`
        ConfigurationID   *string     `bun:"configuration_id,type:uuid"`
        ConfigurationName *string     `bun:"configuration_name"`
        Status            JobStatus   `bun:"status,notnull,default:'pending'"`
        TotalItems        int         `bun:"total_items,notnull,default:0"`
        ProcessedItems    int         `bun:"processed_items,notnull,default:0"`
        SuccessfulItems   int         `bun:"successful_items,notnull,default:0"`
        FailedItems       int         `bun:"failed_items,notnull,default:0"`
        SkippedItems      int         `bun:"skipped_items,notnull,default:0"`
        CurrentPhase      *string     `bun:"current_phase"` // 'initializing', 'discovering', 'importing', 'syncing', 'completed'
        StatusMessage     *string     `bun:"status_message"`
        SyncOptions       JSON        `bun:"sync_options,type:jsonb,notnull,default:'{}'"`
        DocumentIDs       JSONArray   `bun:"document_ids,type:jsonb,notnull,default:'[]'"`
        Logs              JSONArray   `bun:"logs,type:jsonb,notnull,default:'[]'"`
        ErrorMessage      *string     `bun:"error_message"`
        ErrorDetails      JSON        `bun:"error_details,type:jsonb"`
        RetryCount        int         `bun:"retry_count,notnull,default:0"`
        MaxRetries        int         `bun:"max_retries,notnull,default:3"`
        NextRetryAt       *time.Time  `bun:"next_retry_at"`
        TriggeredBy       *string     `bun:"triggered_by,type:uuid"`
        TriggerType       TriggerType `bun:"trigger_type,notnull,default:'manual'"`
        CreatedAt         time.Time   `bun:"created_at,notnull,default:now()"`
        StartedAt         *time.Time  `bun:"started_at"`
        CompletedAt       *time.Time  `bun:"completed_at"`
        UpdatedAt         time.Time   `bun:"updated_at,notnull,default:now()"`
}

// ------------------------------------------------------------------
// SyncConfiguration - Stored sync configurations
// ------------------------------------------------------------------

// SyncConfiguration represents a stored sync configuration
// Stored in integration.metadata.syncConfigurations
type SyncConfiguration struct {
        ID          string    `json:"id"`
        Name        string    `json:"name"`
        Enabled     bool      `json:"enabled"`
        Schedule    string    `json:"schedule,omitempty"`    // Cron expression
        IntervalMin int       `json:"intervalMin,omitempty"` // Minutes between runs
        Options     JSON      `json:"options,omitempty"`
        LastRunAt   time.Time `json:"lastRunAt,omitempty"`
        NextRunAt   time.Time `json:"nextRunAt,omitempty"`
}

// ------------------------------------------------------------------
// SyncJobLogEntry - Log entries for job progress
// ------------------------------------------------------------------

// SyncJobLogEntry represents a single log entry in a sync job
type SyncJobLogEntry struct {
        Timestamp time.Time `json:"timestamp"`
        Level     string    `json:"level"` // 'info', 'warn', 'error'
        Message   string    `json:"message"`
        Details   JSON      `json:"details,omitempty"`
}

// ------------------------------------------------------------------
// Helper types for JSONB columns
// ------------------------------------------------------------------

// JSON is a helper type for JSONB columns (objects)
type JSON map[string]interface{}

// Value implements driver.Valuer for JSON
func (j JSON) Value() (driver.Value, error) <span class="cov8" title="1">{
        if j == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return json.Marshal(j)</span>
}

// Scan implements sql.Scanner for JSON
func (j *JSON) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                *j = nil
                return nil
        }</span>
        <span class="cov8" title="1">bytes, ok := value.([]byte)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(bytes, j)</span>
}

// JSONArray is a helper type for JSONB columns that store arrays
type JSONArray []interface{}

// Value implements driver.Valuer for JSONArray
func (j JSONArray) Value() (driver.Value, error) <span class="cov8" title="1">{
        if j == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return json.Marshal(j)</span>
}

// Scan implements sql.Scanner for JSONArray
func (j *JSONArray) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                *j = nil
                return nil
        }</span>
        <span class="cov8" title="1">bytes, ok := value.([]byte)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(bytes, j)</span>
}

// StringArray is a helper for arrays of strings
type StringArray []string

// Value implements driver.Valuer for StringArray
func (s StringArray) Value() (driver.Value, error) <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return json.Marshal(s)</span>
}

// Scan implements sql.Scanner for StringArray
func (s *StringArray) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                *s = nil
                return nil
        }</span>
        <span class="cov8" title="1">bytes, ok := value.([]byte)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(bytes, s)</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package datasource

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "log/slog"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Common errors
var (
        ErrJobNotFound      = errors.New("sync job not found")
        ErrJobAlreadyExists = errors.New("sync job already exists for this integration")
)

// JobsService handles data source sync job queue operations.
// Follows the same pattern as other job services in the extraction domain.
type JobsService struct {
        db  *bun.DB
        log *slog.Logger
        cfg *config.Config
}

// NewJobsService creates a new JobsService
func NewJobsService(db *bun.DB, log *slog.Logger, cfg *config.Config) *JobsService <span class="cov8" title="1">{
        return &amp;JobsService{
                db:  db,
                log: log.With(logger.Scope("datasource.jobs")),
                cfg: cfg,
        }
}</span>

// Create creates a new sync job for an integration
func (s *JobsService) Create(ctx context.Context, job *DataSourceSyncJob) error <span class="cov8" title="1">{
        _, err := s.db.NewInsert().Model(job).Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.log.Debug("created sync job",
                slog.String("job_id", job.ID),
                slog.String("integration_id", job.IntegrationID))
        return nil</span>
}

// GetByID retrieves a sync job by ID
func (s *JobsService) GetByID(ctx context.Context, id string) (*DataSourceSyncJob, error) <span class="cov8" title="1">{
        job := &amp;DataSourceSyncJob{}
        err := s.db.NewSelect().
                Model(job).
                Where("id = ?", id).
                Scan(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov8" title="1">{
                        return nil, ErrJobNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">return job, nil</span>
}

// GetActiveJobForIntegration returns any pending/running job for an integration
func (s *JobsService) GetActiveJobForIntegration(ctx context.Context, integrationID string) (*DataSourceSyncJob, error) <span class="cov0" title="0">{
        job := &amp;DataSourceSyncJob{}
        err := s.db.NewSelect().
                Model(job).
                Where("integration_id = ?", integrationID).
                Where("status IN (?)", bun.In([]JobStatus{JobStatusPending, JobStatusRunning})).
                OrderExpr("created_at DESC").
                Limit(1).
                Scan(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil // No active job
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return job, nil</span>
}

// ListByIntegration returns sync jobs for an integration
func (s *JobsService) ListByIntegration(ctx context.Context, integrationID string, limit int) ([]*DataSourceSyncJob, error) <span class="cov0" title="0">{
        var jobs []*DataSourceSyncJob
        err := s.db.NewSelect().
                Model(&amp;jobs).
                Where("integration_id = ?", integrationID).
                OrderExpr("created_at DESC").
                Limit(limit).
                Scan(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return jobs, nil</span>
}

// Dequeue claims pending jobs for processing using FOR UPDATE SKIP LOCKED
func (s *JobsService) Dequeue(ctx context.Context, batchSize int) ([]*DataSourceSyncJob, error) <span class="cov0" title="0">{
        var jobs []*DataSourceSyncJob

        err := s.db.RunInTx(ctx, &amp;sql.TxOptions{}, func(ctx context.Context, tx bun.Tx) error </span><span class="cov0" title="0">{
                // Select pending jobs with lock
                err := tx.NewSelect().
                        Model(&amp;jobs).
                        Where("status = ?", JobStatusPending).
                        OrderExpr("created_at ASC").
                        Limit(batchSize).
                        For("UPDATE SKIP LOCKED").
                        Scan(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if len(jobs) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Mark as running
                <span class="cov0" title="0">now := time.Now()
                ids := make([]string, len(jobs))
                for i, job := range jobs </span><span class="cov0" title="0">{
                        ids[i] = job.ID
                        job.Status = JobStatusRunning
                        job.StartedAt = &amp;now
                }</span>

                <span class="cov0" title="0">_, err = tx.NewUpdate().
                        Model((*DataSourceSyncJob)(nil)).
                        Set("status = ?", JobStatusRunning).
                        Set("started_at = ?", now).
                        Set("current_phase = ?", "initializing").
                        Set("updated_at = ?", now).
                        Where("id IN (?)", bun.In(ids)).
                        Exec(ctx)
                return err</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return jobs, nil</span>
}

// MarkRunning marks a job as running
func (s *JobsService) MarkRunning(ctx context.Context, jobID string, phase string) error <span class="cov0" title="0">{
        now := time.Now()
        _, err := s.db.NewUpdate().
                Model((*DataSourceSyncJob)(nil)).
                Set("status = ?", JobStatusRunning).
                Set("started_at = COALESCE(started_at, ?)", now).
                Set("current_phase = ?", phase).
                Set("updated_at = ?", now).
                Where("id = ?", jobID).
                Exec(ctx)
        return err
}</span>

// UpdateProgress updates job progress counters
func (s *JobsService) UpdateProgress(ctx context.Context, jobID string, total, processed, successful, failed, skipped int, phase string, message string) error <span class="cov0" title="0">{
        now := time.Now()
        _, err := s.db.NewUpdate().
                Model((*DataSourceSyncJob)(nil)).
                Set("total_items = ?", total).
                Set("processed_items = ?", processed).
                Set("successful_items = ?", successful).
                Set("failed_items = ?", failed).
                Set("skipped_items = ?", skipped).
                Set("current_phase = ?", phase).
                Set("status_message = ?", message).
                Set("updated_at = ?", now).
                Where("id = ?", jobID).
                Exec(ctx)
        return err
}</span>

// AddDocumentID adds a document ID to the job's document list
func (s *JobsService) AddDocumentID(ctx context.Context, jobID string, documentID string) error <span class="cov0" title="0">{
        now := time.Now()
        _, err := s.db.NewUpdate().
                Model((*DataSourceSyncJob)(nil)).
                Set("document_ids = document_ids || ?::jsonb", `"`+documentID+`"`).
                Set("updated_at = ?", now).
                Where("id = ?", jobID).
                Exec(ctx)
        return err
}</span>

// AppendLog adds a log entry to the job
func (s *JobsService) AppendLog(ctx context.Context, jobID string, entry SyncJobLogEntry) error <span class="cov0" title="0">{
        entryJSON, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">now := time.Now()
        _, err = s.db.NewUpdate().
                Model((*DataSourceSyncJob)(nil)).
                Set("logs = logs || ?::jsonb", string(entryJSON)).
                Set("updated_at = ?", now).
                Where("id = ?", jobID).
                Exec(ctx)
        return err</span>
}

// MarkCompleted marks a job as completed
func (s *JobsService) MarkCompleted(ctx context.Context, jobID string) error <span class="cov0" title="0">{
        now := time.Now()
        _, err := s.db.NewUpdate().
                Model((*DataSourceSyncJob)(nil)).
                Set("status = ?", JobStatusCompleted).
                Set("completed_at = ?", now).
                Set("current_phase = ?", "completed").
                Set("status_message = ?", "Sync completed successfully").
                Set("updated_at = ?", now).
                Where("id = ?", jobID).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.log.Info("sync job completed", slog.String("job_id", jobID))
        return nil</span>
}

// MarkFailed marks a job as failed with an error
func (s *JobsService) MarkFailed(ctx context.Context, jobID string, err error) error <span class="cov0" title="0">{
        now := time.Now()
        errMsg := truncateError(err.Error())
        _, dbErr := s.db.NewUpdate().
                Model((*DataSourceSyncJob)(nil)).
                Set("status = ?", JobStatusFailed).
                Set("completed_at = ?", now).
                Set("current_phase = ?", "failed").
                Set("error_message = ?", errMsg).
                Set("status_message = ?", "Sync failed: "+errMsg).
                Set("retry_count = retry_count + 1").
                Set("updated_at = ?", now).
                Where("id = ?", jobID).
                Exec(ctx)
        if dbErr != nil </span><span class="cov0" title="0">{
                return dbErr
        }</span>

        <span class="cov0" title="0">s.log.Warn("sync job failed",
                slog.String("job_id", jobID),
                slog.String("error", errMsg))
        return nil</span>
}

// MarkFailedWithRetry marks a job as failed and schedules a retry if under max retries
// Returns true if the job was scheduled for retry, false if it was moved to dead letter
func (s *JobsService) MarkFailedWithRetry(ctx context.Context, jobID string, err error, retryCount, maxRetries int) (bool, error) <span class="cov8" title="1">{
        now := time.Now()
        errMsg := truncateError(err.Error())

        // Check if we should move to dead letter
        if retryCount &gt;= maxRetries </span><span class="cov8" title="1">{
                // Move to dead letter - permanently failed
                _, dbErr := s.db.NewUpdate().
                        Model((*DataSourceSyncJob)(nil)).
                        Set("status = ?", JobStatusDeadLetter).
                        Set("completed_at = ?", now).
                        Set("current_phase = ?", "dead_letter").
                        Set("error_message = ?", errMsg).
                        Set("status_message = ?", "Permanently failed after "+string(rune(maxRetries+'0'))+" retries: "+errMsg).
                        Set("retry_count = ?", retryCount).
                        Set("updated_at = ?", now).
                        Where("id = ?", jobID).
                        Exec(ctx)
                if dbErr != nil </span><span class="cov0" title="0">{
                        return false, dbErr
                }</span>

                <span class="cov8" title="1">s.log.Error("sync job moved to dead letter",
                        slog.String("job_id", jobID),
                        slog.Int("retry_count", retryCount),
                        slog.Int("max_retries", maxRetries),
                        slog.String("error", errMsg))
                return false, nil</span>
        }

        // Schedule retry with exponential backoff
        <span class="cov8" title="1">backoffMinutes := 1 &lt;&lt; retryCount // 1, 2, 4, 8, 16... minutes
        if backoffMinutes &gt; 60 </span><span class="cov0" title="0">{
                backoffMinutes = 60 // Cap at 1 hour
        }</span>
        <span class="cov8" title="1">nextRetry := now.Add(time.Duration(backoffMinutes) * time.Minute)

        _, dbErr := s.db.NewUpdate().
                Model((*DataSourceSyncJob)(nil)).
                Set("status = ?", JobStatusPending).
                Set("error_message = ?", errMsg).
                Set("status_message = ?", "Scheduled for retry").
                Set("retry_count = ?", retryCount+1).
                Set("next_retry_at = ?", nextRetry).
                Set("started_at = NULL").
                Set("completed_at = NULL").
                Set("updated_at = ?", now).
                Where("id = ?", jobID).
                Exec(ctx)
        if dbErr != nil </span><span class="cov0" title="0">{
                return false, dbErr
        }</span>

        <span class="cov8" title="1">s.log.Info("sync job scheduled for retry",
                slog.String("job_id", jobID),
                slog.Int("retry_count", retryCount+1),
                slog.Time("next_retry_at", nextRetry))
        return true, nil</span>
}

// MarkCancelled marks a job as cancelled
func (s *JobsService) MarkCancelled(ctx context.Context, jobID string) error <span class="cov0" title="0">{
        now := time.Now()
        _, err := s.db.NewUpdate().
                Model((*DataSourceSyncJob)(nil)).
                Set("status = ?", JobStatusCancelled).
                Set("completed_at = ?", now).
                Set("current_phase = ?", "cancelled").
                Set("status_message = ?", "Sync cancelled by user").
                Set("updated_at = ?", now).
                Where("id = ?", jobID).
                Where("status IN (?)", bun.In([]JobStatus{JobStatusPending, JobStatusRunning})).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s.log.Info("sync job cancelled", slog.String("job_id", jobID))
        return nil</span>
}

// RecoverStaleJobs marks jobs stuck in running state as failed
// This is called on worker startup to handle jobs that were interrupted
func (s *JobsService) RecoverStaleJobs(ctx context.Context, staleMinutes int) (int, error) <span class="cov0" title="0">{
        cutoff := time.Now().Add(-time.Duration(staleMinutes) * time.Minute)

        res, err := s.db.NewUpdate().
                Model((*DataSourceSyncJob)(nil)).
                Set("status = ?", JobStatusFailed).
                Set("error_message = ?", "Job interrupted - marked as failed during recovery").
                Set("completed_at = ?", time.Now()).
                Set("updated_at = ?", time.Now()).
                Where("status = ?", JobStatusRunning).
                Where("started_at &lt; ?", cutoff).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := res.RowsAffected()
        if rowsAffected &gt; 0 </span><span class="cov0" title="0">{
                s.log.Info("recovered stale sync jobs", slog.Int64("count", rowsAffected))
        }</span>
        <span class="cov0" title="0">return int(rowsAffected), nil</span>
}

// GetIntegration retrieves an integration by ID
func (s *JobsService) GetIntegration(ctx context.Context, id string) (*DataSourceIntegration, error) <span class="cov0" title="0">{
        integration := &amp;DataSourceIntegration{}
        err := s.db.NewSelect().
                Model(integration).
                Where("id = ?", id).
                Scan(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, errors.New("integration not found")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return integration, nil</span>
}

// UpdateIntegrationSyncStatus updates the sync-related fields on an integration
func (s *JobsService) UpdateIntegrationSyncStatus(ctx context.Context, integrationID string, lastSynced time.Time, nextSync *time.Time, status IntegrationStatus, errMsg *string) error <span class="cov0" title="0">{
        now := time.Now()
        q := s.db.NewUpdate().
                Model((*DataSourceIntegration)(nil)).
                Set("last_synced_at = ?", lastSynced).
                Set("status = ?", status).
                Set("updated_at = ?", now).
                Where("id = ?", integrationID)

        if nextSync != nil </span><span class="cov0" title="0">{
                q = q.Set("next_sync_at = ?", *nextSync)
        }</span>
        <span class="cov0" title="0">if errMsg != nil </span><span class="cov0" title="0">{
                q = q.Set("error_message = ?", *errMsg)
                q = q.Set("error_count = error_count + 1")
        }</span> else<span class="cov0" title="0"> {
                q = q.Set("error_message = NULL")
                q = q.Set("error_count = 0")
        }</span>

        <span class="cov0" title="0">_, err := q.Exec(ctx)
        return err</span>
}

// truncateError truncates error messages to a reasonable length
func truncateError(msg string) string <span class="cov8" title="1">{
        const maxLen = 1000
        if len(msg) &lt;= maxLen </span><span class="cov8" title="1">{
                return msg
        }</span>
        <span class="cov8" title="1">return msg[:maxLen]</span>
}

// ------------------------------------------------------------------
// Dead Letter Queue Methods
// ------------------------------------------------------------------

// ListDeadLetterJobs returns jobs that have permanently failed
func (s *JobsService) ListDeadLetterJobs(ctx context.Context, projectID string, limit, offset int) ([]*DataSourceSyncJob, int, error) <span class="cov8" title="1">{
        var jobs []*DataSourceSyncJob

        q := s.db.NewSelect().
                Model(&amp;jobs).
                Where("status = ?", JobStatusDeadLetter)

        if projectID != "" </span><span class="cov8" title="1">{
                q = q.Where("project_id = ?", projectID)
        }</span>

        <span class="cov8" title="1">count, err := q.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">err = q.OrderExpr("updated_at DESC").
                Limit(limit).
                Offset(offset).
                Scan(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov8" title="1">return jobs, count, nil</span>
}

// RetryDeadLetterJob moves a dead letter job back to pending for retry
func (s *JobsService) RetryDeadLetterJob(ctx context.Context, jobID string) error <span class="cov8" title="1">{
        now := time.Now()
        res, err := s.db.NewUpdate().
                Model((*DataSourceSyncJob)(nil)).
                Set("status = ?", JobStatusPending).
                Set("retry_count = 0").
                Set("error_message = NULL").
                Set("error_details = NULL").
                Set("status_message = ?", "Manually retried from dead letter queue").
                Set("current_phase = NULL").
                Set("started_at = NULL").
                Set("completed_at = NULL").
                Set("next_retry_at = NULL").
                Set("updated_at = ?", now).
                Where("id = ?", jobID).
                Where("status = ?", JobStatusDeadLetter).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := res.RowsAffected()
        if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrJobNotFound
        }</span>

        <span class="cov8" title="1">s.log.Info("dead letter job retried",
                slog.String("job_id", jobID))
        return nil</span>
}

// DeleteDeadLetterJob permanently deletes a dead letter job
func (s *JobsService) DeleteDeadLetterJob(ctx context.Context, jobID string) error <span class="cov8" title="1">{
        res, err := s.db.NewDelete().
                Model((*DataSourceSyncJob)(nil)).
                Where("id = ?", jobID).
                Where("status = ?", JobStatusDeadLetter).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := res.RowsAffected()
        if rowsAffected == 0 </span><span class="cov8" title="1">{
                return ErrJobNotFound
        }</span>

        <span class="cov8" title="1">s.log.Info("dead letter job deleted",
                slog.String("job_id", jobID))
        return nil</span>
}

// PurgeDeadLetterJobs deletes all dead letter jobs older than the specified duration
func (s *JobsService) PurgeDeadLetterJobs(ctx context.Context, olderThan time.Duration) (int, error) <span class="cov8" title="1">{
        cutoff := time.Now().Add(-olderThan)

        res, err := s.db.NewDelete().
                Model((*DataSourceSyncJob)(nil)).
                Where("status = ?", JobStatusDeadLetter).
                Where("updated_at &lt; ?", cutoff).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := res.RowsAffected()
        if rowsAffected &gt; 0 </span><span class="cov8" title="1">{
                s.log.Info("purged dead letter jobs",
                        slog.Int64("count", rowsAffected),
                        slog.Duration("older_than", olderThan))
        }</span>
        <span class="cov8" title="1">return int(rowsAffected), nil</span>
}

// GetDeadLetterStats returns statistics about dead letter jobs
func (s *JobsService) GetDeadLetterStats(ctx context.Context, projectID string) (*DeadLetterStats, error) <span class="cov8" title="1">{
        stats := &amp;DeadLetterStats{}

        q := s.db.NewSelect().
                Model((*DataSourceSyncJob)(nil)).
                Where("status = ?", JobStatusDeadLetter)

        if projectID != "" </span><span class="cov8" title="1">{
                q = q.Where("project_id = ?", projectID)
        }</span>

        // Get total count
        <span class="cov8" title="1">count, err := q.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">stats.TotalCount = count

        // Get oldest job timestamp
        if count &gt; 0 </span><span class="cov8" title="1">{
                var oldest time.Time
                err = s.db.NewSelect().
                        Model((*DataSourceSyncJob)(nil)).
                        Column("updated_at").
                        Where("status = ?", JobStatusDeadLetter).
                        OrderExpr("updated_at ASC").
                        Limit(1).
                        Scan(ctx, &amp;oldest)
                if err == nil </span><span class="cov8" title="1">{
                        stats.OldestJobAt = &amp;oldest
                }</span>
        }

        <span class="cov8" title="1">return stats, nil</span>
}

// DeadLetterStats contains statistics about dead letter jobs
type DeadLetterStats struct {
        TotalCount  int        `json:"totalCount"`
        OldestJobAt *time.Time `json:"oldestJobAt,omitempty"`
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package datasource

import (
        "context"
        "log/slog"

        "github.com/uptrace/bun"
        "go.uber.org/fx"

        "github.com/emergent/emergent-core/domain/datasource/providers/clickup"
        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/pkg/encryption"
)

// Module provides data source sync functionality
var Module = fx.Module("datasource",
        fx.Provide(
                NewConfig,
                NewJobsService,
                NewProviderRegistry,
                encryption.NewService,
                NewWorker,
        ),
        fx.Invoke(
                RegisterProviders,
                RegisterWorkerLifecycle,
        ),
)

// JobsServiceParams for dependency injection
type JobsServiceParams struct {
        fx.In
        DB  *bun.DB
        Log *slog.Logger
        Cfg *config.Config
}

// NewJobsServiceFromParams creates a JobsService from fx params
func NewJobsServiceFromParams(p JobsServiceParams) *JobsService <span class="cov0" title="0">{
        return NewJobsService(p.DB, p.Log, p.Cfg)
}</span>

// clickupAdapter wraps the clickup.Provider to implement datasource.Provider
type clickupAdapter struct {
        provider *clickup.Provider
}

func (a *clickupAdapter) ProviderType() string <span class="cov0" title="0">{
        return a.provider.ProviderType()
}</span>

func (a *clickupAdapter) TestConnection(ctx context.Context, config ProviderConfig) error <span class="cov0" title="0">{
        // Convert datasource.ProviderConfig to clickup.ProviderConfig
        clickupConfig := clickup.ProviderConfig{
                IntegrationID: config.IntegrationID,
                ProjectID:     config.ProjectID,
                Config:        config.Config,
                Metadata:      config.Metadata,
        }
        return a.provider.TestConnection(ctx, clickupConfig)
}</span>

func (a *clickupAdapter) Sync(ctx context.Context, config ProviderConfig, options SyncOptions, progress ProgressCallback) (*SyncResult, error) <span class="cov0" title="0">{
        // Convert datasource types to clickup types
        clickupConfig := clickup.ProviderConfig{
                IntegrationID: config.IntegrationID,
                ProjectID:     config.ProjectID,
                Config:        config.Config,
                Metadata:      config.Metadata,
        }
        clickupOptions := clickup.SyncOptions{
                Limit:           options.Limit,
                FullSync:        options.FullSync,
                ConfigurationID: options.ConfigurationID,
                Custom:          options.Custom,
        }

        // Wrap the progress callback
        var clickupProgress clickup.ProgressCallback
        if progress != nil </span><span class="cov0" title="0">{
                clickupProgress = func(p clickup.Progress) </span><span class="cov0" title="0">{
                        progress(Progress{
                                Phase:           p.Phase,
                                TotalItems:      p.TotalItems,
                                ProcessedItems:  p.ProcessedItems,
                                SuccessfulItems: p.SuccessfulItems,
                                FailedItems:     p.FailedItems,
                                SkippedItems:    p.SkippedItems,
                                Message:         p.Message,
                        })
                }</span>
        }

        <span class="cov0" title="0">result, err := a.provider.Sync(ctx, clickupConfig, clickupOptions, clickupProgress)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Convert result
        <span class="cov0" title="0">return &amp;SyncResult{
                TotalItems:      result.TotalItems,
                ProcessedItems:  result.ProcessedItems,
                SuccessfulItems: result.SuccessfulItems,
                FailedItems:     result.FailedItems,
                SkippedItems:    result.SkippedItems,
                DocumentIDs:     result.DocumentIDs,
                Errors:          result.Errors,
        }, nil</span>
}

// RegisterProviders registers all available data source providers
func RegisterProviders(registry *ProviderRegistry, db *bun.DB, log *slog.Logger) <span class="cov0" title="0">{
        // Register ClickUp provider (fully implemented)
        clickupProvider := clickup.NewProvider(db, log)
        registry.Register(&amp;clickupAdapter{provider: clickupProvider})

        // Register placeholder providers for other integrations
        // These will be implemented later
        registry.Register(NewNoOpProvider("imap"))
        registry.Register(NewNoOpProvider("gmail_oauth"))
        registry.Register(NewNoOpProvider("google_drive"))

        log.Info("registered data source providers",
                slog.Any("types", registry.ListTypes()))
}</span>

// RegisterWorkerLifecycle registers the sync worker with fx lifecycle
func RegisterWorkerLifecycle(lc fx.Lifecycle, worker *Worker, cfg *Config) <span class="cov0" title="0">{
        if !cfg.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">lc.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        return worker.Start(ctx)
                }</span>,
                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                        return worker.Stop(ctx)
                }</span>,
        })
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package datasource

import (
        "context"
        "sync"
)

// Provider is the interface that data source providers must implement.
// Each provider handles syncing data from a specific external service.
type Provider interface {
        // ProviderType returns the unique type identifier for this provider
        ProviderType() string

        // TestConnection tests if the connection to the data source is valid
        TestConnection(ctx context.Context, config ProviderConfig) error

        // Sync performs a full sync operation and returns sync results
        // The sync method should handle duplicate detection internally
        Sync(ctx context.Context, config ProviderConfig, options SyncOptions, progress ProgressCallback) (*SyncResult, error)
}

// ProviderConfig contains the decrypted configuration for a provider
type ProviderConfig struct {
        IntegrationID string
        ProjectID     string
        Config        map[string]interface{}
        Metadata      map[string]interface{}
}

// SyncOptions contains options for a sync operation
type SyncOptions struct {
        // Limit is the maximum number of items to sync (0 = no limit)
        Limit int

        // FullSync forces a full re-sync instead of incremental
        FullSync bool

        // ConfigurationID is the specific sync configuration to use
        ConfigurationID string

        // Custom options from the sync job
        Custom map[string]interface{}
}

// SyncResult contains the results of a sync operation
type SyncResult struct {
        TotalItems      int
        ProcessedItems  int
        SuccessfulItems int
        FailedItems     int
        SkippedItems    int
        DocumentIDs     []string
        Errors          []string
}

// ProgressCallback is called by providers to report sync progress
type ProgressCallback func(progress Progress)

// Progress represents the current progress of a sync operation
type Progress struct {
        Phase           string // 'discovering', 'importing', 'syncing'
        TotalItems      int
        ProcessedItems  int
        SuccessfulItems int
        FailedItems     int
        SkippedItems    int
        Message         string
}

// ProviderRegistry manages available data source providers
type ProviderRegistry struct {
        providers map[string]Provider
        mu        sync.RWMutex
}

// NewProviderRegistry creates a new provider registry
func NewProviderRegistry() *ProviderRegistry <span class="cov8" title="1">{
        return &amp;ProviderRegistry{
                providers: make(map[string]Provider),
        }
}</span>

// Register adds a provider to the registry
func (r *ProviderRegistry) Register(provider Provider) <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.providers[provider.ProviderType()] = provider
}</span>

// Get retrieves a provider by type
func (r *ProviderRegistry) Get(providerType string) (Provider, bool) <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        provider, ok := r.providers[providerType]
        return provider, ok
}</span>

// ListTypes returns all registered provider types
func (r *ProviderRegistry) ListTypes() []string <span class="cov8" title="1">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        types := make([]string, 0, len(r.providers))
        for t := range r.providers </span><span class="cov8" title="1">{
                types = append(types, t)
        }</span>
        <span class="cov8" title="1">return types</span>
}

// NoOpProvider is a placeholder provider for testing
type NoOpProvider struct {
        providerType string
}

// NewNoOpProvider creates a no-op provider
func NewNoOpProvider(providerType string) *NoOpProvider <span class="cov8" title="1">{
        return &amp;NoOpProvider{providerType: providerType}
}</span>

func (p *NoOpProvider) ProviderType() string <span class="cov8" title="1">{
        return p.providerType
}</span>

func (p *NoOpProvider) TestConnection(ctx context.Context, config ProviderConfig) error <span class="cov8" title="1">{
        return nil
}</span>

func (p *NoOpProvider) Sync(ctx context.Context, config ProviderConfig, options SyncOptions, progress ProgressCallback) (*SyncResult, error) <span class="cov8" title="1">{
        // Report progress
        if progress != nil </span><span class="cov8" title="1">{
                progress(Progress{
                        Phase:   "syncing",
                        Message: "No-op sync completed",
                })
        }</span>

        <span class="cov8" title="1">return &amp;SyncResult{
                TotalItems:      0,
                ProcessedItems:  0,
                SuccessfulItems: 0,
                FailedItems:     0,
                SkippedItems:    0,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package clickup

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "net/http"
        "net/url"
        "sync"
        "time"

        "github.com/emergent/emergent-core/pkg/logger"
)

const (
        baseURLV2 = "https://api.clickup.com/api/v2"
        baseURLV3 = "https://api.clickup.com/api/v3"

        // ClickUp rate limit: 100 requests per minute per workspace
        defaultMaxRequests = 100
        defaultWindowMs    = 60000 // 1 minute
)

// Client is a stateless ClickUp API client.
// Each method accepts the API token, making it suitable for the DataSourceProvider pattern.
type Client struct {
        httpClient  *http.Client
        rateLimiter *RateLimiter
        log         *slog.Logger
}

// NewClient creates a new ClickUp API client
func NewClient(log *slog.Logger) *Client <span class="cov8" title="1">{
        return &amp;Client{
                httpClient: &amp;http.Client{
                        Timeout: 30 * time.Second,
                },
                rateLimiter: NewRateLimiter(defaultMaxRequests, defaultWindowMs),
                log:         log.With(logger.Scope("clickup-client")),
        }
}</span>

// ----------------------------------------------------------------------------
// Rate Limiter
// ----------------------------------------------------------------------------

// RateLimiter implements a sliding window rate limiter
type RateLimiter struct {
        mu          sync.Mutex
        timestamps  []int64
        maxRequests int
        windowMs    int64
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(maxRequests int, windowMs int) *RateLimiter <span class="cov8" title="1">{
        return &amp;RateLimiter{
                timestamps:  make([]int64, 0, maxRequests),
                maxRequests: maxRequests,
                windowMs:    int64(windowMs),
        }
}</span>

// WaitForSlot blocks until a request slot is available
func (r *RateLimiter) WaitForSlot(ctx context.Context) error <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">r.mu.Lock()
                now := time.Now().UnixMilli()

                // Remove timestamps outside the window
                var newTimestamps []int64
                for _, ts := range r.timestamps </span><span class="cov8" title="1">{
                        if now-ts &lt; r.windowMs </span><span class="cov8" title="1">{
                                newTimestamps = append(newTimestamps, ts)
                        }</span>
                }
                <span class="cov8" title="1">r.timestamps = newTimestamps

                // Check if we have capacity
                if len(r.timestamps) &lt; r.maxRequests </span><span class="cov8" title="1">{
                        r.timestamps = append(r.timestamps, now)
                        r.mu.Unlock()
                        return nil
                }</span>

                // Calculate wait time until oldest request expires
                <span class="cov8" title="1">oldestTs := r.timestamps[0]
                waitMs := r.windowMs - (now - oldestTs) + 100 // +100ms buffer
                r.mu.Unlock()

                // Wait before retrying
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                case &lt;-time.After(time.Duration(waitMs) * time.Millisecond):<span class="cov8" title="1">
                        continue</span>
                }
        }
}

// Reset clears all timestamps (useful for testing)
func (r *RateLimiter) Reset() <span class="cov8" title="1">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.timestamps = r.timestamps[:0]
}</span>

// ----------------------------------------------------------------------------
// HTTP Helpers
// ----------------------------------------------------------------------------

// request makes an authenticated API request
func (c *Client) request(ctx context.Context, apiToken, method, urlStr string) ([]byte, error) <span class="cov0" title="0">{
        // Wait for rate limit slot
        if err := c.rateLimiter.WaitForSlot(ctx); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rate limit wait: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, method, urlStr, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", apiToken)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP %d: %s - %s", resp.StatusCode, resp.Status, string(body))
        }</span>

        <span class="cov0" title="0">return body, nil</span>
}

// ----------------------------------------------------------------------------
// ClickUp API v2 Methods
// ----------------------------------------------------------------------------

// GetWorkspaces retrieves all workspaces (teams) the user has access to
func (c *Client) GetWorkspaces(ctx context.Context, apiToken string) (*WorkspacesResponse, error) <span class="cov0" title="0">{
        urlStr := fmt.Sprintf("%s/team", baseURLV2)

        body, err := c.request(ctx, apiToken, http.MethodGet, urlStr)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error("failed to get workspaces", logger.Error(err))
                return nil, fmt.Errorf("get workspaces: %w", err)
        }</span>

        <span class="cov0" title="0">var response WorkspacesResponse
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse workspaces response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// GetSpaces retrieves all spaces in a workspace
func (c *Client) GetSpaces(ctx context.Context, apiToken, workspaceID string, archived bool) (*SpacesResponse, error) <span class="cov0" title="0">{
        u, _ := url.Parse(fmt.Sprintf("%s/team/%s/space", baseURLV2, workspaceID))
        if archived </span><span class="cov0" title="0">{
                q := u.Query()
                q.Set("archived", "true")
                u.RawQuery = q.Encode()
        }</span>

        <span class="cov0" title="0">body, err := c.request(ctx, apiToken, http.MethodGet, u.String())
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error("failed to get spaces", logger.Error(err), slog.String("workspace_id", workspaceID))
                return nil, fmt.Errorf("get spaces: %w", err)
        }</span>

        <span class="cov0" title="0">var response SpacesResponse
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse spaces response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// ----------------------------------------------------------------------------
// ClickUp API v3 Methods (Docs)
// ----------------------------------------------------------------------------

// GetDocs retrieves all docs in a workspace, optionally filtered by parent
func (c *Client) GetDocs(ctx context.Context, apiToken, workspaceID string, cursor, parentID, parentType string) (*DocsResponse, error) <span class="cov0" title="0">{
        u, _ := url.Parse(fmt.Sprintf("%s/workspaces/%s/docs", baseURLV3, workspaceID))
        q := u.Query()
        if cursor != "" </span><span class="cov0" title="0">{
                q.Set("cursor", cursor)
        }</span>
        <span class="cov0" title="0">if parentID != "" </span><span class="cov0" title="0">{
                q.Set("parent", parentID)
        }</span>
        <span class="cov0" title="0">if parentType != "" </span><span class="cov0" title="0">{
                q.Set("parent_type", parentType)
        }</span>
        <span class="cov0" title="0">u.RawQuery = q.Encode()

        body, err := c.request(ctx, apiToken, http.MethodGet, u.String())
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error("failed to get docs", logger.Error(err), slog.String("workspace_id", workspaceID))
                return nil, fmt.Errorf("get docs: %w", err)
        }</span>

        <span class="cov0" title="0">var response DocsResponse
        if err := json.Unmarshal(body, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse docs response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;response, nil</span>
}

// GetDoc retrieves a specific doc by ID
func (c *Client) GetDoc(ctx context.Context, apiToken, workspaceID, docID string) (*Doc, error) <span class="cov0" title="0">{
        urlStr := fmt.Sprintf("%s/workspaces/%s/docs/%s", baseURLV3, workspaceID, docID)

        body, err := c.request(ctx, apiToken, http.MethodGet, urlStr)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error("failed to get doc", logger.Error(err), slog.String("doc_id", docID))
                return nil, fmt.Errorf("get doc: %w", err)
        }</span>

        <span class="cov0" title="0">var doc Doc
        if err := json.Unmarshal(body, &amp;doc); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse doc response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;doc, nil</span>
}

// GetDocPages retrieves all pages for a doc
func (c *Client) GetDocPages(ctx context.Context, apiToken, workspaceID, docID string) ([]Page, error) <span class="cov0" title="0">{
        urlStr := fmt.Sprintf("%s/workspaces/%s/docs/%s/pages", baseURLV3, workspaceID, docID)

        body, err := c.request(ctx, apiToken, http.MethodGet, urlStr)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error("failed to get doc pages", logger.Error(err), slog.String("doc_id", docID))
                return nil, fmt.Errorf("get doc pages: %w", err)
        }</span>

        <span class="cov0" title="0">var pages []Page
        if err := json.Unmarshal(body, &amp;pages); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse pages response: %w", err)
        }</span>

        <span class="cov0" title="0">return pages, nil</span>
}

// GetPage retrieves a specific page from a doc
func (c *Client) GetPage(ctx context.Context, apiToken, workspaceID, docID, pageID string) (*Page, error) <span class="cov0" title="0">{
        urlStr := fmt.Sprintf("%s/workspaces/%s/docs/%s/pages/%s", baseURLV3, workspaceID, docID, pageID)

        body, err := c.request(ctx, apiToken, http.MethodGet, urlStr)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Error("failed to get page", logger.Error(err), slog.String("page_id", pageID))
                return nil, fmt.Errorf("get page: %w", err)
        }</span>

        <span class="cov0" title="0">var page Page
        if err := json.Unmarshal(body, &amp;page); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse page response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;page, nil</span>
}

// ResetRateLimiter resets the rate limiter (for testing)
func (c *Client) ResetRateLimiter() <span class="cov8" title="1">{
        c.rateLimiter.Reset()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package clickup

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "strconv"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/domain/documents"
        "github.com/emergent/emergent-core/pkg/logger"
)

const (
        ProviderTypeClickUp = "clickup"
        SourceTypeClickUp   = "clickup-document"
)

// ProviderConfig contains the decrypted configuration for a provider
// Mirrors datasource.ProviderConfig to avoid import cycle
type ProviderConfig struct {
        IntegrationID string
        ProjectID     string
        Config        map[string]interface{}
        Metadata      map[string]interface{}
}

// SyncOptions contains options for a sync operation
// Mirrors datasource.SyncOptions to avoid import cycle
type SyncOptions struct {
        Limit           int
        FullSync        bool
        ConfigurationID string
        Custom          map[string]interface{}
}

// SyncResult contains the results of a sync operation
// Mirrors datasource.SyncResult to avoid import cycle
type SyncResult struct {
        TotalItems      int
        ProcessedItems  int
        SuccessfulItems int
        FailedItems     int
        SkippedItems    int
        DocumentIDs     []string
        Errors          []string
}

// Progress represents the current progress of a sync operation
// Mirrors datasource.Progress to avoid import cycle
type Progress struct {
        Phase           string
        TotalItems      int
        ProcessedItems  int
        SuccessfulItems int
        FailedItems     int
        SkippedItems    int
        Message         string
}

// ProgressCallback is called by providers to report sync progress
type ProgressCallback func(progress Progress)

// Provider implements the ClickUp data source provider for ClickUp Docs.
type Provider struct {
        client  *Client
        db      bun.IDB
        docRepo *documents.Repository
        log     *slog.Logger
}

// NewProvider creates a new ClickUp provider
func NewProvider(db bun.IDB, log *slog.Logger) *Provider <span class="cov0" title="0">{
        return &amp;Provider{
                client:  NewClient(log),
                db:      db,
                docRepo: documents.NewRepository(db, log),
                log:     log.With(logger.Scope("clickup-provider")),
        }
}</span>

// ProviderType returns the provider type identifier
func (p *Provider) ProviderType() string <span class="cov8" title="1">{
        return ProviderTypeClickUp
}</span>

// TestConnection tests if the ClickUp API credentials are valid
func (p *Provider) TestConnection(ctx context.Context, config ProviderConfig) error <span class="cov0" title="0">{
        clickupConfig, err := p.parseConfig(config.Config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Try to get workspaces to verify credentials
        <span class="cov0" title="0">resp, err := p.client.GetWorkspaces(ctx, clickupConfig.APIToken)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connection test failed: %w", err)
        }</span>

        <span class="cov0" title="0">if len(resp.Teams) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no workspaces found - check API token permissions")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Sync performs a full sync operation from ClickUp
func (p *Provider) Sync(ctx context.Context, config ProviderConfig, options SyncOptions, progressCB ProgressCallback) (*SyncResult, error) <span class="cov0" title="0">{
        clickupConfig, err := p.parseConfig(config.Config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := &amp;SyncResult{
                DocumentIDs: []string{},
                Errors:      []string{},
        }

        // Validate workspace ID
        if clickupConfig.WorkspaceID == "" </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, "Workspace ID not configured. Please test connection first.")
                return result, fmt.Errorf("workspace ID not configured")
        }</span>

        // Report starting phase
        <span class="cov0" title="0">if progressCB != nil </span><span class="cov0" title="0">{
                progressCB(Progress{
                        Phase:   "discovering",
                        Message: "Discovering ClickUp docs...",
                })
        }</span>

        // Get spaces to sync
        <span class="cov0" title="0">spaceIDs, err := p.getSpaceIDs(ctx, clickupConfig)
        if err != nil </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, err.Error())
                return result, err
        }</span>

        <span class="cov0" title="0">p.log.Info("discovered spaces to sync",
                slog.Int("space_count", len(spaceIDs)),
                slog.String("workspace_id", clickupConfig.WorkspaceID))

        // Collect all docs from spaces
        var allDocs []Doc
        for _, spaceID := range spaceIDs </span><span class="cov0" title="0">{
                docs, err := p.getDocsFromSpace(ctx, clickupConfig, spaceID)
                if err != nil </span><span class="cov0" title="0">{
                        p.log.Warn("failed to get docs from space",
                                logger.Error(err),
                                slog.String("space_id", spaceID))
                        continue</span>
                }
                <span class="cov0" title="0">allDocs = append(allDocs, docs...)</span>
        }

        <span class="cov0" title="0">result.TotalItems = len(allDocs)

        // Filter by lastSyncedAt for incremental sync
        if !options.FullSync &amp;&amp; clickupConfig.LastSyncedAt &gt; 0 </span><span class="cov0" title="0">{
                allDocs = p.filterByUpdatedSince(allDocs, clickupConfig.LastSyncedAt)
                p.log.Info("filtered to recently updated docs",
                        slog.Int("filtered_count", len(allDocs)),
                        slog.Int64("since", clickupConfig.LastSyncedAt))
        }</span>

        // Apply limit if specified
        <span class="cov0" title="0">if options.Limit &gt; 0 &amp;&amp; len(allDocs) &gt; options.Limit </span><span class="cov0" title="0">{
                allDocs = allDocs[:options.Limit]
        }</span>

        // Report importing phase
        <span class="cov0" title="0">if progressCB != nil </span><span class="cov0" title="0">{
                progressCB(Progress{
                        Phase:      "importing",
                        TotalItems: len(allDocs),
                        Message:    fmt.Sprintf("Importing %d docs...", len(allDocs)),
                })
        }</span>

        // Import each doc
        <span class="cov0" title="0">for i, doc := range allDocs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        result.Errors = append(result.Errors, "sync cancelled")
                        return result, ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">docID, skipped, err := p.importDoc(ctx, clickupConfig, doc, config.ProjectID, config.IntegrationID)
                result.ProcessedItems++

                if err != nil </span><span class="cov0" title="0">{
                        result.FailedItems++
                        result.Errors = append(result.Errors, fmt.Sprintf("doc %s: %s", doc.ID, err.Error()))
                        p.log.Warn("failed to import doc",
                                logger.Error(err),
                                slog.String("doc_id", doc.ID),
                                slog.String("doc_name", doc.Name))
                }</span> else<span class="cov0" title="0"> if skipped </span><span class="cov0" title="0">{
                        result.SkippedItems++
                }</span> else<span class="cov0" title="0"> {
                        result.SuccessfulItems++
                        result.DocumentIDs = append(result.DocumentIDs, docID)
                }</span>

                // Report progress
                <span class="cov0" title="0">if progressCB != nil &amp;&amp; i%10 == 0 </span><span class="cov0" title="0">{
                        progressCB(Progress{
                                Phase:           "importing",
                                TotalItems:      len(allDocs),
                                ProcessedItems:  result.ProcessedItems,
                                SuccessfulItems: result.SuccessfulItems,
                                FailedItems:     result.FailedItems,
                                SkippedItems:    result.SkippedItems,
                                Message:         fmt.Sprintf("Importing %d/%d docs...", result.ProcessedItems, len(allDocs)),
                        })
                }</span>
        }

        // Report completion
        <span class="cov0" title="0">if progressCB != nil </span><span class="cov0" title="0">{
                progressCB(Progress{
                        Phase:           "completed",
                        TotalItems:      len(allDocs),
                        ProcessedItems:  result.ProcessedItems,
                        SuccessfulItems: result.SuccessfulItems,
                        FailedItems:     result.FailedItems,
                        SkippedItems:    result.SkippedItems,
                        Message:         "Sync completed",
                })
        }</span>

        <span class="cov0" title="0">p.log.Info("clickup sync completed",
                slog.Int("total", result.TotalItems),
                slog.Int("imported", result.SuccessfulItems),
                slog.Int("skipped", result.SkippedItems),
                slog.Int("failed", result.FailedItems))

        return result, nil</span>
}

// ----------------------------------------------------------------------------
// Helper Methods
// ----------------------------------------------------------------------------

// parseConfig parses and validates the provider configuration
func (p *Provider) parseConfig(config map[string]interface{}) (*Config, error) <span class="cov8" title="1">{
        data, err := json.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal config: %w", err)
        }</span>

        <span class="cov8" title="1">var clickupConfig Config
        if err := json.Unmarshal(data, &amp;clickupConfig); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse config: %w", err)
        }</span>

        <span class="cov8" title="1">if clickupConfig.APIToken == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("API token is required")
        }</span>

        <span class="cov8" title="1">return &amp;clickupConfig, nil</span>
}

// getSpaceIDs returns the space IDs to sync
func (p *Provider) getSpaceIDs(ctx context.Context, config *Config) ([]string, error) <span class="cov0" title="0">{
        // If specific spaces are selected, use those
        if len(config.SelectedSpaces) &gt; 0 </span><span class="cov0" title="0">{
                ids := make([]string, len(config.SelectedSpaces))
                for i, s := range config.SelectedSpaces </span><span class="cov0" title="0">{
                        ids[i] = s.ID
                }</span>
                <span class="cov0" title="0">return ids, nil</span>
        }

        // Otherwise, get all spaces from the workspace
        <span class="cov0" title="0">resp, err := p.client.GetSpaces(ctx, config.APIToken, config.WorkspaceID, config.IncludeArchived)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get spaces: %w", err)
        }</span>

        <span class="cov0" title="0">ids := make([]string, len(resp.Spaces))
        for i, s := range resp.Spaces </span><span class="cov0" title="0">{
                ids[i] = s.ID
        }</span>

        <span class="cov0" title="0">return ids, nil</span>
}

// getDocsFromSpace retrieves all docs from a space
func (p *Provider) getDocsFromSpace(ctx context.Context, config *Config, spaceID string) ([]Doc, error) <span class="cov0" title="0">{
        var allDocs []Doc
        cursor := ""

        for </span><span class="cov0" title="0">{
                resp, err := p.client.GetDocs(ctx, config.APIToken, config.WorkspaceID, cursor, spaceID, "SPACE")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">allDocs = append(allDocs, resp.Docs...)

                if resp.NextCursor == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">cursor = resp.NextCursor</span>
        }

        <span class="cov0" title="0">return allDocs, nil</span>
}

// filterByUpdatedSince filters docs to those updated after the given timestamp
func (p *Provider) filterByUpdatedSince(docs []Doc, sinceMs int64) []Doc <span class="cov8" title="1">{
        var filtered []Doc
        for _, doc := range docs </span><span class="cov8" title="1">{
                updatedMs, err := strconv.ParseInt(doc.DateUpdated, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if updatedMs &gt; sinceMs </span><span class="cov8" title="1">{
                        filtered = append(filtered, doc)
                }</span>
        }
        <span class="cov8" title="1">return filtered</span>
}

// importDoc imports a single ClickUp doc as a document
// Returns the document ID, whether it was skipped, and any error
func (p *Provider) importDoc(ctx context.Context, config *Config, doc Doc, projectID, integrationID string) (string, bool, error) <span class="cov0" title="0">{
        // Fetch pages for this doc
        pages, err := p.client.GetDocPages(ctx, config.APIToken, config.WorkspaceID, doc.ID)
        if err != nil </span><span class="cov0" title="0">{
                p.log.Warn("failed to fetch pages for doc",
                        logger.Error(err),
                        slog.String("doc_id", doc.ID))
                pages = nil // Continue without pages
        }</span>

        // Check for existing document by clickupDocId
        <span class="cov0" title="0">existing, err := p.findExistingDoc(ctx, projectID, integrationID, doc.ID)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov0" title="0">if existing != nil </span><span class="cov0" title="0">{
                // Check if doc was modified
                if meta, ok := existing.Metadata["clickupUpdatedAt"].(string); ok &amp;&amp; meta == doc.DateUpdated </span><span class="cov0" title="0">{
                        // Not modified, skip
                        return existing.ID, true, nil
                }</span>

                // Update existing document
                <span class="cov0" title="0">if err := p.updateDocument(ctx, existing, doc, pages, config, integrationID); err != nil </span><span class="cov0" title="0">{
                        return "", false, err
                }</span>
                <span class="cov0" title="0">return existing.ID, false, nil</span>
        }

        // Create new document
        <span class="cov0" title="0">docID, err := p.createDocument(ctx, doc, pages, projectID, integrationID, config)
        if err != nil </span><span class="cov0" title="0">{
                return "", false, err
        }</span>

        <span class="cov0" title="0">return docID, false, nil</span>
}

// findExistingDoc finds an existing document by clickupDocId
func (p *Provider) findExistingDoc(ctx context.Context, projectID, integrationID, clickupDocID string) (*documents.Document, error) <span class="cov0" title="0">{
        var doc documents.Document
        err := p.db.NewSelect().
                Model(&amp;doc).
                Where("project_id = ?", projectID).
                Where("data_source_integration_id = ?", integrationID).
                Where("metadata-&gt;&gt;'clickupDocId' = ?", clickupDocID).
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if err.Error() == "sql: no rows in result set" </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("find existing doc: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;doc, nil</span>
}

// createDocument creates a new document from a ClickUp doc
func (p *Provider) createDocument(ctx context.Context, doc Doc, pages []Page, projectID, integrationID string, config *Config) (string, error) <span class="cov0" title="0">{
        // Build content from pages
        content := p.buildContent(doc.Name, pages)

        // Build metadata
        metadata := DocumentMetadata{
                ClickUpDocID:       doc.ID,
                ClickUpWorkspaceID: config.WorkspaceID,
                ClickUpCreatedAt:   doc.DateCreated,
                ClickUpUpdatedAt:   doc.DateUpdated,
                Archived:           doc.Archived,
                PageCount:          p.countPages(pages),
                Provider:           "clickup",
        }

        // Extract space ID if parent is a space (type 6)
        if doc.Parent.Type == 6 </span><span class="cov0" title="0">{
                metadata.ClickUpSpaceID = doc.Parent.ID
        }</span>

        // Extract avatar
        <span class="cov0" title="0">if doc.Avatar != nil </span><span class="cov0" title="0">{
                metadata.Avatar = doc.Avatar.Value
        }</span>

        <span class="cov0" title="0">metadataMap := make(map[string]any)
        metaJSON, _ := json.Marshal(metadata)
        json.Unmarshal(metaJSON, &amp;metadataMap)

        mimeType := "text/markdown"
        sourceType := SourceTypeClickUp
        conversionStatus := "not_required"

        document := &amp;documents.Document{
                ID:                      uuid.New().String(),
                ProjectID:               projectID,
                Filename:                &amp;doc.Name,
                Content:                 &amp;content,
                MimeType:                &amp;mimeType,
                SourceType:              &amp;sourceType,
                DataSourceIntegrationID: &amp;integrationID,
                ConversionStatus:        &amp;conversionStatus,
                Metadata:                metadataMap,
                CreatedAt:               time.Now(),
                UpdatedAt:               time.Now(),
        }

        if err := p.docRepo.Create(ctx, document); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("create document: %w", err)
        }</span>

        <span class="cov0" title="0">p.log.Debug("created document from ClickUp doc",
                slog.String("document_id", document.ID),
                slog.String("clickup_doc_id", doc.ID),
                slog.String("name", doc.Name))

        return document.ID, nil</span>
}

// updateDocument updates an existing document from a ClickUp doc
func (p *Provider) updateDocument(ctx context.Context, existing *documents.Document, doc Doc, pages []Page, config *Config, integrationID string) error <span class="cov0" title="0">{
        // Build content from pages
        content := p.buildContent(doc.Name, pages)

        // Build metadata
        metadata := DocumentMetadata{
                ClickUpDocID:       doc.ID,
                ClickUpWorkspaceID: config.WorkspaceID,
                ClickUpCreatedAt:   doc.DateCreated,
                ClickUpUpdatedAt:   doc.DateUpdated,
                Archived:           doc.Archived,
                PageCount:          p.countPages(pages),
                Provider:           "clickup",
        }

        if doc.Parent.Type == 6 </span><span class="cov0" title="0">{
                metadata.ClickUpSpaceID = doc.Parent.ID
        }</span>

        <span class="cov0" title="0">if doc.Avatar != nil </span><span class="cov0" title="0">{
                metadata.Avatar = doc.Avatar.Value
        }</span>

        <span class="cov0" title="0">metadataMap := make(map[string]any)
        metaJSON, _ := json.Marshal(metadata)
        json.Unmarshal(metaJSON, &amp;metadataMap)

        // Update fields
        existing.Filename = &amp;doc.Name
        existing.Content = &amp;content
        existing.Metadata = metadataMap
        existing.UpdatedAt = time.Now()

        _, err := p.db.NewUpdate().
                Model(existing).
                WherePK().
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update document: %w", err)
        }</span>

        <span class="cov0" title="0">p.log.Debug("updated document from ClickUp doc",
                slog.String("document_id", existing.ID),
                slog.String("clickup_doc_id", doc.ID),
                slog.String("name", doc.Name))

        return nil</span>
}

// buildContent combines doc name with page content into markdown
func (p *Provider) buildContent(docName string, pages []Page) string <span class="cov8" title="1">{
        var sb strings.Builder
        sb.WriteString(fmt.Sprintf("# %s\n\n", docName))

        if len(pages) == 0 </span><span class="cov8" title="1">{
                sb.WriteString("[No content]\n")
        }</span> else<span class="cov8" title="1"> {
                p.appendPagesContent(&amp;sb, pages, 2)
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

// appendPagesContent recursively appends page content with proper heading levels
func (p *Provider) appendPagesContent(sb *strings.Builder, pages []Page, level int) <span class="cov8" title="1">{
        for _, page := range pages </span><span class="cov8" title="1">{
                if page.Name == "" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Add page heading
                <span class="cov8" title="1">headerPrefix := strings.Repeat("#", level)
                sb.WriteString(fmt.Sprintf("%s %s\n\n", headerPrefix, page.Name))

                // Add page content
                if page.Content != "" </span><span class="cov8" title="1">{
                        sb.WriteString(page.Content)
                        sb.WriteString("\n\n")
                }</span>

                // Recursively add nested pages
                <span class="cov8" title="1">if len(page.Pages) &gt; 0 </span><span class="cov8" title="1">{
                        p.appendPagesContent(sb, page.Pages, level+1)
                }</span>
        }
}

// countPages counts total pages including nested pages
func (p *Provider) countPages(pages []Page) int <span class="cov8" title="1">{
        count := 0
        for _, page := range pages </span><span class="cov8" title="1">{
                count++
                if len(page.Pages) &gt; 0 </span><span class="cov8" title="1">{
                        count += p.countPages(page.Pages)
                }</span>
        }
        <span class="cov8" title="1">return count</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package datasource

import (
        "context"
        "log/slog"
        "sync"
        "time"

        "github.com/emergent/emergent-core/pkg/encryption"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Worker processes data source sync jobs from the queue.
// It follows the same pattern as other workers in the extraction domain.
type Worker struct {
        jobs       *JobsService
        registry   *ProviderRegistry
        encryption *encryption.Service
        cfg        *Config
        log        *slog.Logger
        stopCh     chan struct{}
        stopped    chan struct{}
        running    bool
        mu         sync.Mutex
        wg         sync.WaitGroup

        // Metrics
        processedCount   int64
        successCount     int64
        failureCount     int64
        deadLetterCount  int64
        metricsMu        sync.RWMutex
}

// NewWorker creates a new data source sync worker
func NewWorker(jobs *JobsService, registry *ProviderRegistry, enc *encryption.Service, cfg *Config, log *slog.Logger) *Worker <span class="cov0" title="0">{
        return &amp;Worker{
                jobs:       jobs,
                registry:   registry,
                encryption: enc,
                cfg:        cfg,
                log:        log.With(logger.Scope("datasource.worker")),
        }
}</span>

// Start begins the worker's polling loop
func (w *Worker) Start(ctx context.Context) error <span class="cov0" title="0">{
        w.mu.Lock()
        if w.running </span><span class="cov0" title="0">{
                w.mu.Unlock()
                return nil
        }</span>

        <span class="cov0" title="0">if !w.cfg.Enabled </span><span class="cov0" title="0">{
                w.log.Info("data source sync worker not started (disabled)")
                w.mu.Unlock()
                return nil
        }</span>

        <span class="cov0" title="0">w.running = true
        w.stopCh = make(chan struct{})
        w.stopped = make(chan struct{})
        w.mu.Unlock()

        // Recover stale jobs on startup
        go w.recoverStaleJobsOnStartup(ctx)

        w.log.Info("data source sync worker starting",
                slog.Duration("poll_interval", w.cfg.WorkerInterval()),
                slog.Int("batch_size", w.cfg.WorkerBatchSize))

        w.wg.Add(1)
        go w.run(ctx)

        return nil</span>
}

// Stop gracefully stops the worker
func (w *Worker) Stop(ctx context.Context) error <span class="cov0" title="0">{
        w.mu.Lock()
        if !w.running </span><span class="cov0" title="0">{
                w.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">w.running = false
        close(w.stopCh)
        w.mu.Unlock()

        w.log.Debug("waiting for data source sync worker to stop...")

        select </span>{
        case &lt;-w.stopped:<span class="cov0" title="0">
                w.log.Info("data source sync worker stopped gracefully")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                w.log.Warn("data source sync worker stop timeout")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// recoverStaleJobsOnStartup recovers jobs stuck in running state
func (w *Worker) recoverStaleJobsOnStartup(ctx context.Context) <span class="cov0" title="0">{
        recovered, err := w.jobs.RecoverStaleJobs(ctx, w.cfg.StaleJobMinutes)
        if err != nil </span><span class="cov0" title="0">{
                w.log.Warn("failed to recover stale jobs",
                        slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">if recovered &gt; 0 </span><span class="cov0" title="0">{
                w.log.Info("recovered stale sync jobs on startup",
                        slog.Int("count", recovered))
        }</span>
}

// run is the main worker loop
func (w *Worker) run(ctx context.Context) <span class="cov0" title="0">{
        defer w.wg.Done()
        defer close(w.stopped)

        ticker := time.NewTicker(w.cfg.WorkerInterval())
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := w.processBatch(ctx); err != nil </span><span class="cov0" title="0">{
                                w.log.Warn("process batch failed",
                                        slog.String("error", err.Error()))
                        }</span>
                }
        }
}

// processBatch processes a batch of sync jobs
func (w *Worker) processBatch(ctx context.Context) error <span class="cov0" title="0">{
        select </span>{
        case &lt;-w.stopCh:<span class="cov0" title="0">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">jobs, err := w.jobs.Dequeue(ctx, w.cfg.WorkerBatchSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(jobs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, job := range jobs </span><span class="cov0" title="0">{
                if err := w.processJob(ctx, job); err != nil </span><span class="cov0" title="0">{
                        w.log.Warn("process job failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", err.Error()))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// processJob processes a single sync job
func (w *Worker) processJob(ctx context.Context, job *DataSourceSyncJob) error <span class="cov0" title="0">{
        startTime := time.Now()
        w.log.Info("processing sync job",
                slog.String("job_id", job.ID),
                slog.String("integration_id", job.IntegrationID))

        // Get the integration
        integration, err := w.jobs.GetIntegration(ctx, job.IntegrationID)
        if err != nil </span><span class="cov0" title="0">{
                if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov0" title="0">w.incrementFailure()
                return err</span>
        }

        // Get the provider
        <span class="cov0" title="0">provider, ok := w.registry.Get(integration.ProviderType)
        if !ok </span><span class="cov0" title="0">{
                err := &amp;syncError{message: "provider not found: " + integration.ProviderType}
                if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov0" title="0">w.incrementFailure()
                return err</span>
        }

        // Update phase to syncing
        <span class="cov0" title="0">if err := w.jobs.MarkRunning(ctx, job.ID, "syncing"); err != nil </span><span class="cov0" title="0">{
                w.log.Warn("failed to update job phase",
                        slog.String("job_id", job.ID),
                        slog.String("error", err.Error()))
        }</span>

        // Decrypt the integration config
        <span class="cov0" title="0">var config map[string]interface{}
        if integration.ConfigEncrypted != nil &amp;&amp; *integration.ConfigEncrypted != "" </span><span class="cov0" title="0">{
                w.log.Debug("decrypting integration configuration",
                        slog.String("integration_id", integration.ID))
                var err error
                config, err = w.encryption.Decrypt(ctx, *integration.ConfigEncrypted)
                if err != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to decrypt integration config",
                                slog.String("integration_id", integration.ID),
                                slog.String("error", err.Error()))
                        if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                                w.log.Error("failed to mark job as failed",
                                        slog.String("job_id", job.ID),
                                        slog.String("error", markErr.Error()))
                        }</span>
                        <span class="cov0" title="0">w.incrementFailure()
                        return err</span>
                }
                <span class="cov0" title="0">w.log.Debug("configuration decrypted successfully")</span>
        } else<span class="cov0" title="0"> {
                config = make(map[string]interface{})
        }</span>

        // Build provider config
        <span class="cov0" title="0">providerConfig := ProviderConfig{
                IntegrationID: integration.ID,
                ProjectID:     integration.ProjectID,
                Config:        config,
                Metadata:      integration.Metadata,
        }

        // Build sync options
        syncOptions := SyncOptions{
                Custom: job.SyncOptions,
        }
        if job.ConfigurationID != nil </span><span class="cov0" title="0">{
                syncOptions.ConfigurationID = *job.ConfigurationID
        }</span>

        // Progress callback
        <span class="cov0" title="0">progressCallback := func(p Progress) </span><span class="cov0" title="0">{
                // Update job progress
                if err := w.jobs.UpdateProgress(ctx, job.ID,
                        p.TotalItems,
                        p.ProcessedItems,
                        p.SuccessfulItems,
                        p.FailedItems,
                        p.SkippedItems,
                        p.Phase,
                        p.Message,
                ); err != nil </span><span class="cov0" title="0">{
                        w.log.Warn("failed to update job progress",
                                slog.String("job_id", job.ID),
                                slog.String("error", err.Error()))
                }</span>
        }

        // Run the sync
        <span class="cov0" title="0">result, err := provider.Sync(ctx, providerConfig, syncOptions, progressCallback)
        if err != nil </span><span class="cov0" title="0">{
                // Update integration status
                errMsg := err.Error()
                if updateErr := w.jobs.UpdateIntegrationSyncStatus(ctx,
                        integration.ID, time.Now(), nil, IntegrationStatusError, &amp;errMsg); updateErr != nil </span><span class="cov0" title="0">{
                        w.log.Warn("failed to update integration status",
                                slog.String("integration_id", integration.ID),
                                slog.String("error", updateErr.Error()))
                }</span>

                // Use retry logic with dead letter handling
                <span class="cov0" title="0">willRetry, markErr := w.jobs.MarkFailedWithRetry(ctx, job.ID, err, job.RetryCount, job.MaxRetries)
                if markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>

                <span class="cov0" title="0">if !willRetry </span><span class="cov0" title="0">{
                        w.incrementDeadLetter()
                }</span> else<span class="cov0" title="0"> {
                        w.incrementFailure()
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // Update final progress
        <span class="cov0" title="0">if err := w.jobs.UpdateProgress(ctx, job.ID,
                result.TotalItems,
                result.ProcessedItems,
                result.SuccessfulItems,
                result.FailedItems,
                result.SkippedItems,
                "completed",
                "Sync completed successfully",
        ); err != nil </span><span class="cov0" title="0">{
                w.log.Warn("failed to update final progress",
                        slog.String("job_id", job.ID),
                        slog.String("error", err.Error()))
        }</span>

        // Mark job completed
        <span class="cov0" title="0">if err := w.jobs.MarkCompleted(ctx, job.ID); err != nil </span><span class="cov0" title="0">{
                w.log.Error("failed to mark job as completed",
                        slog.String("job_id", job.ID),
                        slog.String("error", err.Error()))
                return err
        }</span>

        // Update integration status
        <span class="cov0" title="0">var nextSync *time.Time
        if integration.SyncMode == SyncModeRecurring &amp;&amp; integration.SyncIntervalMinutes != nil </span><span class="cov0" title="0">{
                next := time.Now().Add(time.Duration(*integration.SyncIntervalMinutes) * time.Minute)
                nextSync = &amp;next
        }</span>
        <span class="cov0" title="0">if err := w.jobs.UpdateIntegrationSyncStatus(ctx,
                integration.ID, time.Now(), nextSync, IntegrationStatusActive, nil); err != nil </span><span class="cov0" title="0">{
                w.log.Warn("failed to update integration status",
                        slog.String("integration_id", integration.ID),
                        slog.String("error", err.Error()))
        }</span>

        <span class="cov0" title="0">durationMs := time.Since(startTime).Milliseconds()
        w.log.Info("sync job completed",
                slog.String("job_id", job.ID),
                slog.String("integration_id", job.IntegrationID),
                slog.Int("total", result.TotalItems),
                slog.Int("successful", result.SuccessfulItems),
                slog.Int("failed", result.FailedItems),
                slog.Int64("duration_ms", durationMs))

        w.incrementSuccess()
        return nil</span>
}

// incrementSuccess increments success metrics
func (w *Worker) incrementSuccess() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.successCount++
        w.metricsMu.Unlock()
}</span>

// incrementFailure increments failure metrics
func (w *Worker) incrementFailure() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.failureCount++
        w.metricsMu.Unlock()
}</span>

// incrementDeadLetter increments dead letter metrics
func (w *Worker) incrementDeadLetter() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.deadLetterCount++
        w.metricsMu.Unlock()
}</span>

// Metrics returns current worker metrics
func (w *Worker) Metrics() WorkerMetrics <span class="cov8" title="1">{
        w.metricsMu.RLock()
        defer w.metricsMu.RUnlock()

        return WorkerMetrics{
                Processed:  w.processedCount,
                Succeeded:  w.successCount,
                Failed:     w.failureCount,
                DeadLetter: w.deadLetterCount,
        }
}</span>

// WorkerMetrics contains worker metrics
type WorkerMetrics struct {
        Processed  int64 `json:"processed"`
        Succeeded  int64 `json:"succeeded"`
        Failed     int64 `json:"failed"`
        DeadLetter int64 `json:"deadLetter"`
}

// IsRunning returns whether the worker is running
func (w *Worker) IsRunning() bool <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        return w.running
}</span>

// syncError is a simple error type for sync failures
type syncError struct {
        message string
}

func (e *syncError) Error() string <span class="cov8" title="1">{
        return e.message
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package devtools

import (
        "log/slog"
        "net/http"
        "os"
        "path/filepath"
        "strings"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Handler serves developer tools endpoints
type Handler struct {
        log          *slog.Logger
        cfg          *config.Config
        coverageDir  string
        docsDir      string
}

// NewHandler creates a new devtools handler
func NewHandler(log *slog.Logger, cfg *config.Config) *Handler <span class="cov0" title="0">{
        // Determine base directory (relative to server-go)
        baseDir := "."
        if _, err := os.Stat("apps/server-go"); err == nil </span><span class="cov0" title="0">{
                baseDir = "apps/server-go"
        }</span>

        <span class="cov0" title="0">return &amp;Handler{
                log:         log.With(logger.Scope("devtools")),
                cfg:         cfg,
                coverageDir: filepath.Join(baseDir, "coverage"),
                docsDir:     filepath.Join(baseDir, "docs", "swagger"),
        }</span>
}

// ServeCoverage serves the coverage index page
func (h *Handler) ServeCoverage(c echo.Context) error <span class="cov0" title="0">{
        indexPath := filepath.Join(h.coverageDir, "index.html")

        // Check if coverage report exists
        if _, err := os.Stat(indexPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return h.serveCoverageNotFound(c)
        }</span>

        <span class="cov0" title="0">return c.File(indexPath)</span>
}

// ServeCoverageFiles serves coverage report files (CSS, JS, etc.)
func (h *Handler) ServeCoverageFiles(c echo.Context) error <span class="cov0" title="0">{
        // Get the requested file path
        requestPath := c.Param("*")
        if requestPath == "" </span><span class="cov0" title="0">{
                return h.ServeCoverage(c)
        }</span>

        <span class="cov0" title="0">filePath := filepath.Join(h.coverageDir, requestPath)

        // Security: prevent directory traversal
        absPath, err := filepath.Abs(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadRequest, "Invalid path")
        }</span>
        <span class="cov0" title="0">absDir, _ := filepath.Abs(h.coverageDir)
        if !strings.HasPrefix(absPath, absDir) </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusForbidden, "Access denied")
        }</span>

        // Check if file exists
        <span class="cov0" title="0">if _, err := os.Stat(filePath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "File not found")
        }</span>

        <span class="cov0" title="0">return c.File(filePath)</span>
}

// serveCoverageNotFound shows a helpful message when coverage isn't generated
func (h *Handler) serveCoverageNotFound(c echo.Context) error <span class="cov0" title="0">{
        html := `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Coverage Report - Not Generated&lt;/title&gt;
    &lt;style&gt;
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 40px; max-width: 800px; margin: 0 auto; }
        h1 { color: #333; }
        code { background: #f4f4f4; padding: 2px 8px; border-radius: 4px; }
        pre { background: #1e1e1e; color: #d4d4d4; padding: 16px; border-radius: 8px; overflow-x: auto; }
        .command { color: #9cdcfe; }
        .comment { color: #6a9955; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt; Coverage Report Not Found&lt;/h1&gt;
    &lt;p&gt;The coverage report has not been generated yet. Run the following commands to generate it:&lt;/p&gt;
    
    &lt;h3&gt;Generate Coverage Report&lt;/h3&gt;
    &lt;pre&gt;&lt;code&gt;&lt;span class="comment"&gt;# From apps/server-go directory:&lt;/span&gt;
&lt;span class="command"&gt;make test-coverage-html&lt;/span&gt;

&lt;span class="comment"&gt;# Or manually:&lt;/span&gt;
&lt;span class="command"&gt;go test -coverprofile=coverage/coverage.out ./...&lt;/span&gt;
&lt;span class="command"&gt;go tool cover -html=coverage/coverage.out -o coverage/index.html&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

    &lt;h3&gt;Generate E2E Test Coverage&lt;/h3&gt;
    &lt;pre&gt;&lt;code&gt;&lt;span class="comment"&gt;# Run E2E tests with coverage:&lt;/span&gt;
&lt;span class="command"&gt;./scripts/run-e2e-tests.sh --coverage&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;After generating the report, refresh this page.&lt;/p&gt;
    
    &lt;p&gt;&lt;a href="/docs"&gt; View API Documentation&lt;/a&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;`
        return c.HTML(http.StatusOK, html)
}</span>

// ServeDocsIndex serves the Swagger UI index page
func (h *Handler) ServeDocsIndex(c echo.Context) error <span class="cov0" title="0">{
        return h.serveSwaggerUI(c)
}</span>

// ServeDocs serves Swagger UI assets
func (h *Handler) ServeDocs(c echo.Context) error <span class="cov0" title="0">{
        requestPath := c.Param("*")
        
        // Serve index.html for empty path (shouldn't happen with new routes but keep as fallback)
        if requestPath == "" || requestPath == "/" </span><span class="cov0" title="0">{
                return h.serveSwaggerUI(c)
        }</span>

        // Try to serve from docs directory
        <span class="cov0" title="0">filePath := filepath.Join(h.docsDir, requestPath)
        if _, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                return c.File(filePath)
        }</span>

        <span class="cov0" title="0">return echo.NewHTTPError(http.StatusNotFound, "File not found")</span>
}

// serveSwaggerUI serves the Swagger UI HTML
func (h *Handler) serveSwaggerUI(c echo.Context) error <span class="cov0" title="0">{
        html := `&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Emergent API Documentation&lt;/title&gt;
    &lt;link rel="stylesheet" type="text/css" href="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui.css"&gt;
    &lt;style&gt;
        html { box-sizing: border-box; overflow: -moz-scrollbars-vertical; overflow-y: scroll; }
        *, *:before, *:after { box-sizing: inherit; }
        body { margin: 0; background: #fafafa; }
        .swagger-ui .topbar { display: none; }
        .swagger-ui .info { margin: 30px 0; }
        .swagger-ui .info .title { font-size: 36px; }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="swagger-ui"&gt;&lt;/div&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-bundle.js"&gt;&lt;/script&gt;
    &lt;script src="https://unpkg.com/swagger-ui-dist@5.9.0/swagger-ui-standalone-preset.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        window.onload = function() {
            // Determine the base path from current URL (handles /docs and /api/v2/docs)
            const basePath = window.location.pathname.replace(/\/docs\/?$/, '');
            const specUrl = basePath ? basePath + '/openapi.json' : '/openapi.json';
            
            window.ui = SwaggerUIBundle({
                url: specUrl,
                dom_id: '#swagger-ui',
                deepLinking: true,
                presets: [
                    SwaggerUIBundle.presets.apis,
                    SwaggerUIStandalonePreset
                ],
                plugins: [
                    SwaggerUIBundle.plugins.DownloadUrl
                ],
                layout: "StandaloneLayout",
                validatorUrl: null,
                persistAuthorization: true
            });
        };
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`
        return c.HTML(http.StatusOK, html)
}</span>

// ServeOpenAPISpec serves the OpenAPI JSON specification
func (h *Handler) ServeOpenAPISpec(c echo.Context) error <span class="cov0" title="0">{
        // Try to serve generated spec from docs directory
        specPath := filepath.Join(h.docsDir, "swagger.json")
        if _, err := os.Stat(specPath); err == nil </span><span class="cov0" title="0">{
                return c.File(specPath)
        }</span>

        // Return a minimal spec if none exists
        <span class="cov0" title="0">return h.serveMinimalSpec(c)</span>
}

// serveMinimalSpec returns a minimal OpenAPI spec when none is generated
func (h *Handler) serveMinimalSpec(c echo.Context) error <span class="cov0" title="0">{
        spec := map[string]any{
                "openapi": "3.0.3",
                "info": map[string]any{
                        "title":       "Emergent API",
                        "description": "Emergent Knowledge Base API - Go Server\n\nOpenAPI spec not yet generated. Run `make swagger` to generate the full spec from annotations.",
                        "version":     "1.0.0",
                        "contact": map[string]any{
                                "name": "Emergent Team",
                        },
                },
                "servers": []map[string]any{
                        {"url": "/", "description": "Current server"},
                },
                "paths": map[string]any{
                        "/health": map[string]any{
                                "get": map[string]any{
                                        "summary":     "Health check",
                                        "description": "Returns server health status",
                                        "tags":        []string{"Health"},
                                        "responses": map[string]any{
                                                "200": map[string]any{
                                                        "description": "Server is healthy",
                                                },
                                        },
                                },
                        },
                },
                "components": map[string]any{
                        "securitySchemes": map[string]any{
                                "bearerAuth": map[string]any{
                                        "type":         "http",
                                        "scheme":       "bearer",
                                        "bearerFormat": "JWT",
                                },
                        },
                },
                "security": []map[string]any{
                        {"bearerAuth": []string{}},
                },
                "tags": []map[string]any{
                        {"name": "Health", "description": "Health check endpoints"},
                        {"name": "Documents", "description": "Document management"},
                        {"name": "Chunks", "description": "Document chunk management"},
                        {"name": "Graph", "description": "Knowledge graph operations"},
                        {"name": "Search", "description": "Search operations"},
                        {"name": "Chat", "description": "Chat conversations"},
                        {"name": "MCP", "description": "Model Context Protocol"},
                },
        }
        return c.JSON(http.StatusOK, spec)
}</span>

// EnsureCoverageDir creates the coverage directory if it doesn't exist
func (h *Handler) EnsureCoverageDir() error <span class="cov0" title="0">{
        return os.MkdirAll(h.coverageDir, 0755)
}</span>

// EnsureDocsDir creates the docs directory if it doesn't exist
func (h *Handler) EnsureDocsDir() error <span class="cov0" title="0">{
        return os.MkdirAll(h.docsDir, 0755)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package devtools

import (
        "log/slog"

        "github.com/labstack/echo/v4"
        "go.uber.org/fx"

        "github.com/emergent/emergent-core/internal/config"
)

// Module provides developer tools endpoints (coverage, docs)
var Module = fx.Module("devtools",
        fx.Provide(NewHandler),
        fx.Invoke(RegisterRoutes),
)

// RegisterRoutes registers all devtools routes
func RegisterRoutes(e *echo.Echo, h *Handler, cfg *config.Config, log *slog.Logger) <span class="cov0" title="0">{
        // Only enable in development/debug mode
        if !cfg.Debug </span><span class="cov0" title="0">{
                log.Info("devtools endpoints disabled (not in debug mode)")
                return
        }</span>

        // Coverage endpoint - serves HTML coverage report
        <span class="cov0" title="0">e.GET("/coverage", h.ServeCoverage)
        e.GET("/coverage/*", h.ServeCoverageFiles)

        // Docs endpoint - serves OpenAPI/Swagger UI
        e.GET("/docs", h.ServeDocsIndex)
        e.GET("/docs/", h.ServeDocsIndex)
        e.GET("/docs/*", h.ServeDocs)

        // OpenAPI spec endpoint
        e.GET("/openapi.json", h.ServeOpenAPISpec)

        log.Info("devtools endpoints registered",
                slog.String("coverage", "/coverage"),
                slog.String("docs", "/docs"),
                slog.String("openapi", "/openapi.json"),
        )</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package documents

import (
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

// Handler handles document HTTP requests
type Handler struct {
        svc *Service
}

// NewHandler creates a new documents handler
func NewHandler(svc *Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{svc: svc}
}</span>

// List handles GET /api/v2/documents
func (h *Handler) List(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        // Parse query parameters
        <span class="cov8" title="1">params := ListParams{
                ProjectID: user.ProjectID,
        }

        // Limit
        if limitStr := c.QueryParam("limit"); limitStr != "" </span><span class="cov8" title="1">{
                limit, err := parsePositiveInt(limitStr, 1, 500)
                if err != nil </span><span class="cov8" title="1">{
                        return apperror.ErrBadRequest.WithMessage("limit must be between 1 and 500")
                }</span>
                <span class="cov8" title="1">params.Limit = limit</span>
        }

        // Cursor
        <span class="cov8" title="1">if cursorStr := c.QueryParam("cursor"); cursorStr != "" </span><span class="cov8" title="1">{
                cursor, err := ParseCursor(cursorStr)
                if err != nil </span><span class="cov8" title="1">{
                        return apperror.ErrBadRequest.WithMessage("invalid cursor")
                }</span>
                <span class="cov8" title="1">params.Cursor = cursor</span>
        }

        // Filters
        <span class="cov8" title="1">if sourceType := c.QueryParam("sourceType"); sourceType != "" </span><span class="cov8" title="1">{
                params.SourceType = &amp;sourceType
        }</span>
        <span class="cov8" title="1">if integrationID := c.QueryParam("integrationId"); integrationID != "" </span><span class="cov0" title="0">{
                params.IntegrationID = &amp;integrationID
        }</span>
        <span class="cov8" title="1">if rootOnly := c.QueryParam("rootOnly"); rootOnly == "true" </span><span class="cov8" title="1">{
                params.RootOnly = true
        }</span>
        <span class="cov8" title="1">if parentID := c.QueryParam("parentDocumentId"); parentID != "" </span><span class="cov8" title="1">{
                params.ParentDocumentID = &amp;parentID
        }</span>

        // Execute query
        <span class="cov8" title="1">result, err := h.svc.List(c.Request().Context(), params)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrInternal.WithInternal(err)
        }</span>

        // Set cursor header if there are more results
        <span class="cov8" title="1">if result.NextCursor != nil </span><span class="cov8" title="1">{
                c.Response().Header().Set("x-next-cursor", *result.NextCursor)
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// GetByID handles GET /api/v2/documents/:id
func (h *Handler) GetByID(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        <span class="cov8" title="1">documentID := c.Param("id")
        if documentID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("document id required")
        }</span>

        <span class="cov8" title="1">doc, err := h.svc.GetByID(c.Request().Context(), user.ProjectID, documentID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, doc)</span>
}

// Create handles POST /api/v2/documents
func (h *Handler) Create(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        <span class="cov8" title="1">var req CreateDocumentRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("Invalid request body")
        }</span>

        // Validate request
        <span class="cov8" title="1">if err := validateCreateRequest(&amp;req); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">doc, wasCreated, err := h.svc.Create(c.Request().Context(), CreateParams{
                ProjectID: user.ProjectID,
                Filename:  req.Filename,
                Content:   req.Content,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Return 201 for new document, 200 for deduplicated existing document
        <span class="cov8" title="1">status := http.StatusCreated
        if !wasCreated </span><span class="cov8" title="1">{
                status = http.StatusOK
        }</span>

        <span class="cov8" title="1">return c.JSON(status, doc)</span>
}

// Delete handles DELETE /api/v2/documents/:id
func (h *Handler) Delete(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        <span class="cov8" title="1">documentID := c.Param("id")
        if documentID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("document id required")
        }</span>

        <span class="cov8" title="1">response, err := h.svc.Delete(c.Request().Context(), user.ProjectID, documentID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, response)</span>
}

// BulkDelete handles DELETE /api/v2/documents (with body)
func (h *Handler) BulkDelete(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        <span class="cov8" title="1">var req BulkDeleteRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("Invalid request body")
        }</span>

        // Validate request
        <span class="cov8" title="1">if len(req.IDs) == 0 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("ids array is required and must not be empty")
        }</span>

        <span class="cov8" title="1">response, err := h.svc.BulkDelete(c.Request().Context(), user.ProjectID, req.IDs)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, response)</span>
}

// validateCreateRequest validates the create document request
func validateCreateRequest(req *CreateDocumentRequest) error <span class="cov8" title="1">{
        // Filename max length validation
        if len(req.Filename) &gt; 512 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("filename must be at most 512 characters")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// parsePositiveInt parses a string as an int and validates it's within bounds
func parsePositiveInt(s string, min, max int) (int, error) <span class="cov8" title="1">{
        var n int
        for _, c := range s </span><span class="cov8" title="1">{
                if c &lt; '0' || c &gt; '9' </span><span class="cov8" title="1">{
                        return 0, apperror.ErrBadRequest
                }</span>
                <span class="cov8" title="1">n = n*10 + int(c-'0')
                if n &gt; max </span><span class="cov8" title="1">{
                        return 0, apperror.ErrBadRequest
                }</span>
        }
        <span class="cov8" title="1">if n &lt; min </span><span class="cov8" title="1">{
                return 0, apperror.ErrBadRequest
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package documents

import (
        "context"
        "database/sql"
        "encoding/base64"
        "encoding/json"
        "fmt"
        "log/slog"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
        "github.com/emergent/emergent-core/pkg/pgutils"
)

// Repository handles document database operations
type Repository struct {
        db  bun.IDB
        log *slog.Logger
}

// NewRepository creates a new documents repository
func NewRepository(db bun.IDB, log *slog.Logger) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                db:  db,
                log: log.With(logger.Scope("documents-repo")),
        }
}</span>

// List retrieves documents with pagination and filtering
func (r *Repository) List(ctx context.Context, params ListParams) (*ListResult, error) <span class="cov8" title="1">{
        // Default limit
        if params.Limit &lt;= 0 </span><span class="cov8" title="1">{
                params.Limit = 100
        }</span>
        <span class="cov8" title="1">if params.Limit &gt; 500 </span><span class="cov0" title="0">{
                params.Limit = 500
        }</span>

        // Build base query with RLS context via project_id
        <span class="cov8" title="1">query := r.db.NewSelect().
                Model((*Document)(nil)).
                Where("project_id = ?", params.ProjectID)

        // Apply filters
        if params.SourceType != nil </span><span class="cov8" title="1">{
                query = query.Where("source_type = ?", *params.SourceType)
        }</span>
        <span class="cov8" title="1">if params.IntegrationID != nil </span><span class="cov0" title="0">{
                query = query.Where("data_source_integration_id = ?", *params.IntegrationID)
        }</span>
        <span class="cov8" title="1">if params.RootOnly </span><span class="cov8" title="1">{
                query = query.Where("parent_document_id IS NULL")
        }</span>
        <span class="cov8" title="1">if params.ParentDocumentID != nil </span><span class="cov8" title="1">{
                query = query.Where("parent_document_id = ?", *params.ParentDocumentID)
        }</span>

        // Apply cursor-based pagination
        <span class="cov8" title="1">if params.Cursor != nil </span><span class="cov8" title="1">{
                query = query.Where("(created_at, id) &lt; (?, ?)", params.Cursor.CreatedAt, params.Cursor.ID)
        }</span>

        // Get total count (without pagination)
        <span class="cov8" title="1">countQuery := r.db.NewSelect().
                Model((*Document)(nil)).
                Where("project_id = ?", params.ProjectID)
        
        if params.SourceType != nil </span><span class="cov8" title="1">{
                countQuery = countQuery.Where("source_type = ?", *params.SourceType)
        }</span>
        <span class="cov8" title="1">if params.IntegrationID != nil </span><span class="cov0" title="0">{
                countQuery = countQuery.Where("data_source_integration_id = ?", *params.IntegrationID)
        }</span>
        <span class="cov8" title="1">if params.RootOnly </span><span class="cov8" title="1">{
                countQuery = countQuery.Where("parent_document_id IS NULL")
        }</span>
        <span class="cov8" title="1">if params.ParentDocumentID != nil </span><span class="cov8" title="1">{
                countQuery = countQuery.Where("parent_document_id = ?", *params.ParentDocumentID)
        }</span>

        <span class="cov8" title="1">total, err := countQuery.Count(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("count documents: %w", err)
        }</span>

        // Order by created_at DESC, id DESC for cursor pagination
        <span class="cov8" title="1">query = query.Order("created_at DESC", "id DESC").
                Limit(params.Limit + 1) // +1 to detect if there are more

        documents := []Document{} // Initialize to empty slice, not nil
        if err := query.Scan(ctx, &amp;documents); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("list documents: %w", err)
        }</span>

        // Check if there are more results
        <span class="cov8" title="1">var nextCursor *string
        if len(documents) &gt; params.Limit </span><span class="cov8" title="1">{
                // There are more results - create cursor from last item we're returning
                documents = documents[:params.Limit]
                lastDoc := documents[len(documents)-1]
                cursor := Cursor{
                        CreatedAt: lastDoc.CreatedAt,
                        ID:        lastDoc.ID,
                }
                cursorJSON, _ := json.Marshal(cursor)
                encoded := base64.URLEncoding.EncodeToString(cursorJSON)
                nextCursor = &amp;encoded
        }</span>

        <span class="cov8" title="1">return &amp;ListResult{
                Documents:  documents,
                Total:      total,
                NextCursor: nextCursor,
        }, nil</span>
}

// GetByID retrieves a single document by ID
func (r *Repository) GetByID(ctx context.Context, projectID, documentID string) (*Document, error) <span class="cov8" title="1">{
        var doc Document
        err := r.db.NewSelect().
                Model(&amp;doc).
                Where("id = ?", documentID).
                Where("project_id = ?", projectID).
                Scan(ctx)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil // Return nil, nil for not found (let caller decide error)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get document: %w", err)</span>
        }

        <span class="cov8" title="1">return &amp;doc, nil</span>
}

// GetByContentHash retrieves a document by content hash (for deduplication)
func (r *Repository) GetByContentHash(ctx context.Context, projectID, contentHash string) (*Document, error) <span class="cov8" title="1">{
        var doc Document
        err := r.db.NewSelect().
                Model(&amp;doc).
                Where("project_id = ?", projectID).
                Where("content_hash = ?", contentHash).
                Scan(ctx)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get document by content hash: %w", err)</span>
        }

        <span class="cov8" title="1">return &amp;doc, nil</span>
}

// GetByFileHash retrieves a document by file hash (for upload deduplication)
func (r *Repository) GetByFileHash(ctx context.Context, projectID, fileHash string) (*Document, error) <span class="cov0" title="0">{
        var doc Document
        err := r.db.NewSelect().
                Model(&amp;doc).
                Where("project_id = ?", projectID).
                Where("file_hash = ?", fileHash).
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("get document by file hash: %w", err)</span>
        }

        <span class="cov0" title="0">return &amp;doc, nil</span>
}

// Create creates a new document in the database
func (r *Repository) Create(ctx context.Context, doc *Document) error <span class="cov8" title="1">{
        _, err := r.db.NewInsert().
                Model(doc).
                Returning("*").
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if pgutils.IsUniqueViolation(err) </span><span class="cov0" title="0">{
                        // Content hash duplicate - let service handle this
                        return apperror.New(409, "duplicate", "Document with this content already exists")
                }</span>
                <span class="cov0" title="0">if pgutils.IsForeignKeyViolation(err) </span><span class="cov0" title="0">{
                        return apperror.New(400, "invalid-project", "Project not found")
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to create document", logger.Error(err))
                return apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Delete permanently deletes a document by ID
// Returns true if a document was deleted, false if not found
func (r *Repository) Delete(ctx context.Context, projectID, documentID string) (bool, error) <span class="cov0" title="0">{
        result, err := r.db.NewDelete().
                Model((*Document)(nil)).
                Where("id = ?", documentID).
                Where("project_id = ?", projectID).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to delete document", logger.Error(err), slog.String("id", documentID))
                return false, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov0" title="0">rowsAffected, _ := result.RowsAffected()
        return rowsAffected &gt; 0, nil</span>
}

// DeleteWithCascade deletes a document and all related entities in a transaction
// Returns a summary of what was deleted
func (r *Repository) DeleteWithCascade(ctx context.Context, projectID, documentID string) (*DeleteSummary, error) <span class="cov8" title="1">{
        summary := &amp;DeleteSummary{}

        err := r.db.RunInTx(ctx, nil, func(ctx context.Context, tx bun.Tx) error </span><span class="cov8" title="1">{
                // 1. Delete notifications related to this document
                result, err := tx.NewDelete().
                        TableExpr("kb.notifications").
                        Where("related_resource_type = ?", "document").
                        Where("related_resource_id = ?", documentID).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete notifications: %w", err)
                }</span>
                <span class="cov8" title="1">if n, _ := result.RowsAffected(); n &gt; 0 </span><span class="cov0" title="0">{
                        summary.Notifications = int(n)
                }</span>

                // 2. Get extraction job IDs for this document
                <span class="cov8" title="1">var jobIDs []string
                err = tx.NewSelect().
                        TableExpr("kb.object_extraction_jobs").
                        Column("id").
                        Where("document_id = ?", documentID).
                        Scan(ctx, &amp;jobIDs)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("get extraction jobs: %w", err)
                }</span>

                <span class="cov8" title="1">if len(jobIDs) &gt; 0 </span><span class="cov0" title="0">{
                        // 3. Get graph object IDs from these jobs
                        var objectIDs []string
                        err = tx.NewSelect().
                                TableExpr("kb.graph_objects").
                                Column("id").
                                Where("extraction_job_id IN (?)", bun.In(jobIDs)).
                                Scan(ctx, &amp;objectIDs)
                        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                                return fmt.Errorf("get graph objects: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(objectIDs) &gt; 0 </span><span class="cov0" title="0">{
                                // 4. Delete graph relationships involving these objects
                                result, err = tx.NewDelete().
                                        TableExpr("kb.graph_relationships").
                                        Where("src_id IN (?) OR dst_id IN (?)", bun.In(objectIDs), bun.In(objectIDs)).
                                        Exec(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("delete relationships: %w", err)
                                }</span>
                                <span class="cov0" title="0">if n, _ := result.RowsAffected(); n &gt; 0 </span><span class="cov0" title="0">{
                                        summary.GraphRelationships = int(n)
                                }</span>

                                // 5. Delete graph objects
                                <span class="cov0" title="0">result, err = tx.NewDelete().
                                        TableExpr("kb.graph_objects").
                                        Where("id IN (?)", bun.In(objectIDs)).
                                        Exec(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("delete graph objects: %w", err)
                                }</span>
                                <span class="cov0" title="0">if n, _ := result.RowsAffected(); n &gt; 0 </span><span class="cov0" title="0">{
                                        summary.GraphObjects = int(n)
                                }</span>
                        }

                        // 6. Delete extraction jobs
                        <span class="cov0" title="0">result, err = tx.NewDelete().
                                TableExpr("kb.object_extraction_jobs").
                                Where("id IN (?)", bun.In(jobIDs)).
                                Exec(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("delete extraction jobs: %w", err)
                        }</span>
                        <span class="cov0" title="0">if n, _ := result.RowsAffected(); n &gt; 0 </span><span class="cov0" title="0">{
                                summary.ExtractionJobs = int(n)
                        }</span>
                }

                // 7. Delete chunks (should cascade via FK, but explicit for count)
                <span class="cov8" title="1">result, err = tx.NewDelete().
                        TableExpr("kb.chunks").
                        Where("document_id = ?", documentID).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete chunks: %w", err)
                }</span>
                <span class="cov8" title="1">if n, _ := result.RowsAffected(); n &gt; 0 </span><span class="cov0" title="0">{
                        summary.Chunks = int(n)
                }</span>

                // 8. Delete the document itself
                <span class="cov8" title="1">result, err = tx.NewDelete().
                        Model((*Document)(nil)).
                        Where("id = ?", documentID).
                        Where("project_id = ?", projectID).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete document: %w", err)
                }</span>

                <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()
                if rowsAffected == 0 </span><span class="cov8" title="1">{
                        return apperror.ErrNotFound.WithMessage("Document not found")
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                if appErr, ok := err.(*apperror.Error); ok </span><span class="cov8" title="1">{
                        return nil, appErr
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to delete document with cascade", logger.Error(err), slog.String("id", documentID))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return summary, nil</span>
}

// BulkDeleteWithCascade deletes multiple documents and their related entities
// Returns a summary and list of IDs that were not found
func (r *Repository) BulkDeleteWithCascade(ctx context.Context, projectID string, documentIDs []string) (*DeleteSummary, []string, error) <span class="cov8" title="1">{
        summary := &amp;DeleteSummary{}
        var notFound []string

        // First, verify which documents exist
        var existingIDs []string
        err := r.db.NewSelect().
                Model((*Document)(nil)).
                Column("id").
                Where("id IN (?)", bun.In(documentIDs)).
                Where("project_id = ?", projectID).
                Scan(ctx, &amp;existingIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        // Find which IDs don't exist
        <span class="cov8" title="1">existingSet := make(map[string]bool)
        for _, id := range existingIDs </span><span class="cov8" title="1">{
                existingSet[id] = true
        }</span>
        <span class="cov8" title="1">for _, id := range documentIDs </span><span class="cov8" title="1">{
                if !existingSet[id] </span><span class="cov8" title="1">{
                        notFound = append(notFound, id)
                }</span>
        }

        // If no documents exist, return early
        <span class="cov8" title="1">if len(existingIDs) == 0 </span><span class="cov0" title="0">{
                return summary, notFound, nil
        }</span>

        <span class="cov8" title="1">err = r.db.RunInTx(ctx, nil, func(ctx context.Context, tx bun.Tx) error </span><span class="cov8" title="1">{
                // 1. Delete notifications
                result, err := tx.NewDelete().
                        TableExpr("kb.notifications").
                        Where("related_resource_type = ?", "document").
                        Where("related_resource_id IN (?)", bun.In(existingIDs)).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete notifications: %w", err)
                }</span>
                <span class="cov8" title="1">if n, _ := result.RowsAffected(); n &gt; 0 </span><span class="cov0" title="0">{
                        summary.Notifications = int(n)
                }</span>

                // 2. Get extraction job IDs
                <span class="cov8" title="1">var jobIDs []string
                err = tx.NewSelect().
                        TableExpr("kb.object_extraction_jobs").
                        Column("id").
                        Where("document_id IN (?)", bun.In(existingIDs)).
                        Scan(ctx, &amp;jobIDs)
                if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                        return fmt.Errorf("get extraction jobs: %w", err)
                }</span>

                <span class="cov8" title="1">if len(jobIDs) &gt; 0 </span><span class="cov0" title="0">{
                        // 3. Get graph object IDs
                        var objectIDs []string
                        err = tx.NewSelect().
                                TableExpr("kb.graph_objects").
                                Column("id").
                                Where("extraction_job_id IN (?)", bun.In(jobIDs)).
                                Scan(ctx, &amp;objectIDs)
                        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                                return fmt.Errorf("get graph objects: %w", err)
                        }</span>

                        <span class="cov0" title="0">if len(objectIDs) &gt; 0 </span><span class="cov0" title="0">{
                                // 4. Delete relationships
                                result, err = tx.NewDelete().
                                        TableExpr("kb.graph_relationships").
                                        Where("src_id IN (?) OR dst_id IN (?)", bun.In(objectIDs), bun.In(objectIDs)).
                                        Exec(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("delete relationships: %w", err)
                                }</span>
                                <span class="cov0" title="0">if n, _ := result.RowsAffected(); n &gt; 0 </span><span class="cov0" title="0">{
                                        summary.GraphRelationships = int(n)
                                }</span>

                                // 5. Delete graph objects
                                <span class="cov0" title="0">result, err = tx.NewDelete().
                                        TableExpr("kb.graph_objects").
                                        Where("id IN (?)", bun.In(objectIDs)).
                                        Exec(ctx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("delete graph objects: %w", err)
                                }</span>
                                <span class="cov0" title="0">if n, _ := result.RowsAffected(); n &gt; 0 </span><span class="cov0" title="0">{
                                        summary.GraphObjects = int(n)
                                }</span>
                        }

                        // 6. Delete extraction jobs
                        <span class="cov0" title="0">result, err = tx.NewDelete().
                                TableExpr("kb.object_extraction_jobs").
                                Where("id IN (?)", bun.In(jobIDs)).
                                Exec(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("delete extraction jobs: %w", err)
                        }</span>
                        <span class="cov0" title="0">if n, _ := result.RowsAffected(); n &gt; 0 </span><span class="cov0" title="0">{
                                summary.ExtractionJobs = int(n)
                        }</span>
                }

                // 7. Delete chunks
                <span class="cov8" title="1">result, err = tx.NewDelete().
                        TableExpr("kb.chunks").
                        Where("document_id IN (?)", bun.In(existingIDs)).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete chunks: %w", err)
                }</span>
                <span class="cov8" title="1">if n, _ := result.RowsAffected(); n &gt; 0 </span><span class="cov0" title="0">{
                        summary.Chunks = int(n)
                }</span>

                // 8. Delete documents
                <span class="cov8" title="1">result, err = tx.NewDelete().
                        Model((*Document)(nil)).
                        Where("id IN (?)", bun.In(existingIDs)).
                        Where("project_id = ?", projectID).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("delete documents: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to bulk delete documents", logger.Error(err))
                return nil, nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return summary, notFound, nil</span>
}

// ParseCursor decodes a base64-encoded cursor
func ParseCursor(encoded string) (*Cursor, error) <span class="cov8" title="1">{
        if encoded == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">data, err := base64.URLEncoding.DecodeString(encoded)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid cursor encoding: %w", err)
        }</span>

        <span class="cov8" title="1">var cursor Cursor
        if err := json.Unmarshal(data, &amp;cursor); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid cursor format: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;cursor, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package documents

import (
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/auth"
)

// RegisterRoutes registers document routes with the Echo router
func RegisterRoutes(e *echo.Echo, h *Handler, uploadHandler *UploadHandler, authMiddleware *auth.Middleware) <span class="cov8" title="1">{
        // Base group for documents - all routes require authentication and project ID
        g := e.Group("/api/v2/documents")
        g.Use(authMiddleware.RequireAuth())
        g.Use(authMiddleware.RequireProjectID())

        // Read operations - require documents:read scope
        readGroup := g.Group("")
        readGroup.Use(authMiddleware.RequireScopes("documents:read"))
        readGroup.GET("", h.List)
        readGroup.GET("/:id", h.GetByID)

        // Write operations - require documents:write scope
        writeGroup := g.Group("")
        writeGroup.Use(authMiddleware.RequireScopes("documents:write"))
        writeGroup.POST("", h.Create)
        writeGroup.POST("/upload", uploadHandler.Upload)

        // Delete operations - require documents:delete scope
        deleteGroup := g.Group("")
        deleteGroup.Use(authMiddleware.RequireScopes("documents:delete"))
        deleteGroup.DELETE("", h.BulkDelete)
        deleteGroup.DELETE("/:id", h.Delete)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package documents

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "log/slog"
        "strings"
        "time"

        "github.com/google/uuid"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Service handles document business logic
type Service struct {
        repo *Repository
        log  *slog.Logger
}

// NewService creates a new documents service
func NewService(repo *Repository, log *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: repo,
                log:  log.With(logger.Scope("documents.svc")),
        }
}</span>

// List retrieves documents with pagination and filtering
func (s *Service) List(ctx context.Context, params ListParams) (*ListResult, error) <span class="cov8" title="1">{
        return s.repo.List(ctx, params)
}</span>

// GetByID retrieves a single document by ID
func (s *Service) GetByID(ctx context.Context, projectID, documentID string) (*Document, error) <span class="cov8" title="1">{
        doc, err := s.repo.GetByID(ctx, projectID, documentID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if doc == nil </span><span class="cov8" title="1">{
                return nil, apperror.ErrNotFound.WithMessage("Document not found")
        }</span>
        <span class="cov8" title="1">return doc, nil</span>
}

// CreateParams contains parameters for creating a document
type CreateParams struct {
        ProjectID string
        Filename  string
        Content   string
}

// Create creates a new document with content deduplication
// If a document with the same content hash exists, returns the existing document
func (s *Service) Create(ctx context.Context, params CreateParams) (*Document, bool, error) <span class="cov8" title="1">{
        // Apply defaults
        filename := strings.TrimSpace(params.Filename)
        if filename == "" </span><span class="cov8" title="1">{
                filename = "unnamed.txt"
        }</span>

        <span class="cov8" title="1">content := params.Content
        if content == "" </span><span class="cov8" title="1">{
                content = ""
        }</span>

        // Calculate content hash for deduplication
        <span class="cov8" title="1">contentHash := computeContentHash(content)

        // Check for existing document with same content hash (deduplication)
        existingDoc, err := s.repo.GetByContentHash(ctx, params.ProjectID, contentHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">if existingDoc != nil </span><span class="cov8" title="1">{
                s.log.Info("document deduplicated",
                        slog.String("projectId", params.ProjectID),
                        slog.String("existingId", existingDoc.ID),
                        slog.String("contentHash", contentHash))
                return existingDoc, false, nil // Return existing doc, wasCreated=false
        }</span>

        // Create new document
        <span class="cov8" title="1">now := time.Now().UTC()
        doc := &amp;Document{
                ID:          uuid.New().String(),
                ProjectID:   params.ProjectID,
                Filename:    &amp;filename,
                Content:     &amp;content,
                ContentHash: &amp;contentHash,
                CreatedAt:   now,
                UpdatedAt:   now,
        }

        err = s.repo.Create(ctx, doc)
        if err != nil </span><span class="cov0" title="0">{
                // Handle race condition: another request may have created the same document
                if appErr, ok := err.(*apperror.Error); ok &amp;&amp; appErr.Code == "duplicate" </span><span class="cov0" title="0">{
                        existingDoc, getErr := s.repo.GetByContentHash(ctx, params.ProjectID, contentHash)
                        if getErr == nil &amp;&amp; existingDoc != nil </span><span class="cov0" title="0">{
                                return existingDoc, false, nil
                        }</span>
                }
                <span class="cov0" title="0">return nil, false, err</span>
        }

        <span class="cov8" title="1">s.log.Info("document created",
                slog.String("id", doc.ID),
                slog.String("projectId", params.ProjectID),
                slog.String("filename", filename))

        return doc, true, nil</span> // Return new doc, wasCreated=true
}

// Delete deletes a document and all related entities
func (s *Service) Delete(ctx context.Context, projectID, documentID string) (*DeleteResponse, error) <span class="cov8" title="1">{
        // Validate UUID format
        if _, err := uuid.Parse(documentID); err != nil </span><span class="cov8" title="1">{
                return nil, apperror.ErrBadRequest.WithMessage("Invalid document ID format")
        }</span>

        <span class="cov8" title="1">summary, err := s.repo.DeleteWithCascade(ctx, projectID, documentID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s.log.Info("document deleted",
                slog.String("id", documentID),
                slog.String("projectId", projectID),
                slog.Int("chunks", summary.Chunks),
                slog.Int("extractionJobs", summary.ExtractionJobs))

        return &amp;DeleteResponse{
                Status:  "deleted",
                Summary: summary,
        }, nil</span>
}

// BulkDelete deletes multiple documents and all related entities
func (s *Service) BulkDelete(ctx context.Context, projectID string, documentIDs []string) (*DeleteResponse, error) <span class="cov8" title="1">{
        // Validate all UUIDs
        for _, id := range documentIDs </span><span class="cov8" title="1">{
                if _, err := uuid.Parse(id); err != nil </span><span class="cov8" title="1">{
                        return nil, apperror.ErrBadRequest.WithMessage("Invalid document ID format: " + id)
                }</span>
        }

        <span class="cov8" title="1">summary, notFound, err := s.repo.BulkDeleteWithCascade(ctx, projectID, documentIDs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">deleted := len(documentIDs) - len(notFound)
        status := "deleted"
        if len(notFound) &gt; 0 </span><span class="cov8" title="1">{
                status = "partial"
        }</span>

        <span class="cov8" title="1">s.log.Info("documents bulk deleted",
                slog.String("projectId", projectID),
                slog.Int("requested", len(documentIDs)),
                slog.Int("deleted", deleted),
                slog.Int("notFound", len(notFound)))

        response := &amp;DeleteResponse{
                Status:  status,
                Deleted: deleted,
                Summary: summary,
        }

        if len(notFound) &gt; 0 </span><span class="cov8" title="1">{
                response.NotFound = notFound
        }</span>

        <span class="cov8" title="1">return response, nil</span>
}

// CreateFromUpload creates a document record from a file upload
// If a document with the same file hash exists, returns the existing document
func (s *Service) CreateFromUpload(ctx context.Context, params UploadParams) (*UploadDocumentResponse, error) <span class="cov0" title="0">{
        // Apply defaults
        filename := strings.TrimSpace(params.Filename)
        if filename == "" </span><span class="cov0" title="0">{
                filename = "unnamed"
        }</span>

        // Check for existing document with same file hash (deduplication)
        <span class="cov0" title="0">existingDoc, err := s.repo.GetByFileHash(ctx, params.ProjectID, params.FileHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if existingDoc != nil </span><span class="cov0" title="0">{
                s.log.Info("document upload deduplicated",
                        slog.String("projectId", params.ProjectID),
                        slog.String("existingId", existingDoc.ID),
                        slog.String("fileHash", params.FileHash))

                return &amp;UploadDocumentResponse{
                        Document:           toDocumentSummary(existingDoc),
                        IsDuplicate:        true,
                        ExistingDocumentID: &amp;existingDoc.ID,
                }, nil
        }</span>

        // Determine conversion status based on mime type
        <span class="cov0" title="0">conversionStatus := determineConversionStatus(params.MimeType)

        // Create new document
        now := time.Now().UTC()
        doc := &amp;Document{
                ID:               uuid.New().String(),
                ProjectID:        params.ProjectID,
                Filename:         &amp;filename,
                MimeType:         &amp;params.MimeType,
                FileHash:         &amp;params.FileHash,
                FileSizeBytes:    &amp;params.FileSize,
                StorageKey:       &amp;params.StorageKey,
                StorageURL:       &amp;params.StorageURL,
                ConversionStatus: &amp;conversionStatus,
                CreatedAt:        now,
                UpdatedAt:        now,
        }

        // Set source type to "upload"
        sourceType := "upload"
        doc.SourceType = &amp;sourceType

        err = s.repo.Create(ctx, doc)
        if err != nil </span><span class="cov0" title="0">{
                // Handle race condition: another request may have created the same document
                if appErr, ok := err.(*apperror.Error); ok &amp;&amp; appErr.Code == "duplicate" </span><span class="cov0" title="0">{
                        existingDoc, getErr := s.repo.GetByFileHash(ctx, params.ProjectID, params.FileHash)
                        if getErr == nil &amp;&amp; existingDoc != nil </span><span class="cov0" title="0">{
                                return &amp;UploadDocumentResponse{
                                        Document:           toDocumentSummary(existingDoc),
                                        IsDuplicate:        true,
                                        ExistingDocumentID: &amp;existingDoc.ID,
                                }, nil
                        }</span>
                }
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov0" title="0">s.log.Info("document uploaded",
                slog.String("id", doc.ID),
                slog.String("projectId", params.ProjectID),
                slog.String("filename", filename),
                slog.Int64("size", params.FileSize),
                slog.String("mimeType", params.MimeType))

        return &amp;UploadDocumentResponse{
                Document:    toDocumentSummary(doc),
                IsDuplicate: false,
        }, nil</span>
}

// toDocumentSummary converts a Document to a DocumentSummary
func toDocumentSummary(doc *Document) *DocumentSummary <span class="cov8" title="1">{
        name := ""
        if doc.Filename != nil </span><span class="cov8" title="1">{
                name = *doc.Filename
        }</span>

        <span class="cov8" title="1">status := "not_required"
        if doc.ConversionStatus != nil </span><span class="cov8" title="1">{
                status = *doc.ConversionStatus
        }</span>

        <span class="cov8" title="1">return &amp;DocumentSummary{
                ID:               doc.ID,
                Name:             name,
                MimeType:         doc.MimeType,
                FileSizeBytes:    doc.FileSizeBytes,
                ConversionStatus: status,
                ConversionError:  doc.ConversionError,
                StorageKey:       doc.StorageKey,
                CreatedAt:        doc.CreatedAt.Format(time.RFC3339),
        }</span>
}

// determineConversionStatus determines if a file needs conversion based on mime type
func determineConversionStatus(mimeType string) string <span class="cov8" title="1">{
        // Plain text and markdown don't need conversion
        if strings.HasPrefix(mimeType, "text/") </span><span class="cov8" title="1">{
                return "not_required"
        }</span>

        // Common document types that need conversion
        <span class="cov8" title="1">needsConversion := []string{
                "application/pdf",
                "application/msword",
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                "application/vnd.ms-excel",
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                "application/vnd.ms-powerpoint",
                "application/vnd.openxmlformats-officedocument.presentationml.presentation",
        }

        for _, ct := range needsConversion </span><span class="cov8" title="1">{
                if mimeType == ct </span><span class="cov8" title="1">{
                        return "pending"
                }</span>
        }

        // Default to not required for unknown types
        <span class="cov8" title="1">return "not_required"</span>
}

// computeContentHash computes SHA-256 hash of content
func computeContentHash(content string) string <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(content))
        return hex.EncodeToString(hash[:])
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package documents

import (
        "bytes"
        "crypto/sha256"
        "encoding/hex"
        "io"
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/internal/storage"
        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

const (
        // MaxUploadSize is the maximum file size for uploads (100MB)
        MaxUploadSize = 100 * 1024 * 1024
)

// UploadHandler handles document upload HTTP requests
type UploadHandler struct {
        svc     *Service
        storage *storage.Service
}

// NewUploadHandler creates a new upload handler
func NewUploadHandler(svc *Service, storageSvc *storage.Service) *UploadHandler <span class="cov8" title="1">{
        return &amp;UploadHandler{
                svc:     svc,
                storage: storageSvc,
        }
}</span>

// Upload handles POST /api/v2/documents/upload (multipart file upload)
func (h *UploadHandler) Upload(c echo.Context) error <span class="cov0" title="0">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        // Check if storage is enabled
        <span class="cov0" title="0">if !h.storage.Enabled() </span><span class="cov0" title="0">{
                return apperror.New(503, "storage_unavailable", "Storage service is not configured")
        }</span>

        // Get file from multipart form
        <span class="cov0" title="0">file, err := c.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("file is required")
        }</span>

        // Validate file size
        <span class="cov0" title="0">if file.Size &gt; MaxUploadSize </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("file size exceeds maximum of 100MB")
        }</span>

        // Open the file
        <span class="cov0" title="0">src, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("failed to read file")
        }</span>
        <span class="cov0" title="0">defer src.Close()

        // Read file into buffer (needed for hashing and upload)
        buf := new(bytes.Buffer)
        n, err := io.Copy(buf, src)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrInternal.WithInternal(err)
        }</span>
        <span class="cov0" title="0">fileBytes := buf.Bytes()

        // Compute file hash for deduplication
        fileHash := computeFileHash(fileBytes)

        // Detect MIME type
        mimeType := file.Header.Get("Content-Type")
        if mimeType == "" || mimeType == "application/octet-stream" </span><span class="cov0" title="0">{
                // Try to detect from content
                mimeType = http.DetectContentType(fileBytes)
        }</span>

        // Parse optional form fields
        <span class="cov0" title="0">autoExtract := c.FormValue("autoExtract") == "true"

        // Upload to storage
        uploadResult, err := h.storage.UploadDocument(
                c.Request().Context(),
                bytes.NewReader(fileBytes),
                n,
                storage.DocumentUploadOptions{
                        OrgID:     user.OrgID,
                        ProjectID: user.ProjectID,
                        Filename:  file.Filename,
                        UploadOptions: storage.UploadOptions{
                                ContentType: mimeType,
                        },
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrInternal.WithInternal(err)
        }</span>

        // Create document record
        <span class="cov0" title="0">response, err := h.svc.CreateFromUpload(c.Request().Context(), UploadParams{
                ProjectID:   user.ProjectID,
                OrgID:       user.OrgID,
                Filename:    file.Filename,
                MimeType:    mimeType,
                FileSize:    n,
                FileHash:    fileHash,
                StorageKey:  uploadResult.Key,
                StorageURL:  uploadResult.StorageURL,
                AutoExtract: autoExtract,
        })
        if err != nil </span><span class="cov0" title="0">{
                // Try to clean up storage if document creation fails
                _ = h.storage.Delete(c.Request().Context(), uploadResult.Key)
                return err
        }</span>

        // Return 201 for new document, 200 for deduplicated existing document
        <span class="cov0" title="0">status := http.StatusCreated
        if response.IsDuplicate </span><span class="cov0" title="0">{
                status = http.StatusOK
                // Clean up the uploaded file since we're using the existing one
                _ = h.storage.Delete(c.Request().Context(), uploadResult.Key)
        }</span>

        <span class="cov0" title="0">return c.JSON(status, response)</span>
}

// computeFileHash computes SHA-256 hash of file bytes
func computeFileHash(data []byte) string <span class="cov8" title="1">{
        hash := sha256.Sum256(data)
        return hex.EncodeToString(hash[:])
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package email

import (
        "time"

        "github.com/emergent/emergent-core/internal/config"
)

// Config contains email service configuration
type Config struct {
        // Enabled determines if email sending is enabled
        Enabled bool
        // MailgunDomain is the Mailgun domain
        MailgunDomain string
        // MailgunAPIKey is the Mailgun API key
        MailgunAPIKey string
        // FromEmail is the default from email address
        FromEmail string
        // FromName is the default from name
        FromName string
        // MaxRetries is the maximum number of retry attempts (default: 3)
        MaxRetries int
        // RetryDelaySec is the base delay in seconds for retries (default: 60)
        RetryDelaySec int
        // WorkerIntervalMs is the polling interval in milliseconds (default: 5000)
        WorkerIntervalMs int
        // WorkerBatchSize is the number of jobs to process per poll (default: 10)
        WorkerBatchSize int
}

// NewConfig creates email configuration from the app config
func NewConfig(cfg *config.Config) *Config <span class="cov8" title="1">{
        return &amp;Config{
                Enabled:          cfg.Email.Enabled,
                MailgunDomain:    cfg.Email.MailgunDomain,
                MailgunAPIKey:    cfg.Email.MailgunAPIKey,
                FromEmail:        cfg.Email.FromEmail,
                FromName:         cfg.Email.FromName,
                MaxRetries:       cfg.Email.MaxRetries,
                RetryDelaySec:    cfg.Email.RetryDelaySec,
                WorkerIntervalMs: cfg.Email.WorkerIntervalMs,
                WorkerBatchSize:  cfg.Email.WorkerBatchSize,
        }
}</span>

// WorkerInterval returns the worker interval as a Duration
func (c *Config) WorkerInterval() time.Duration <span class="cov8" title="1">{
        return time.Duration(c.WorkerIntervalMs) * time.Millisecond
}</span>

// IsConfigured returns true if Mailgun is configured
func (c *Config) IsConfigured() bool <span class="cov8" title="1">{
        return c.MailgunDomain != "" &amp;&amp; c.MailgunAPIKey != ""
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package email

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "log/slog"
        "math"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/logger"
)

// JobsService manages the email job queue.
// It provides methods to enqueue, dequeue, and manage email jobs.
type JobsService struct {
        db  bun.IDB
        log *slog.Logger
        cfg *Config
}

// NewJobsService creates a new email jobs service
func NewJobsService(db bun.IDB, log *slog.Logger, cfg *Config) *JobsService <span class="cov8" title="1">{
        return &amp;JobsService{
                db:  db,
                log: log.With(logger.Scope("email.jobs")),
                cfg: cfg,
        }
}</span>

// EnqueueOptions contains options for enqueuing an email job
type EnqueueOptions struct {
        TemplateName string
        ToEmail      string
        ToName       *string
        Subject      string
        TemplateData map[string]interface{}
        SourceType   *string
        SourceID     *string
        MaxAttempts  *int
}

// Enqueue creates a new email job ready for immediate processing.
//
// Uses PostgreSQL now() for next_retry_at to ensure clock consistency
// with the dequeue() query.
func (s *JobsService) Enqueue(ctx context.Context, opts EnqueueOptions) (*EmailJob, error) <span class="cov8" title="1">{
        maxAttempts := s.cfg.MaxRetries
        if opts.MaxAttempts != nil </span><span class="cov8" title="1">{
                maxAttempts = *opts.MaxAttempts
        }</span>

        <span class="cov8" title="1">templateData := opts.TemplateData
        if templateData == nil </span><span class="cov8" title="1">{
                templateData = make(map[string]interface{})
        }</span>

        // Serialize template data to JSON
        <span class="cov8" title="1">templateDataJSON, err := json.Marshal(templateData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal template data: %w", err)
        }</span>

        <span class="cov8" title="1">job := &amp;EmailJob{}

        // Use raw SQL for now() to ensure clock consistency
        // Bun's NewRaw uses ? placeholders
        err = s.db.NewRaw(`INSERT INTO kb.email_jobs (
                template_name, to_email, to_name, subject, template_data,
                status, attempts, max_attempts, source_type, source_id, next_retry_at
        ) VALUES (?, ?, ?, ?, ?, 'pending', 0, ?, ?, ?, now())
        RETURNING *`,
                opts.TemplateName,
                opts.ToEmail,
                opts.ToName,
                opts.Subject,
                string(templateDataJSON),
                maxAttempts,
                opts.SourceType,
                opts.SourceID,
        ).Scan(ctx, job)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("enqueue email job: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Debug("enqueued email job",
                slog.String("job_id", job.ID),
                slog.String("to_email", job.ToEmail),
                slog.String("template", job.TemplateName))

        return job, nil</span>
}

// Dequeue atomically claims jobs for processing.
//
// Uses PostgreSQL's FOR UPDATE SKIP LOCKED for concurrent workers.
// This pattern allows multiple workers to safely process jobs without conflicts.
func (s *JobsService) Dequeue(ctx context.Context, batchSize int) ([]*EmailJob, error) <span class="cov8" title="1">{
        if batchSize &lt;= 0 </span><span class="cov0" title="0">{
                batchSize = s.cfg.WorkerBatchSize
        }</span>

        <span class="cov8" title="1">var jobs []*EmailJob

        // Strategic SQL: FOR UPDATE SKIP LOCKED for concurrent workers
        // Bun's NewRaw uses ? placeholders
        err := s.db.NewRaw(`WITH cte AS (
                SELECT id FROM kb.email_jobs
                WHERE status='pending' 
                        AND (next_retry_at IS NULL OR next_retry_at &lt;= now())
                ORDER BY created_at ASC
                FOR UPDATE SKIP LOCKED
                LIMIT ?
        )
        UPDATE kb.email_jobs j 
        SET status='processing', 
                attempts=attempts+1
        FROM cte WHERE j.id = cte.id
        RETURNING j.*`, batchSize).Scan(ctx, &amp;jobs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dequeue email jobs: %w", err)
        }</span>

        <span class="cov8" title="1">return jobs, nil</span>
}

// MarkSent marks a job as sent successfully
func (s *JobsService) MarkSent(ctx context.Context, id string, messageID string) error <span class="cov8" title="1">{
        now := time.Now()
        _, err := s.db.NewUpdate().
                Model((*EmailJob)(nil)).
                Set("status = ?", JobStatusSent).
                Set("mailgun_message_id = ?", messageID).
                Set("processed_at = ?", now).
                Set("last_error = NULL").
                Where("id = ?", id).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mark sent: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Debug("email job marked as sent",
                slog.String("job_id", id),
                slog.String("message_id", messageID))

        return nil</span>
}

// MarkFailed marks a job as failed.
// If attempts &lt; maxAttempts, requeue with exponential backoff.
// Otherwise, mark as permanently failed.
func (s *JobsService) MarkFailed(ctx context.Context, id string, jobErr error) error <span class="cov8" title="1">{
        job := &amp;EmailJob{}
        selectErr := s.db.NewSelect().
                Model(job).
                Column("id", "attempts", "max_attempts").
                Where("id = ?", id).
                Scan(ctx)

        if selectErr != nil </span><span class="cov0" title="0">{
                if selectErr == sql.ErrNoRows </span><span class="cov0" title="0">{
                        s.log.Warn("email job not found when marking as failed", slog.String("job_id", id))
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("get job for mark failed: %w", selectErr)</span>
        }

        <span class="cov8" title="1">errorMessage := truncateError(jobErr.Error())

        if job.Attempts &lt; job.MaxAttempts </span><span class="cov8" title="1">{
                // Calculate exponential backoff: base * attempt^2, capped at 1 hour
                delaySeconds := int(math.Min(
                        3600,
                        float64(s.cfg.RetryDelaySec)*float64(job.Attempts)*float64(job.Attempts),
                ))

                // Requeue for retry using Bun's NewRaw with ? placeholders
                _, updateErr := s.db.NewRaw(`UPDATE kb.email_jobs 
                        SET status='pending', 
                                last_error=?, 
                                next_retry_at=now() + (? || ' seconds')::interval
                        WHERE id=?`,
                        errorMessage, fmt.Sprintf("%d", delaySeconds), id).Exec(ctx)
                if updateErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("requeue failed job: %w", updateErr)
                }</span>

                <span class="cov8" title="1">s.log.Warn("email job failed, retrying",
                        slog.String("job_id", id),
                        slog.Int("attempt", job.Attempts),
                        slog.Int("max_attempts", job.MaxAttempts),
                        slog.Duration("retry_delay", time.Duration(delaySeconds)*time.Second),
                        slog.String("error", errorMessage))</span>
        } else<span class="cov8" title="1"> {
                // Max retries exceeded - move to dead letter queue
                now := time.Now()
                _, updateErr := s.db.NewUpdate().
                        Model((*EmailJob)(nil)).
                        Set("status = ?", JobStatusDeadLetter).
                        Set("last_error = ?", errorMessage).
                        Set("processed_at = ?", now).
                        Where("id = ?", id).
                        Exec(ctx)

                if updateErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("mark as dead letter: %w", updateErr)
                }</span>

                <span class="cov8" title="1">s.log.Error("email job moved to dead letter queue",
                        slog.String("job_id", id),
                        slog.Int("attempts", job.Attempts),
                        slog.String("error", errorMessage))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// RecoverStaleJobs recovers jobs stuck in 'processing' status.
// This can happen when the server restarts while jobs are being processed.
func (s *JobsService) RecoverStaleJobs(ctx context.Context, staleThresholdMinutes int) (int, error) <span class="cov8" title="1">{
        if staleThresholdMinutes &lt;= 0 </span><span class="cov0" title="0">{
                staleThresholdMinutes = 10
        }</span>

        // Use Bun's NewRaw with ? placeholders
        <span class="cov8" title="1">result, err := s.db.NewRaw(`UPDATE kb.email_jobs 
                SET status = 'pending', 
                        next_retry_at = now()
                WHERE status = 'processing' 
                        AND created_at &lt; now() - (? || ' minutes')::interval`,
                fmt.Sprintf("%d", staleThresholdMinutes)).Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("recover stale jobs: %w", err)
        }</span>

        <span class="cov8" title="1">count, _ := result.RowsAffected()

        if count &gt; 0 </span><span class="cov8" title="1">{
                s.log.Warn("recovered stale email jobs",
                        slog.Int64("count", count),
                        slog.Int("threshold_minutes", staleThresholdMinutes))
        }</span>

        <span class="cov8" title="1">return int(count), nil</span>
}

// GetJob retrieves a job by ID
func (s *JobsService) GetJob(ctx context.Context, id string) (*EmailJob, error) <span class="cov8" title="1">{
        job := &amp;EmailJob{}
        err := s.db.NewSelect().
                Model(job).
                Where("id = ?", id).
                Scan(ctx)

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get job: %w", err)
        }</span>

        <span class="cov8" title="1">return job, nil</span>
}

// GetJobsBySource retrieves jobs by source type and ID
func (s *JobsService) GetJobsBySource(ctx context.Context, sourceType, sourceID string) ([]*EmailJob, error) <span class="cov8" title="1">{
        var jobs []*EmailJob
        err := s.db.NewSelect().
                Model(&amp;jobs).
                Where("source_type = ?", sourceType).
                Where("source_id = ?", sourceID).
                Order("created_at DESC").
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get jobs by source: %w", err)
        }</span>

        <span class="cov8" title="1">return jobs, nil</span>
}

// Stats returns queue statistics
func (s *JobsService) Stats(ctx context.Context) (*QueueStats, error) <span class="cov8" title="1">{
        stats := &amp;QueueStats{}

        err := s.db.NewRaw(`SELECT 
                COUNT(*) FILTER (WHERE status = 'pending') as pending,
                COUNT(*) FILTER (WHERE status = 'processing') as processing,
                COUNT(*) FILTER (WHERE status = 'sent') as sent,
                COUNT(*) FILTER (WHERE status = 'failed') as failed
        FROM kb.email_jobs`).Scan(ctx, &amp;stats.Pending, &amp;stats.Processing, &amp;stats.Sent, &amp;stats.Failed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get stats: %w", err)
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// QueueStats contains queue statistics
type QueueStats struct {
        Pending    int64 `json:"pending"`
        Processing int64 `json:"processing"`
        Sent       int64 `json:"sent"`
        Failed     int64 `json:"failed"`
}

// truncateError truncates an error message to 1000 characters
func truncateError(msg string) string <span class="cov8" title="1">{
        if len(msg) &gt; 1000 </span><span class="cov8" title="1">{
                return msg[:1000]
        }</span>
        <span class="cov8" title="1">return msg</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package email

import (
        "context"
        "fmt"
        "log/slog"
        "time"

        "github.com/mailgun/mailgun-go/v4"

        "github.com/emergent/emergent-core/pkg/logger"
)

// MailgunSender sends emails via Mailgun API.
// This is a thin wrapper around the Mailgun SDK.
type MailgunSender struct {
        cfg    *Config
        log    *slog.Logger
        client *mailgun.MailgunImpl
}

// NewMailgunSender creates a new Mailgun email sender.
// Returns nil if Mailgun is not configured.
func NewMailgunSender(cfg *Config, log *slog.Logger) *MailgunSender <span class="cov8" title="1">{
        if !cfg.IsConfigured() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">client := mailgun.NewMailgun(cfg.MailgunDomain, cfg.MailgunAPIKey)

        return &amp;MailgunSender{
                cfg:    cfg,
                log:    log.With(logger.Scope("email.mailgun")),
                client: client,
        }</span>
}

// Send sends an email via Mailgun.
func (s *MailgunSender) Send(ctx context.Context, opts SendOptions) (*SendResult, error) <span class="cov0" title="0">{
        if !s.cfg.Enabled </span><span class="cov0" title="0">{
                s.log.Warn("email sending is disabled (EMAIL_ENABLED=false)")
                return &amp;SendResult{
                        Success: false,
                        Error:   "Email sending is disabled",
                }, nil
        }</span>

        <span class="cov0" title="0">if err := s.validate(); err != nil </span><span class="cov0" title="0">{
                s.log.Error("email configuration invalid", slog.String("error", err.Error()))
                return &amp;SendResult{
                        Success: false,
                        Error:   err.Error(),
                }, nil
        }</span>

        // Format recipient with name if provided
        <span class="cov0" title="0">to := opts.To
        if opts.ToName != "" </span><span class="cov0" title="0">{
                to = fmt.Sprintf("%s &lt;%s&gt;", opts.ToName, opts.To)
        }</span>

        // Format sender with name
        <span class="cov0" title="0">from := fmt.Sprintf("%s &lt;%s&gt;", s.cfg.FromName, s.cfg.FromEmail)

        // Create message
        message := s.client.NewMessage(from, opts.Subject, opts.Text, to)
        if opts.HTML != "" </span><span class="cov0" title="0">{
                message.SetHtml(opts.HTML)
        }</span>

        <span class="cov0" title="0">s.log.Debug("sending email",
                slog.String("to", opts.To),
                slog.String("subject", opts.Subject))

        // Send with timeout
        sendCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
        defer cancel()

        _, messageID, err := s.client.Send(sendCtx, message)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to send email",
                        slog.String("to", opts.To),
                        slog.String("error", err.Error()))
                return &amp;SendResult{
                        Success: false,
                        Error:   err.Error(),
                }, nil
        }</span>

        <span class="cov0" title="0">s.log.Info("email sent successfully",
                slog.String("to", opts.To),
                slog.String("message_id", messageID))

        return &amp;SendResult{
                Success:   true,
                MessageID: messageID,
        }, nil</span>
}

// validate checks that the configuration is valid
func (s *MailgunSender) validate() error <span class="cov8" title="1">{
        if s.cfg.MailgunDomain == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("MAILGUN_DOMAIN is required")
        }</span>
        <span class="cov8" title="1">if s.cfg.MailgunAPIKey == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("MAILGUN_API_KEY is required")
        }</span>
        <span class="cov8" title="1">if s.cfg.FromEmail == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("EMAIL_FROM_ADDRESS is required")
        }</span>
        <span class="cov8" title="1">if s.cfg.FromName == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("EMAIL_FROM_NAME is required")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetEventsForMessage retrieves events for a specific message from Mailgun Logs API.
// Used to track delivery status (delivered, opened, bounced, etc.)
func (s *MailgunSender) GetEventsForMessage(ctx context.Context, messageID string, sentAt *time.Time) ([]MailgunEvent, error) <span class="cov0" title="0">{
        if !s.cfg.Enabled </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("email service is disabled")
        }</span>

        // Calculate time range
        <span class="cov0" title="0">now := time.Now()
        lookbackDays := 7
        msPerDay := 24 * time.Hour

        var start, end time.Time
        if sentAt != nil </span><span class="cov0" title="0">{
                start = *sentAt
                endFromSent := sentAt.Add(time.Duration(lookbackDays) * msPerDay)
                if endFromSent.Before(now) </span><span class="cov0" title="0">{
                        end = endFromSent
                }</span> else<span class="cov0" title="0"> {
                        end = now
                }</span>
        } else<span class="cov0" title="0"> {
                start = now.Add(-time.Duration(lookbackDays) * msPerDay)
                end = now
        }</span>

        // Create event iterator
        <span class="cov0" title="0">it := s.client.ListEvents(&amp;mailgun.ListEventOptions{
                Begin: start,
                End:   end,
                Filter: map[string]string{
                        "message-id": messageID,
                },
        })

        var events []MailgunEvent
        var page []mailgun.Event

        // Iterate through pages
        for it.Next(ctx, &amp;page) </span><span class="cov0" title="0">{
                for _, e := range page </span><span class="cov0" title="0">{
                        events = append(events, MailgunEvent{
                                ID:        e.GetID(),
                                Event:     e.GetName(),
                                Timestamp: e.GetTimestamp().Unix(),
                        })
                }</span>
        }

        <span class="cov0" title="0">if err := it.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get events: %w", err)
        }</span>

        <span class="cov0" title="0">return events, nil</span>
}

// MailgunEvent represents an event from Mailgun's logs
type MailgunEvent struct {
        ID        string `json:"id"`
        Event     string `json:"event"`
        Timestamp int64  `json:"timestamp"`
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package email

import (
        "context"
        "log/slog"
        "os"
        "path/filepath"

        "github.com/uptrace/bun"
        "go.uber.org/fx"

        "github.com/emergent/emergent-core/internal/config"
)

// Module provides email functionality including job queue and worker
var Module = fx.Module("email",
        fx.Provide(
                NewConfig,
                NewJobsService,
                NewTemplateServiceFromConfig,
                NewSender, // Uses Mailgun when configured, otherwise no-op
                NewWorker,
        ),
        fx.Invoke(RegisterWorkerLifecycle),
)

// NewTemplateServiceFromConfig creates a template service with the default template directory
func NewTemplateServiceFromConfig(log *slog.Logger) *TemplateService <span class="cov0" title="0">{
        // Default template directory relative to the server binary
        // In production, templates are typically at ./templates/email
        // In development, they might be at apps/server/templates/email
        templateDir := os.Getenv("EMAIL_TEMPLATE_DIR")
        if templateDir == "" </span><span class="cov0" title="0">{
                // Try common paths
                candidates := []string{
                        "templates/email",
                        "../server/templates/email",
                        "../../apps/server/templates/email",
                }
                for _, candidate := range candidates </span><span class="cov0" title="0">{
                        if _, err := os.Stat(candidate); err == nil </span><span class="cov0" title="0">{
                                templateDir = candidate
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if templateDir == "" </span><span class="cov0" title="0">{
                templateDir = "templates/email"
        }</span>

        <span class="cov0" title="0">absPath, _ := filepath.Abs(templateDir)
        log.Info("initializing email template service", slog.String("template_dir", absPath))

        return NewTemplateService(templateDir, log)</span>
}

// NewSender creates the appropriate email sender based on configuration.
// Uses Mailgun when configured, otherwise falls back to no-op sender.
func NewSender(log *slog.Logger, cfg *Config) Sender <span class="cov8" title="1">{
        if cfg.IsConfigured() &amp;&amp; cfg.Enabled </span><span class="cov8" title="1">{
                mailgunSender := NewMailgunSender(cfg, log)
                if mailgunSender != nil </span><span class="cov8" title="1">{
                        log.Info("using Mailgun sender",
                                slog.String("domain", cfg.MailgunDomain),
                                slog.String("from", cfg.FromEmail))
                        return mailgunSender
                }</span>
        }

        <span class="cov8" title="1">log.Info("using no-op email sender (Mailgun not configured or email disabled)")
        return &amp;noOpSender{log: log}</span>
}

// noOpSender is a no-op email sender for development/testing
type noOpSender struct {
        log *slog.Logger
}

func (s *noOpSender) Send(ctx context.Context, opts SendOptions) (*SendResult, error) <span class="cov8" title="1">{
        s.log.Info("email send (no-op)",
                slog.String("to", opts.To),
                slog.String("subject", opts.Subject))
        
        return &amp;SendResult{
                Success:   true,
                MessageID: "noop-" + opts.To,
        }, nil
}</span>

// RegisterWorkerLifecycle registers the email worker with fx lifecycle
func RegisterWorkerLifecycle(lc fx.Lifecycle, worker *Worker, cfg *Config) <span class="cov0" title="0">{
        if !cfg.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">lc.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        return worker.Start(ctx)
                }</span>,
                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                        return worker.Stop(ctx)
                }</span>,
        })
}

// Params for NewJobsService constructor
type JobsServiceParams struct {
        fx.In
        DB  *bun.DB
        Log *slog.Logger
        Cfg *config.Config
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package email

import (
        "embed"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"
        "strings"
        "sync"

        "github.com/aymerick/raymond"
        "github.com/emergent/emergent-core/pkg/logger"
)

// TemplateService handles email template rendering using Handlebars.
//
// Templates are loaded from the templates/email directory with the structure:
// - layouts/*.hbs - Base layouts that wrap content
// - partials/*.hbs - Reusable template parts (buttons, footers, etc.)
// - *.hbs - Main email templates
//
// For MJML templates, this service expects pre-compiled HTML versions.
// In production, MJML templates should be pre-compiled during the build process.
type TemplateService struct {
        templateDir   string
        log           *slog.Logger
        isDevelopment bool

        // Caches
        templateCache map[string]*raymond.Template
        layoutCache   map[string]*raymond.Template
        mu            sync.RWMutex
}

// TemplateRenderResult contains the rendered email content
type TemplateRenderResult struct {
        HTML string
        Text string
}

// TemplateContext is the data passed to templates
type TemplateContext map[string]interface{}

// NewTemplateService creates a new template service
func NewTemplateService(templateDir string, log *slog.Logger) *TemplateService <span class="cov0" title="0">{
        isDev := os.Getenv("NODE_ENV") != "production" &amp;&amp; os.Getenv("GO_ENV") != "production"
        
        ts := &amp;TemplateService{
                templateDir:   templateDir,
                log:           log.With(logger.Scope("email.template")),
                isDevelopment: isDev,
                templateCache: make(map[string]*raymond.Template),
                layoutCache:   make(map[string]*raymond.Template),
        }

        // Register partials
        ts.registerPartials()

        // Preload templates in production
        if !isDev </span><span class="cov0" title="0">{
                ts.preloadTemplates()
        }</span>

        <span class="cov0" title="0">return ts</span>
}

// registerPartials loads and registers all partials from the partials directory
func (ts *TemplateService) registerPartials() <span class="cov0" title="0">{
        partialsDir := filepath.Join(ts.templateDir, "partials")

        if _, err := os.Stat(partialsDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                ts.log.Debug("partials directory not found", slog.String("path", partialsDir))
                return
        }</span>

        <span class="cov0" title="0">entries, err := os.ReadDir(partialsDir)
        if err != nil </span><span class="cov0" title="0">{
                ts.log.Warn("failed to read partials directory", slog.String("error", err.Error()))
                return
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">name := entry.Name()
                // Support both .hbs and .mjml.hbs extensions
                if strings.HasSuffix(name, ".hbs") </span><span class="cov0" title="0">{
                        partialName := strings.TrimSuffix(strings.TrimSuffix(name, ".hbs"), ".mjml")
                        content, err := os.ReadFile(filepath.Join(partialsDir, name))
                        if err != nil </span><span class="cov0" title="0">{
                                ts.log.Warn("failed to read partial", slog.String("name", name), slog.String("error", err.Error()))
                                continue</span>
                        }
                        <span class="cov0" title="0">raymond.RegisterPartial(partialName, string(content))
                        ts.log.Debug("registered partial", slog.String("name", partialName))</span>
                }
        }
}

// preloadTemplates loads all templates into cache (production optimization)
func (ts *TemplateService) preloadTemplates() <span class="cov0" title="0">{
        if _, err := os.Stat(ts.templateDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                ts.log.Warn("template directory not found", slog.String("path", ts.templateDir))
                return
        }</span>

        // Load layouts
        <span class="cov0" title="0">layoutsDir := filepath.Join(ts.templateDir, "layouts")
        if entries, err := os.ReadDir(layoutsDir); err == nil </span><span class="cov0" title="0">{
                for _, entry := range entries </span><span class="cov0" title="0">{
                        if !entry.IsDir() &amp;&amp; strings.HasSuffix(entry.Name(), ".hbs") </span><span class="cov0" title="0">{
                                name := strings.TrimSuffix(strings.TrimSuffix(entry.Name(), ".hbs"), ".mjml")
                                ts.loadLayout(name)
                        }</span>
                }
        }

        // Load main templates
        <span class="cov0" title="0">entries, err := os.ReadDir(ts.templateDir)
        if err != nil </span><span class="cov0" title="0">{
                ts.log.Warn("failed to read template directory", slog.String("error", err.Error()))
                return
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if strings.HasSuffix(entry.Name(), ".hbs") </span><span class="cov0" title="0">{
                        name := strings.TrimSuffix(strings.TrimSuffix(entry.Name(), ".hbs"), ".mjml")
                        ts.loadTemplate(name)
                }</span>
        }

        <span class="cov0" title="0">ts.log.Info("preloaded email templates",
                slog.Int("templates", len(ts.templateCache)),
                slog.Int("layouts", len(ts.layoutCache)))</span>
}

// loadTemplate loads a template from disk and caches it
func (ts *TemplateService) loadTemplate(name string) (*raymond.Template, error) <span class="cov0" title="0">{
        ts.mu.Lock()
        defer ts.mu.Unlock()

        // Check cache first (in production)
        if !ts.isDevelopment </span><span class="cov0" title="0">{
                if tmpl, ok := ts.templateCache[name]; ok </span><span class="cov0" title="0">{
                        return tmpl, nil
                }</span>
        }

        // Try different file extensions
        <span class="cov0" title="0">var content []byte
        var err error
        
        // Try .html.hbs first (pre-compiled MJML)
        filePath := filepath.Join(ts.templateDir, name+".html.hbs")
        if _, statErr := os.Stat(filePath); statErr == nil </span><span class="cov0" title="0">{
                content, err = os.ReadFile(filePath)
        }</span> else<span class="cov0" title="0"> {
                // Try .mjml.hbs (raw MJML - will need compilation)
                filePath = filepath.Join(ts.templateDir, name+".mjml.hbs")
                if _, statErr := os.Stat(filePath); statErr == nil </span><span class="cov0" title="0">{
                        content, err = os.ReadFile(filePath)
                }</span> else<span class="cov0" title="0"> {
                        // Try .hbs
                        filePath = filepath.Join(ts.templateDir, name+".hbs")
                        content, err = os.ReadFile(filePath)
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("template not found: %s", name)
        }</span>

        <span class="cov0" title="0">tmpl, err := raymond.Parse(string(content))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse template %s: %w", name, err)
        }</span>

        // Cache in production
        <span class="cov0" title="0">if !ts.isDevelopment </span><span class="cov0" title="0">{
                ts.templateCache[name] = tmpl
        }</span>

        <span class="cov0" title="0">return tmpl, nil</span>
}

// loadLayout loads a layout template
func (ts *TemplateService) loadLayout(name string) (*raymond.Template, error) <span class="cov0" title="0">{
        ts.mu.Lock()
        defer ts.mu.Unlock()

        // Check cache first (in production)
        if !ts.isDevelopment </span><span class="cov0" title="0">{
                if tmpl, ok := ts.layoutCache[name]; ok </span><span class="cov0" title="0">{
                        return tmpl, nil
                }</span>
        }

        // Try different file extensions
        <span class="cov0" title="0">var content []byte
        var err error

        layoutsDir := filepath.Join(ts.templateDir, "layouts")
        
        // Try .html.hbs first
        filePath := filepath.Join(layoutsDir, name+".html.hbs")
        if _, statErr := os.Stat(filePath); statErr == nil </span><span class="cov0" title="0">{
                content, err = os.ReadFile(filePath)
        }</span> else<span class="cov0" title="0"> {
                // Try .mjml.hbs
                filePath = filepath.Join(layoutsDir, name+".mjml.hbs")
                if _, statErr := os.Stat(filePath); statErr == nil </span><span class="cov0" title="0">{
                        content, err = os.ReadFile(filePath)
                }</span> else<span class="cov0" title="0"> {
                        // Try .hbs
                        filePath = filepath.Join(layoutsDir, name+".hbs")
                        content, err = os.ReadFile(filePath)
                }</span>
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("layout not found: %s", name)
        }</span>

        <span class="cov0" title="0">tmpl, err := raymond.Parse(string(content))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse layout %s: %w", name, err)
        }</span>

        // Cache in production
        <span class="cov0" title="0">if !ts.isDevelopment </span><span class="cov0" title="0">{
                ts.layoutCache[name] = tmpl
        }</span>

        <span class="cov0" title="0">return tmpl, nil</span>
}

// Render renders an email template with the given context
func (ts *TemplateService) Render(templateName string, context TemplateContext, layoutName string) (*TemplateRenderResult, error) <span class="cov0" title="0">{
        // Reload partials in development
        if ts.isDevelopment </span><span class="cov0" title="0">{
                ts.registerPartials()
        }</span>

        // Load and render the main template
        <span class="cov0" title="0">tmpl, err := ts.loadTemplate(templateName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">content, err := tmpl.Exec(context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to render template %s: %w", templateName, err)
        }</span>

        // Apply layout if specified
        <span class="cov0" title="0">if layoutName != "" </span><span class="cov0" title="0">{
                layout, err := ts.loadLayout(layoutName)
                if err != nil </span><span class="cov0" title="0">{
                        ts.log.Debug("layout not found, using template directly",
                                slog.String("layout", layoutName))
                }</span> else<span class="cov0" title="0"> {
                        // Create context with content for layout
                        layoutCtx := make(TemplateContext)
                        for k, v := range context </span><span class="cov0" title="0">{
                                layoutCtx[k] = v
                        }</span>
                        <span class="cov0" title="0">layoutCtx["content"] = raymond.SafeString(content)

                        content, err = layout.Exec(layoutCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to render layout %s: %w", layoutName, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;TemplateRenderResult{
                HTML: content,
                Text: ts.generatePlainText(context),
        }, nil</span>
}

// RenderFromContent renders a template from raw content string
func (ts *TemplateService) RenderFromContent(content string, context TemplateContext, layoutName string) (*TemplateRenderResult, error) <span class="cov0" title="0">{
        tmpl, err := raymond.Parse(content)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse content: %w", err)
        }</span>

        <span class="cov0" title="0">rendered, err := tmpl.Exec(context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to render content: %w", err)
        }</span>

        // Apply layout if specified
        <span class="cov0" title="0">if layoutName != "" </span><span class="cov0" title="0">{
                layout, err := ts.loadLayout(layoutName)
                if err != nil </span><span class="cov0" title="0">{
                        ts.log.Debug("layout not found, using content directly",
                                slog.String("layout", layoutName))
                }</span> else<span class="cov0" title="0"> {
                        layoutCtx := make(TemplateContext)
                        for k, v := range context </span><span class="cov0" title="0">{
                                layoutCtx[k] = v
                        }</span>
                        <span class="cov0" title="0">layoutCtx["content"] = raymond.SafeString(rendered)

                        rendered, err = layout.Exec(layoutCtx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to render layout %s: %w", layoutName, err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;TemplateRenderResult{
                HTML: rendered,
                Text: ts.generatePlainText(context),
        }, nil</span>
}

// generatePlainText creates a plain text version from context
func (ts *TemplateService) generatePlainText(context TemplateContext) string <span class="cov8" title="1">{
        // If context has a plainText field, use it
        if plainText, ok := context["plainText"].(string); ok &amp;&amp; plainText != "" </span><span class="cov8" title="1">{
                return plainText
        }</span>

        // Simple text generation from common fields
        <span class="cov8" title="1">var parts []string

        if title, ok := context["title"].(string); ok &amp;&amp; title != "" </span><span class="cov8" title="1">{
                parts = append(parts, title, "")
        }</span>

        <span class="cov8" title="1">if previewText, ok := context["previewText"].(string); ok &amp;&amp; previewText != "" </span><span class="cov8" title="1">{
                parts = append(parts, previewText, "")
        }</span>

        <span class="cov8" title="1">if message, ok := context["message"].(string); ok &amp;&amp; message != "" </span><span class="cov8" title="1">{
                parts = append(parts, message, "")
        }</span>

        <span class="cov8" title="1">if ctaUrl, ok := context["ctaUrl"].(string); ok &amp;&amp; ctaUrl != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("Link: %s", ctaUrl), "")
        }</span>

        <span class="cov8" title="1">if dashboardUrl, ok := context["dashboardUrl"].(string); ok &amp;&amp; dashboardUrl != "" </span><span class="cov8" title="1">{
                parts = append(parts, fmt.Sprintf("Dashboard: %s", dashboardUrl), "")
        }</span>

        <span class="cov8" title="1">if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                return strings.Join(parts, "\n")
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// HasTemplate checks if a template exists
func (ts *TemplateService) HasTemplate(name string) bool <span class="cov0" title="0">{
        // Try different extensions
        extensions := []string{".html.hbs", ".mjml.hbs", ".hbs"}
        for _, ext := range extensions </span><span class="cov0" title="0">{
                filePath := filepath.Join(ts.templateDir, name+ext)
                if _, err := os.Stat(filePath); err == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// ListTemplates returns all available template names
func (ts *TemplateService) ListTemplates() []string <span class="cov0" title="0">{
        if _, err := os.Stat(ts.templateDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">entries, err := os.ReadDir(ts.templateDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var templates []string
        for _, entry := range entries </span><span class="cov0" title="0">{
                if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">name := entry.Name()
                if strings.HasSuffix(name, ".hbs") </span><span class="cov0" title="0">{
                        // Remove all extensions
                        templateName := strings.TrimSuffix(strings.TrimSuffix(strings.TrimSuffix(name, ".hbs"), ".mjml"), ".html")
                        templates = append(templates, templateName)
                }</span>
        }

        <span class="cov0" title="0">return templates</span>
}

// ClearCache clears the template cache (useful for development)
func (ts *TemplateService) ClearCache() <span class="cov8" title="1">{
        ts.mu.Lock()
        defer ts.mu.Unlock()
        ts.templateCache = make(map[string]*raymond.Template)
        ts.layoutCache = make(map[string]*raymond.Template)
}</span>

// EmbeddedTemplateService is a variant that uses embedded templates
// This is useful for including templates in the binary
type EmbeddedTemplateService struct {
        *TemplateService
        fs embed.FS
}

// NewEmbeddedTemplateService creates a template service from embedded files
func NewEmbeddedTemplateService(fs embed.FS, basePath string, log *slog.Logger) *EmbeddedTemplateService <span class="cov0" title="0">{
        // For embedded templates, we always preload
        ets := &amp;EmbeddedTemplateService{
                TemplateService: &amp;TemplateService{
                        templateDir:   basePath,
                        log:           log.With(logger.Scope("email.template")),
                        isDevelopment: false,
                        templateCache: make(map[string]*raymond.Template),
                        layoutCache:   make(map[string]*raymond.Template),
                },
                fs: fs,
        }

        // Load embedded templates
        ets.loadEmbeddedTemplates()

        return ets
}</span>

// loadEmbeddedTemplates loads templates from the embedded filesystem
func (ets *EmbeddedTemplateService) loadEmbeddedTemplates() <span class="cov0" title="0">{
        // Register partials
        partialsDir := filepath.Join(ets.templateDir, "partials")
        if entries, err := ets.fs.ReadDir(partialsDir); err == nil </span><span class="cov0" title="0">{
                for _, entry := range entries </span><span class="cov0" title="0">{
                        if !entry.IsDir() &amp;&amp; strings.HasSuffix(entry.Name(), ".hbs") </span><span class="cov0" title="0">{
                                name := strings.TrimSuffix(strings.TrimSuffix(entry.Name(), ".hbs"), ".mjml")
                                if content, err := ets.fs.ReadFile(filepath.Join(partialsDir, entry.Name())); err == nil </span><span class="cov0" title="0">{
                                        raymond.RegisterPartial(name, string(content))
                                }</span>
                        }
                }
        }

        // Load layouts
        <span class="cov0" title="0">layoutsDir := filepath.Join(ets.templateDir, "layouts")
        if entries, err := ets.fs.ReadDir(layoutsDir); err == nil </span><span class="cov0" title="0">{
                for _, entry := range entries </span><span class="cov0" title="0">{
                        if !entry.IsDir() &amp;&amp; strings.HasSuffix(entry.Name(), ".hbs") </span><span class="cov0" title="0">{
                                name := strings.TrimSuffix(strings.TrimSuffix(entry.Name(), ".hbs"), ".mjml")
                                if content, err := ets.fs.ReadFile(filepath.Join(layoutsDir, entry.Name())); err == nil </span><span class="cov0" title="0">{
                                        if tmpl, err := raymond.Parse(string(content)); err == nil </span><span class="cov0" title="0">{
                                                ets.layoutCache[name] = tmpl
                                        }</span>
                                }
                        }
                }
        }

        // Load main templates
        <span class="cov0" title="0">if entries, err := ets.fs.ReadDir(ets.templateDir); err == nil </span><span class="cov0" title="0">{
                for _, entry := range entries </span><span class="cov0" title="0">{
                        if entry.IsDir() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">if strings.HasSuffix(entry.Name(), ".hbs") </span><span class="cov0" title="0">{
                                name := strings.TrimSuffix(strings.TrimSuffix(entry.Name(), ".hbs"), ".mjml")
                                if content, err := ets.fs.ReadFile(filepath.Join(ets.templateDir, entry.Name())); err == nil </span><span class="cov0" title="0">{
                                        if tmpl, err := raymond.Parse(string(content)); err == nil </span><span class="cov0" title="0">{
                                                ets.templateCache[name] = tmpl
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">ets.log.Info("loaded embedded email templates",
                slog.Int("templates", len(ets.templateCache)),
                slog.Int("layouts", len(ets.layoutCache)))</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package email

import (
        "context"
        "log/slog"
        "sync"
        "time"

        "github.com/emergent/emergent-core/pkg/logger"
)

// Worker processes email jobs from the queue.
// It follows the same pattern as NestJS workers:
// - Polling-based with configurable interval
// - Graceful shutdown waiting for current batch
// - Stale job recovery on startup
// - Metrics tracking
type Worker struct {
        jobs      *JobsService
        sender    Sender
        templates *TemplateService
        cfg       *Config
        log       *slog.Logger
        stopCh    chan struct{}
        stoppedCh chan struct{}
        running   bool
        mu        sync.Mutex
        wg        sync.WaitGroup

        // Metrics
        processedCount int64
        successCount   int64
        failureCount   int64
        metricsMu      sync.RWMutex
}

// Sender is the interface for sending emails
type Sender interface {
        Send(ctx context.Context, opts SendOptions) (*SendResult, error)
}

// SendOptions contains options for sending an email
type SendOptions struct {
        To      string
        ToName  string
        Subject string
        HTML    string
        Text    string
}

// SendResult contains the result of sending an email
type SendResult struct {
        Success   bool
        MessageID string
        Error     string
}

// NewWorker creates a new email worker
func NewWorker(jobs *JobsService, sender Sender, templates *TemplateService, cfg *Config, log *slog.Logger) *Worker <span class="cov0" title="0">{
        return &amp;Worker{
                jobs:      jobs,
                sender:    sender,
                templates: templates,
                cfg:       cfg,
                log:       log.With(logger.Scope("email.worker")),
        }
}</span>

// Start begins the worker's polling loop
func (w *Worker) Start(ctx context.Context) error <span class="cov0" title="0">{
        w.mu.Lock()
        if w.running </span><span class="cov0" title="0">{
                w.mu.Unlock()
                return nil
        }</span>

        // Check if email is enabled
        <span class="cov0" title="0">if !w.cfg.Enabled </span><span class="cov0" title="0">{
                w.log.Info("email worker not started (EMAIL_ENABLED=false)")
                w.mu.Unlock()
                return nil
        }</span>

        <span class="cov0" title="0">w.running = true
        w.stopCh = make(chan struct{})
        w.stoppedCh = make(chan struct{})
        w.mu.Unlock()

        // Recover stale jobs on startup
        go w.recoverStaleJobsOnStartup(ctx)

        w.log.Info("email worker starting",
                slog.Duration("poll_interval", w.cfg.WorkerInterval()),
                slog.Int("batch_size", w.cfg.WorkerBatchSize))

        w.wg.Add(1)
        go w.run(ctx)

        return nil</span>
}

// Stop gracefully stops the worker, waiting for current batch to complete
func (w *Worker) Stop(ctx context.Context) error <span class="cov0" title="0">{
        w.mu.Lock()
        if !w.running </span><span class="cov0" title="0">{
                w.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">w.running = false
        close(w.stopCh)
        w.mu.Unlock()

        w.log.Debug("waiting for email worker to stop...")

        // Wait for worker to stop or context to be cancelled
        select </span>{
        case &lt;-w.stoppedCh:<span class="cov0" title="0">
                w.log.Info("email worker stopped gracefully")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                w.log.Warn("email worker stop timeout, forcing shutdown")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// recoverStaleJobsOnStartup recovers stale jobs on startup
func (w *Worker) recoverStaleJobsOnStartup(ctx context.Context) <span class="cov0" title="0">{
        recovered, err := w.jobs.RecoverStaleJobs(ctx, 10)
        if err != nil </span><span class="cov0" title="0">{
                w.log.Warn("failed to recover stale jobs on startup",
                        slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov0" title="0">if recovered &gt; 0 </span><span class="cov0" title="0">{
                w.log.Info("recovered stale email jobs on startup",
                        slog.Int("count", recovered))
        }</span>
}

// run is the main worker loop
func (w *Worker) run(ctx context.Context) <span class="cov0" title="0">{
        defer w.wg.Done()
        defer close(w.stoppedCh)

        ticker := time.NewTicker(w.cfg.WorkerInterval())
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := w.processBatch(ctx); err != nil </span><span class="cov0" title="0">{
                                w.log.Warn("process batch failed", slog.String("error", err.Error()))
                        }</span>
                }
        }
}

// processBatch processes a batch of email jobs
func (w *Worker) processBatch(ctx context.Context) error <span class="cov0" title="0">{
        // Check if we should stop
        select </span>{
        case &lt;-w.stopCh:<span class="cov0" title="0">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">jobs, err := w.jobs.Dequeue(ctx, w.cfg.WorkerBatchSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if len(jobs) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for _, job := range jobs </span><span class="cov0" title="0">{
                if err := w.processJob(ctx, job); err != nil </span><span class="cov0" title="0">{
                        w.log.Warn("process job failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", err.Error()))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// processJob processes a single email job
func (w *Worker) processJob(ctx context.Context, job *EmailJob) error <span class="cov0" title="0">{
        startTime := time.Now()

        // Render the template
        templateContext := make(TemplateContext)
        if job.TemplateData != nil </span><span class="cov0" title="0">{
                for k, v := range job.TemplateData </span><span class="cov0" title="0">{
                        templateContext[k] = v
                }</span>
        }
        
        // Add common fields if not present
        <span class="cov0" title="0">if _, ok := templateContext["title"]; !ok </span><span class="cov0" title="0">{
                templateContext["title"] = job.Subject
        }</span>
        <span class="cov0" title="0">if _, ok := templateContext["previewText"]; !ok </span><span class="cov0" title="0">{
                templateContext["previewText"] = job.Subject
        }</span>
        <span class="cov0" title="0">if job.ToName != nil </span><span class="cov0" title="0">{
                templateContext["recipientName"] = *job.ToName
        }</span>

        <span class="cov0" title="0">var htmlContent, textContent string

        // Check if template exists
        if w.templates.HasTemplate(job.TemplateName) </span><span class="cov0" title="0">{
                result, err := w.templates.Render(job.TemplateName, templateContext, "default")
                if err != nil </span><span class="cov0" title="0">{
                        w.log.Warn("template render failed, using fallback",
                                slog.String("template", job.TemplateName),
                                slog.String("error", err.Error()))
                        htmlContent = w.generateFallbackHTML(job, templateContext)
                        textContent = w.generateFallbackText(job, templateContext)
                }</span> else<span class="cov0" title="0"> {
                        htmlContent = result.HTML
                        textContent = result.Text
                }</span>
        } else<span class="cov0" title="0"> {
                // No template found, use fallback
                w.log.Debug("template not found, using fallback",
                        slog.String("template", job.TemplateName))
                htmlContent = w.generateFallbackHTML(job, templateContext)
                textContent = w.generateFallbackText(job, templateContext)
        }</span>

        // Send the email
        <span class="cov0" title="0">toName := ""
        if job.ToName != nil </span><span class="cov0" title="0">{
                toName = *job.ToName
        }</span>

        <span class="cov0" title="0">result, err := w.sender.Send(ctx, SendOptions{
                To:      job.ToEmail,
                ToName:  toName,
                Subject: job.Subject,
                HTML:    htmlContent,
                Text:    textContent,
        })

        if err != nil </span><span class="cov0" title="0">{
                // Sender error
                if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov0" title="0">w.incrementFailure()
                return err</span>
        }

        <span class="cov0" title="0">if !result.Success </span><span class="cov0" title="0">{
                // Mailgun returned an error
                sendErr := &amp;sendError{message: result.Error}
                if markErr := w.jobs.MarkFailed(ctx, job.ID, sendErr); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov0" title="0">w.incrementFailure()
                return sendErr</span>
        }

        // Mark as sent
        <span class="cov0" title="0">if err := w.jobs.MarkSent(ctx, job.ID, result.MessageID); err != nil </span><span class="cov0" title="0">{
                w.log.Error("failed to mark job as sent",
                        slog.String("job_id", job.ID),
                        slog.String("error", err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">durationMs := time.Since(startTime).Milliseconds()
        w.log.Debug("email sent",
                slog.String("job_id", job.ID),
                slog.String("to_email", job.ToEmail),
                slog.String("template", job.TemplateName),
                slog.String("message_id", result.MessageID),
                slog.Int64("duration_ms", durationMs))

        w.incrementSuccess()
        return nil</span>
}

// generateFallbackHTML creates a simple HTML email when template is not available
func (w *Worker) generateFallbackHTML(job *EmailJob, ctx TemplateContext) string <span class="cov8" title="1">{
        recipientName := ""
        if name, ok := ctx["recipientName"].(string); ok </span><span class="cov8" title="1">{
                recipientName = name
        }</span>
        
        <span class="cov8" title="1">greeting := "Hello"
        if recipientName != "" </span><span class="cov8" title="1">{
                greeting = "Hello " + recipientName
        }</span>

        <span class="cov8" title="1">message := ""
        if msg, ok := ctx["message"].(string); ok </span><span class="cov8" title="1">{
                message = msg
        }</span>

        <span class="cov8" title="1">ctaUrl := ""
        ctaText := ""
        if url, ok := ctx["ctaUrl"].(string); ok </span><span class="cov8" title="1">{
                ctaUrl = url
        }</span>
        <span class="cov8" title="1">if text, ok := ctx["ctaText"].(string); ok </span><span class="cov8" title="1">{
                ctaText = text
        }</span>
        <span class="cov8" title="1">if ctaText == "" </span><span class="cov8" title="1">{
                ctaText = "Click Here"
        }</span>

        <span class="cov8" title="1">html := `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
  &lt;title&gt;` + job.Subject + `&lt;/title&gt;
&lt;/head&gt;
&lt;body style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; line-height: 1.6; color: #374151; margin: 0; padding: 20px; background-color: #f3f4f6;"&gt;
  &lt;div style="max-width: 600px; margin: 0 auto; background-color: #ffffff; border-radius: 8px; padding: 32px;"&gt;
    &lt;p style="font-size: 16px; margin-bottom: 16px;"&gt;` + greeting + `,&lt;/p&gt;
    &lt;p style="margin-bottom: 16px;"&gt;` + message + `&lt;/p&gt;`

        if ctaUrl != "" </span><span class="cov8" title="1">{
                html += `
    &lt;p style="margin-bottom: 24px;"&gt;
      &lt;a href="` + ctaUrl + `" style="display: inline-block; background-color: #4F46E5; color: #ffffff; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-weight: 600;"&gt;` + ctaText + `&lt;/a&gt;
    &lt;/p&gt;`
        }</span>

        <span class="cov8" title="1">html += `
    &lt;hr style="border: none; border-top: 1px solid #e5e7eb; margin: 32px 0 16px;"&gt;
    &lt;p style="font-size: 12px; color: #6b7280;"&gt;
      This email was sent by Emergent.
    &lt;/p&gt;
  &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`

        return html</span>
}

// generateFallbackText creates plain text email when template is not available
func (w *Worker) generateFallbackText(job *EmailJob, ctx TemplateContext) string <span class="cov8" title="1">{
        recipientName := ""
        if name, ok := ctx["recipientName"].(string); ok </span><span class="cov8" title="1">{
                recipientName = name
        }</span>

        <span class="cov8" title="1">greeting := "Hello"
        if recipientName != "" </span><span class="cov8" title="1">{
                greeting = "Hello " + recipientName
        }</span>

        <span class="cov8" title="1">message := ""
        if msg, ok := ctx["message"].(string); ok </span><span class="cov8" title="1">{
                message = msg
        }</span>

        <span class="cov8" title="1">ctaUrl := ""
        if url, ok := ctx["ctaUrl"].(string); ok </span><span class="cov8" title="1">{
                ctaUrl = url
        }</span>

        <span class="cov8" title="1">text := greeting + ",\n\n" + message

        if ctaUrl != "" </span><span class="cov8" title="1">{
                text += "\n\nLink: " + ctaUrl
        }</span>

        <span class="cov8" title="1">text += "\n\n---\nThis email was sent by Emergent."

        return text</span>
}

// incrementSuccess increments both processed and success counters
func (w *Worker) incrementSuccess() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.successCount++
        w.metricsMu.Unlock()
}</span>

// incrementFailure increments both processed and failure counters
func (w *Worker) incrementFailure() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.failureCount++
        w.metricsMu.Unlock()
}</span>

// Metrics returns current worker metrics
func (w *Worker) Metrics() WorkerMetrics <span class="cov8" title="1">{
        w.metricsMu.RLock()
        defer w.metricsMu.RUnlock()

        return WorkerMetrics{
                Processed: w.processedCount,
                Succeeded: w.successCount,
                Failed:    w.failureCount,
        }
}</span>

// WorkerMetrics contains worker metrics
type WorkerMetrics struct {
        Processed int64 `json:"processed"`
        Succeeded int64 `json:"succeeded"`
        Failed    int64 `json:"failed"`
}

// IsRunning returns whether the worker is currently running
func (w *Worker) IsRunning() bool <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        return w.running
}</span>

// sendError is a simple error type for send failures
type sendError struct {
        message string
}

func (e *sendError) Error() string <span class="cov8" title="1">{
        return e.message
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package events

import (
        "context"
        "crypto/rand"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "sync"
        "time"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
        "github.com/emergent/emergent-core/pkg/logger"
)

const (
        // HeartbeatInterval is how often to send heartbeat events
        HeartbeatInterval = 30 * time.Second
)

// Handler handles SSE connections for real-time events
type Handler struct {
        svc         *Service
        log         *slog.Logger
        connections map[string]*SSEConnection
        connMu      sync.RWMutex

        // Heartbeat management
        heartbeatCtx    context.Context
        heartbeatCancel context.CancelFunc
}

// NewHandler creates a new events handler
func NewHandler(svc *Service, log *slog.Logger) *Handler <span class="cov0" title="0">{
        ctx, cancel := context.WithCancel(context.Background())

        h := &amp;Handler{
                svc:             svc,
                log:             log.With(logger.Scope("events.handler")),
                connections:     make(map[string]*SSEConnection),
                heartbeatCtx:    ctx,
                heartbeatCancel: cancel,
        }

        // Start heartbeat goroutine
        go h.heartbeatLoop()

        return h
}</span>

// Stop stops the handler and cleans up resources
func (h *Handler) Stop() <span class="cov0" title="0">{
        h.heartbeatCancel()

        // Close all connections
        h.connMu.Lock()
        defer h.connMu.Unlock()

        for connID, conn := range h.connections </span><span class="cov0" title="0">{
                close(conn.Done)
                delete(h.connections, connID)
        }</span>
}

// heartbeatLoop sends periodic heartbeats to all connections
func (h *Handler) heartbeatLoop() <span class="cov0" title="0">{
        ticker := time.NewTicker(HeartbeatInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-h.heartbeatCtx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        h.sendHeartbeats()</span>
                }
        }
}

// sendHeartbeats sends a heartbeat to all active connections
func (h *Handler) sendHeartbeats() <span class="cov0" title="0">{
        h.connMu.RLock()
        connections := make([]*SSEConnection, 0, len(h.connections))
        for _, conn := range h.connections </span><span class="cov0" title="0">{
                connections = append(connections, conn)
        }</span>
        <span class="cov0" title="0">h.connMu.RUnlock()

        if len(connections) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">now := time.Now().UTC()
        heartbeat := HeartbeatEvent{
                Timestamp: now.Format(time.RFC3339),
                // Health status could be fetched here from health service if needed
        }

        for _, conn := range connections </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-conn.Done:<span class="cov0" title="0">
                        continue</span>
                default:<span class="cov0" title="0">
                        if err := h.sendEvent(conn, "heartbeat", heartbeat); err != nil </span><span class="cov0" title="0">{
                                h.log.Warn("failed to send heartbeat",
                                        slog.String("connection_id", conn.ConnectionID),
                                        logger.Error(err),
                                )
                                // Remove failed connection
                                h.removeConnection(conn.ConnectionID)
                        }</span> else<span class="cov0" title="0"> {
                                conn.LastHeartbeat = now
                        }</span>
                }
        }
}

// HandleStream handles GET /api/events/stream - SSE connection endpoint
func (h *Handler) HandleStream(c echo.Context) error <span class="cov0" title="0">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        // Get projectId from query param (required)
        <span class="cov0" title="0">projectID := c.QueryParam("projectId")
        if projectID == "" </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]string{
                        "error": "Missing projectId query parameter",
                })
        }</span>

        // Generate connection ID
        <span class="cov0" title="0">connectionID := h.generateConnectionID()

        // Set up SSE headers
        w := c.Response().Writer
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        w.Header().Set("X-Accel-Buffering", "no")

        flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                return apperror.ErrInternal.WithMessage("streaming not supported")
        }</span>

        // Create connection
        <span class="cov0" title="0">conn := &amp;SSEConnection{
                ConnectionID:  connectionID,
                UserID:        user.ID,
                ProjectID:     projectID,
                Writer:        w,
                Flusher:       flusher,
                Done:          make(chan struct{}),
                LastHeartbeat: time.Now(),
        }

        // Store connection
        h.connMu.Lock()
        h.connections[connectionID] = conn
        h.connMu.Unlock()

        defer h.removeConnection(connectionID)

        h.log.Info("SSE connection established",
                slog.String("connection_id", connectionID),
                slog.String("project_id", projectID),
                slog.String("user_id", user.ID),
        )

        // Send connected event
        connectedEvent := ConnectedEvent{
                ConnectionID: connectionID,
                ProjectID:    projectID,
        }
        if err := h.sendEvent(conn, "connected", connectedEvent); err != nil </span><span class="cov0" title="0">{
                h.log.Error("failed to send connected event", logger.Error(err))
                return nil
        }</span>

        // Subscribe to project events
        <span class="cov0" title="0">unsubscribe := h.svc.Subscribe(projectID, func(event EntityEvent) </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-conn.Done:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        payload := SSEEventPayload{
                                Entity:    event.Entity,
                                ID:        event.ID,
                                IDs:       event.IDs,
                                Data:      event.Data,
                                Timestamp: event.Timestamp,
                        }
                        if err := h.sendEvent(conn, string(event.Type), payload); err != nil </span><span class="cov0" title="0">{
                                h.log.Warn("failed to send event to connection",
                                        slog.String("connection_id", connectionID),
                                        logger.Error(err),
                                )
                        }</span>
                }
        })
        <span class="cov0" title="0">defer unsubscribe()

        // Wait for client disconnect
        ctx := c.Request().Context()
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                h.log.Info("SSE connection closed (client disconnected)",
                        slog.String("connection_id", connectionID),
                )</span>
        case &lt;-conn.Done:<span class="cov0" title="0">
                h.log.Info("SSE connection closed (server closed)",
                        slog.String("connection_id", connectionID),
                )</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// HandleConnectionsCount handles GET /api/events/connections/count
func (h *Handler) HandleConnectionsCount(c echo.Context) error <span class="cov0" title="0">{
        h.connMu.RLock()
        count := len(h.connections)
        h.connMu.RUnlock()

        return c.JSON(http.StatusOK, map[string]int{
                "count": count,
        })
}</span>

// sendEvent sends an SSE event to a connection
func (h *Handler) sendEvent(conn *SSEConnection, event string, data any) error <span class="cov0" title="0">{
        select </span>{
        case &lt;-conn.Done:<span class="cov0" title="0">
                return fmt.Errorf("connection closed")</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal event data: %w", err)
        }</span>

        <span class="cov0" title="0">fmt.Fprintf(conn.Writer, "event: %s\n", event)
        fmt.Fprintf(conn.Writer, "data: %s\n\n", jsonData)
        conn.Flusher.Flush()

        return nil</span>
}

// removeConnection removes a connection from the map
func (h *Handler) removeConnection(connectionID string) <span class="cov0" title="0">{
        h.connMu.Lock()
        defer h.connMu.Unlock()

        if conn, ok := h.connections[connectionID]; ok </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-conn.Done:<span class="cov0" title="0"></span>
                        // Already closed
                default:<span class="cov0" title="0">
                        close(conn.Done)</span>
                }
                <span class="cov0" title="0">delete(h.connections, connectionID)</span>
        }
}

// generateConnectionID creates a unique connection ID
func (h *Handler) generateConnectionID() string <span class="cov0" title="0">{
        bytes := make([]byte, 16)
        rand.Read(bytes)
        return fmt.Sprintf("sse_%d_%s", time.Now().UnixMilli(), hex.EncodeToString(bytes)[:12])
}</span>
</pre>
		
		<pre class="file" id="file37" style="display: none">package events

import (
        "context"
        "log/slog"

        "github.com/labstack/echo/v4"
        "go.uber.org/fx"

        "github.com/emergent/emergent-core/pkg/auth"
)

// Module provides the events domain
var Module = fx.Module("events",
        fx.Provide(NewService),
        fx.Provide(NewHandler),
        fx.Invoke(RegisterRoutes),
        fx.Invoke(RegisterLifecycle),
)

// RouteParams are the dependencies for registering routes
type RouteParams struct {
        fx.In

        Echo           *echo.Echo
        Handler        *Handler
        AuthMiddleware *auth.Middleware
}

// RegisterRoutes registers the events routes
func RegisterRoutes(p RouteParams) <span class="cov0" title="0">{
        // All events routes require authentication
        events := p.Echo.Group("/api/events")
        events.Use(p.AuthMiddleware.RequireAuth())

        events.GET("/stream", p.Handler.HandleStream)
        events.GET("/connections/count", p.Handler.HandleConnectionsCount)
}</span>

// LifecycleParams are the dependencies for lifecycle hooks
type LifecycleParams struct {
        fx.In

        LC      fx.Lifecycle
        Handler *Handler
        Log     *slog.Logger
}

// RegisterLifecycle registers lifecycle hooks for cleanup
func RegisterLifecycle(p LifecycleParams) <span class="cov0" title="0">{
        p.LC.Append(fx.Hook{
                OnStop: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        p.Log.Info("stopping events handler")
                        p.Handler.Stop()
                        return nil
                }</span>,
        })
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package events

import (
        "log/slog"
        "sync"
        "time"

        "github.com/emergent/emergent-core/pkg/logger"
)

// Subscriber is a callback function for receiving events
type Subscriber func(event EntityEvent)

// Service handles event pub/sub for real-time updates
type Service struct {
        log         *slog.Logger
        subscribers map[string][]Subscriber // projectID -&gt; subscribers
        mu          sync.RWMutex
}

// NewService creates a new events service
func NewService(log *slog.Logger) *Service <span class="cov0" title="0">{
        return &amp;Service{
                log:         log.With(logger.Scope("events.service")),
                subscribers: make(map[string][]Subscriber),
        }
}</span>

// Subscribe registers a callback for events on a specific project
// Returns an unsubscribe function
func (s *Service) Subscribe(projectID string, callback Subscriber) func() <span class="cov0" title="0">{
        s.mu.Lock()
        defer s.mu.Unlock()

        s.subscribers[projectID] = append(s.subscribers[projectID], callback)

        // Return unsubscribe function
        return func() </span><span class="cov0" title="0">{
                s.mu.Lock()
                defer s.mu.Unlock()

                subs := s.subscribers[projectID]
                for i, sub := range subs </span><span class="cov0" title="0">{
                        // Compare function pointers (this works for the same closure)
                        if &amp;sub == &amp;callback </span><span class="cov0" title="0">{
                                s.subscribers[projectID] = append(subs[:i], subs[i+1:]...)
                                break</span>
                        }
                }

                // Clean up empty subscriber lists
                <span class="cov0" title="0">if len(s.subscribers[projectID]) == 0 </span><span class="cov0" title="0">{
                        delete(s.subscribers, projectID)
                }</span>
        }
}

// Emit broadcasts an event to all subscribers for the project
func (s *Service) Emit(event EntityEvent) <span class="cov0" title="0">{
        s.mu.RLock()
        subs := s.subscribers[event.ProjectID]
        s.mu.RUnlock()

        if len(subs) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.log.Debug("emitting event",
                slog.String("type", string(event.Type)),
                slog.String("entity", string(event.Entity)),
                slog.String("project_id", event.ProjectID),
                slog.Int("subscribers", len(subs)),
        )

        for _, sub := range subs </span><span class="cov0" title="0">{
                // Call subscriber in goroutine to avoid blocking
                go sub(event)
        }</span>
}

// EmitCreated emits an entity.created event
func (s *Service) EmitCreated(entity EntityType, id string, projectID string, opts *EmitOptions) <span class="cov0" title="0">{
        event := EntityEvent{
                Type:      EventTypeCreated,
                Entity:    entity,
                ID:        &amp;id,
                ProjectID: projectID,
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }

        if opts != nil </span><span class="cov0" title="0">{
                event.Data = opts.Data
                event.Actor = opts.Actor
                event.Version = opts.Version
                event.ObjectType = opts.ObjectType
        }</span>

        <span class="cov0" title="0">s.Emit(event)</span>
}

// EmitUpdated emits an entity.updated event
func (s *Service) EmitUpdated(entity EntityType, id string, projectID string, opts *EmitOptions) <span class="cov0" title="0">{
        event := EntityEvent{
                Type:      EventTypeUpdated,
                Entity:    entity,
                ID:        &amp;id,
                ProjectID: projectID,
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }

        if opts != nil </span><span class="cov0" title="0">{
                event.Data = opts.Data
                event.Actor = opts.Actor
                event.Version = opts.Version
                event.ObjectType = opts.ObjectType
        }</span>

        <span class="cov0" title="0">s.Emit(event)</span>
}

// EmitDeleted emits an entity.deleted event
func (s *Service) EmitDeleted(entity EntityType, id string, projectID string, opts *EmitOptions) <span class="cov0" title="0">{
        event := EntityEvent{
                Type:      EventTypeDeleted,
                Entity:    entity,
                ID:        &amp;id,
                ProjectID: projectID,
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }

        if opts != nil </span><span class="cov0" title="0">{
                event.Actor = opts.Actor
                event.Version = opts.Version
                event.ObjectType = opts.ObjectType
        }</span>

        <span class="cov0" title="0">s.Emit(event)</span>
}

// EmitBatch emits an entity.batch event for multiple entities
func (s *Service) EmitBatch(entity EntityType, ids []string, projectID string, data map[string]any) <span class="cov0" title="0">{
        event := EntityEvent{
                Type:      EventTypeBatch,
                Entity:    entity,
                ID:        nil,
                IDs:       ids,
                ProjectID: projectID,
                Data:      data,
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }

        s.Emit(event)
}</span>

// GetSubscriberCount returns the number of subscribers for a project
func (s *Service) GetSubscriberCount(projectID string) int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return len(s.subscribers[projectID])
}</span>

// GetTotalSubscriberCount returns the total number of subscribers across all projects
func (s *Service) GetTotalSubscriberCount() int <span class="cov0" title="0">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        total := 0
        for _, subs := range s.subscribers </span><span class="cov0" title="0">{
                total += len(subs)
        }</span>
        <span class="cov0" title="0">return total</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Package agents provides ADK-based extraction agents for entity and relationship extraction.
package agents

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "strings"

        "google.golang.org/adk/agent"
        "google.golang.org/adk/agent/llmagent"
        "google.golang.org/adk/model"
        "google.golang.org/genai"

        "github.com/emergent/emergent-core/pkg/adk"
)

// EntityExtractorConfig holds configuration for the entity extractor agent.
type EntityExtractorConfig struct {
        // Model is the ADK LLM model to use.
        Model model.LLM

        // GenerateConfig is the generation configuration.
        GenerateConfig *genai.GenerateContentConfig

        // OutputKey is the session state key for extracted entities.
        // Default: "extracted_entities"
        OutputKey string

        // Logger for debug output.
        Logger *slog.Logger
}

// NewEntityExtractorAgent creates an ADK agent for entity extraction.
//
// The agent uses structured output (OutputSchema) to ensure valid JSON.
// Extracted entities are stored in session state under the OutputKey.
func NewEntityExtractorAgent(cfg EntityExtractorConfig) (agent.Agent, error) <span class="cov0" title="0">{
        if cfg.Model == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("model is required")
        }</span>

        <span class="cov0" title="0">outputKey := cfg.OutputKey
        if outputKey == "" </span><span class="cov0" title="0">{
                outputKey = "extracted_entities"
        }</span>

        <span class="cov0" title="0">log := cfg.Logger
        if log == nil </span><span class="cov0" title="0">{
                log = slog.Default()
        }</span>

        // Create the LLM agent with structured output
        <span class="cov0" title="0">agentCfg := llmagent.Config{
                Name:        "EntityExtractor",
                Description: "Extracts entities from document text with type-specific properties",

                Model:                 cfg.Model,
                GenerateContentConfig: cfg.GenerateConfig,

                // Use OutputSchema for structured JSON output
                OutputSchema: EntityExtractionSchema(),

                // Store output in session state for downstream agents
                OutputKey: outputKey,

                // Dynamic instruction built from extraction parameters
                InstructionProvider: func(ctx agent.ReadonlyContext) (string, error) </span><span class="cov0" title="0">{
                        // Get extraction parameters from session state
                        state := ctx.ReadonlyState()

                        documentTextRaw, err := state.Get("document_text")
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("document_text is required in session state: %w", err)
                        }</span>
                        <span class="cov0" title="0">documentText, ok := documentTextRaw.(string)
                        if !ok || documentText == "" </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("document_text must be a non-empty string")
                        }</span>

                        // Get optional parameters
                        <span class="cov0" title="0">objectSchemas := make(map[string]ObjectSchema)
                        if schemasRaw, err := state.Get("object_schemas"); err == nil </span><span class="cov0" title="0">{
                                if schemas, ok := schemasRaw.(map[string]ObjectSchema); ok </span><span class="cov0" title="0">{
                                        objectSchemas = schemas
                                }</span> else<span class="cov0" title="0"> if schemasMap, ok := schemasRaw.(map[string]any); ok </span><span class="cov0" title="0">{
                                        // Convert from generic map
                                        for k, v := range schemasMap </span><span class="cov0" title="0">{
                                                if schemaMap, ok := v.(map[string]any); ok </span><span class="cov0" title="0">{
                                                        objectSchemas[k] = convertToObjectSchema(schemaMap)
                                                }</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">var allowedTypes []string
                        if typesRaw, err := state.Get("allowed_types"); err == nil </span><span class="cov0" title="0">{
                                if types, ok := typesRaw.([]string); ok </span><span class="cov0" title="0">{
                                        allowedTypes = types
                                }</span>
                        }

                        <span class="cov0" title="0">var existingEntities []ExistingEntityContext
                        if entitiesRaw, err := state.Get("existing_entities"); err == nil </span><span class="cov0" title="0">{
                                if entities, ok := entitiesRaw.([]ExistingEntityContext); ok </span><span class="cov0" title="0">{
                                        existingEntities = entities
                                }</span>
                        }

                        // Build the extraction prompt
                        <span class="cov0" title="0">prompt := BuildEntityExtractionPrompt(
                                documentText,
                                objectSchemas,
                                allowedTypes,
                                existingEntities,
                        )

                        log.Debug("built entity extraction prompt",
                                slog.Int("prompt_length", len(prompt)),
                                slog.Int("document_length", len(documentText)),
                                slog.Int("schema_count", len(objectSchemas)),
                                slog.Int("existing_entity_count", len(existingEntities)),
                        )

                        return prompt, nil</span>
                },
        }

        <span class="cov0" title="0">return llmagent.New(agentCfg)</span>
}

// EntityExtractorFactory creates entity extractor agents with a shared model factory.
type EntityExtractorFactory struct {
        modelFactory *adk.ModelFactory
        log          *slog.Logger
}

// NewEntityExtractorFactory creates a new factory for entity extractor agents.
func NewEntityExtractorFactory(modelFactory *adk.ModelFactory, log *slog.Logger) *EntityExtractorFactory <span class="cov0" title="0">{
        return &amp;EntityExtractorFactory{
                modelFactory: modelFactory,
                log:          log,
        }
}</span>

// CreateAgent creates a new entity extractor agent.
func (f *EntityExtractorFactory) CreateAgent(ctx context.Context) (agent.Agent, error) <span class="cov0" title="0">{
        llm, err := f.modelFactory.CreateModel(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create LLM model: %w", err)
        }</span>

        <span class="cov0" title="0">return NewEntityExtractorAgent(EntityExtractorConfig{
                Model:          llm,
                GenerateConfig: f.modelFactory.ExtractionGenerateConfig(),
                Logger:         f.log,
        })</span>
}

// ParseEntityExtractionOutput parses the entity extraction output from session state.
func ParseEntityExtractionOutput(output any) (*EntityExtractionOutput, error) <span class="cov8" title="1">{
        if output == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("output is nil")
        }</span>

        // If it's already the right type, return it
        <span class="cov8" title="1">if result, ok := output.(*EntityExtractionOutput); ok </span><span class="cov8" title="1">{
                return result, nil
        }</span>

        // Try to parse as JSON string
        <span class="cov8" title="1">if str, ok := output.(string); ok </span><span class="cov8" title="1">{
                str = strings.TrimSpace(str)
                // Remove markdown code blocks if present
                str = strings.TrimPrefix(str, "```json")
                str = strings.TrimPrefix(str, "```")
                str = strings.TrimSuffix(str, "```")
                str = strings.TrimSpace(str)

                var result EntityExtractionOutput
                if err := json.Unmarshal([]byte(str), &amp;result); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse JSON: %w", err)
                }</span>
                <span class="cov8" title="1">return &amp;result, nil</span>
        }

        // Try to marshal and unmarshal for type conversion
        <span class="cov8" title="1">data, err := json.Marshal(output)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to marshal output: %w", err)
        }</span>

        <span class="cov8" title="1">var result EntityExtractionOutput
        if err := json.Unmarshal(data, &amp;result); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to unmarshal output: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// convertToObjectSchema converts a generic map to ObjectSchema.
func convertToObjectSchema(m map[string]any) ObjectSchema <span class="cov8" title="1">{
        schema := ObjectSchema{}

        if name, ok := m["name"].(string); ok </span><span class="cov8" title="1">{
                schema.Name = name
        }</span>
        <span class="cov8" title="1">if desc, ok := m["description"].(string); ok </span><span class="cov8" title="1">{
                schema.Description = desc
        }</span>
        <span class="cov8" title="1">if props, ok := m["properties"].(map[string]any); ok </span><span class="cov8" title="1">{
                schema.Properties = make(map[string]PropertyDef)
                for k, v := range props </span><span class="cov8" title="1">{
                        if propMap, ok := v.(map[string]any); ok </span><span class="cov8" title="1">{
                                pd := PropertyDef{}
                                if t, ok := propMap["type"].(string); ok </span><span class="cov8" title="1">{
                                        pd.Type = t
                                }</span>
                                <span class="cov8" title="1">if d, ok := propMap["description"].(string); ok </span><span class="cov8" title="1">{
                                        pd.Description = d
                                }</span>
                                <span class="cov8" title="1">schema.Properties[k] = pd</span>
                        }
                }
        }
        <span class="cov8" title="1">if req, ok := m["required"].([]any); ok </span><span class="cov8" title="1">{
                schema.Required = make([]string, 0, len(req))
                for _, r := range req </span><span class="cov8" title="1">{
                        if s, ok := r.(string); ok </span><span class="cov8" title="1">{
                                schema.Required = append(schema.Required, s)
                        }</span>
                }
        }

        <span class="cov8" title="1">return schema</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Package agents provides ADK-based extraction agents for entity and relationship extraction.
package agents

import (
        "context"
        "encoding/json"
        "fmt"
        "iter"
        "log/slog"
        "regexp"
        "strings"

        "google.golang.org/adk/agent"
        "google.golang.org/adk/agent/workflowagents/loopagent"
        "google.golang.org/adk/agent/workflowagents/sequentialagent"
        "google.golang.org/adk/model"
        "google.golang.org/adk/runner"
        "google.golang.org/adk/session"
        "google.golang.org/genai"

        "github.com/emergent/emergent-core/pkg/adk"
)

// ExtractionPipelineConfig holds configuration for the extraction pipeline.
type ExtractionPipelineConfig struct {
        // ModelFactory creates LLM models for the agents.
        ModelFactory *adk.ModelFactory

        // OrphanThreshold is the max acceptable orphan rate (0.0-1.0).
        // Default is 0.3 (30% orphans allowed).
        OrphanThreshold float64

        // MaxRetries is the max number of relationship extraction retries.
        // Default is 3.
        MaxRetries uint

        // Logger for debug output.
        Logger *slog.Logger
}

// ExtractionPipelineInput is the input for running the extraction pipeline.
type ExtractionPipelineInput struct {
        // DocumentText is the document text to extract from.
        DocumentText string

        // ObjectSchemas defines the entity types and their properties.
        ObjectSchemas map[string]ObjectSchema

        // RelationshipSchemas defines the relationship types.
        RelationshipSchemas map[string]RelationshipSchema

        // AllowedTypes limits extraction to specific entity types (optional).
        AllowedTypes []string

        // ExistingEntities provides context for identity resolution (optional).
        ExistingEntities []ExistingEntityContext
}

// ExtractionPipelineOutput is the result of running the extraction pipeline.
type ExtractionPipelineOutput struct {
        // Entities are the extracted entities with temp_ids.
        Entities []InternalEntity

        // Relationships are the extracted relationships.
        Relationships []ExtractedRelationship
}

// ExtractionPipeline orchestrates entity and relationship extraction using ADK agents.
type ExtractionPipeline struct {
        modelFactory    *adk.ModelFactory
        orphanThreshold float64
        maxRetries      uint
        log             *slog.Logger
}

// NewExtractionPipeline creates a new extraction pipeline.
func NewExtractionPipeline(cfg ExtractionPipelineConfig) (*ExtractionPipeline, error) <span class="cov0" title="0">{
        if cfg.ModelFactory == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("model factory is required")
        }</span>

        <span class="cov0" title="0">log := cfg.Logger
        if log == nil </span><span class="cov0" title="0">{
                log = slog.Default()
        }</span>

        <span class="cov0" title="0">orphanThreshold := cfg.OrphanThreshold
        if orphanThreshold &lt;= 0 </span><span class="cov0" title="0">{
                orphanThreshold = 0.3 // Default 30%
        }</span>

        <span class="cov0" title="0">maxRetries := cfg.MaxRetries
        if maxRetries == 0 </span><span class="cov0" title="0">{
                maxRetries = 3
        }</span>

        <span class="cov0" title="0">return &amp;ExtractionPipeline{
                modelFactory:    cfg.ModelFactory,
                orphanThreshold: orphanThreshold,
                maxRetries:      maxRetries,
                log:             log,
        }, nil</span>
}

// Run executes the extraction pipeline on the given input.
func (p *ExtractionPipeline) Run(ctx context.Context, input ExtractionPipelineInput) (*ExtractionPipelineOutput, error) <span class="cov0" title="0">{
        if input.DocumentText == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("document text is required")
        }</span>

        <span class="cov0" title="0">p.log.Info("starting extraction pipeline",
                slog.Int("document_length", len(input.DocumentText)),
                slog.Int("schema_count", len(input.ObjectSchemas)),
        )

        // Create the LLM model
        llm, err := p.modelFactory.CreateModel(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create LLM model: %w", err)
        }</span>

        // Create the sequential pipeline agent
        <span class="cov0" title="0">pipelineAgent, err := p.createPipelineAgent(llm)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create pipeline agent: %w", err)
        }</span>

        // Create initial state map
        <span class="cov0" title="0">initialState := map[string]any{
                "document_text": input.DocumentText,
        }
        if len(input.ObjectSchemas) &gt; 0 </span><span class="cov0" title="0">{
                initialState["object_schemas"] = input.ObjectSchemas
        }</span>
        <span class="cov0" title="0">if len(input.RelationshipSchemas) &gt; 0 </span><span class="cov0" title="0">{
                initialState["relationship_schemas"] = input.RelationshipSchemas
        }</span>
        <span class="cov0" title="0">if len(input.AllowedTypes) &gt; 0 </span><span class="cov0" title="0">{
                initialState["allowed_types"] = input.AllowedTypes
        }</span>
        <span class="cov0" title="0">if len(input.ExistingEntities) &gt; 0 </span><span class="cov0" title="0">{
                initialState["existing_entities"] = input.ExistingEntities
        }</span>

        // Create a session with initial state
        <span class="cov0" title="0">sessionService := session.InMemoryService()
        createResp, err := sessionService.Create(ctx, &amp;session.CreateRequest{
                AppName: "extraction",
                UserID:  "system",
                State:   initialState,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create session: %w", err)
        }</span>
        <span class="cov0" title="0">sess := createResp.Session

        // Create a runner and execute
        r, err := runner.New(runner.Config{
                Agent:          pipelineAgent,
                SessionService: sessionService,
                AppName:        "extraction",
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create runner: %w", err)
        }</span>

        // Run the pipeline with an empty user message (agents use state)
        <span class="cov0" title="0">userMessage := &amp;genai.Content{
                Role:  "user",
                Parts: []*genai.Part{genai.NewPartFromText("Extract entities and relationships from the document.")},
        }

        var events []*session.Event
        for event, err := range r.Run(ctx, "system", sess.ID(), userMessage, agent.RunConfig{}) </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("pipeline execution failed: %w", err)
                }</span>
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">p.log.Debug("pipeline completed", slog.Int("event_count", len(events)))

        // Fetch the updated session to get the final state
        getResp, err := sessionService.Get(ctx, &amp;session.GetRequest{
                AppName:   "extraction",
                UserID:    "system",
                SessionID: sess.ID(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get session: %w", err)
        }</span>

        // Extract results from session state
        <span class="cov0" title="0">return p.extractResults(getResp.Session)</span>
}

// createPipelineAgent creates the sequential pipeline agent.
func (p *ExtractionPipeline) createPipelineAgent(llm model.LLM) (agent.Agent, error) <span class="cov0" title="0">{
        generateConfig := p.modelFactory.ExtractionGenerateConfig()

        // Create entity extractor agent
        entityExtractor, err := NewEntityExtractorAgent(EntityExtractorConfig{
                Model:          llm,
                GenerateConfig: generateConfig,
                OutputKey:      "extracted_entities_raw",
                Logger:         p.log,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create entity extractor: %w", err)
        }</span>

        // Create a post-processing agent that adds temp_ids
        <span class="cov0" title="0">entityProcessor, err := p.createEntityProcessorAgent()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create entity processor: %w", err)
        }</span>

        // Create relationship builder agent
        <span class="cov0" title="0">relationshipBuilder, err := NewRelationshipBuilderAgent(RelationshipBuilderConfig{
                Model:          llm,
                GenerateConfig: generateConfig,
                OutputKey:      "extracted_relationships",
                Logger:         p.log,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create relationship builder: %w", err)
        }</span>

        // Create quality checker agent
        <span class="cov0" title="0">qualityChecker, err := NewQualityCheckerAgent(QualityCheckerConfig{
                OrphanThreshold: p.orphanThreshold,
                Logger:          p.log,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create quality checker: %w", err)
        }</span>

        // Create a sequential agent for relationship building + quality check
        <span class="cov0" title="0">relationshipWithQuality, err := sequentialagent.New(sequentialagent.Config{
                AgentConfig: agent.Config{
                        Name:        "RelationshipWithQuality",
                        Description: "Builds relationships and checks quality",
                        SubAgents:   []agent.Agent{relationshipBuilder, qualityChecker},
                },
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create relationship with quality agent: %w", err)
        }</span>

        // Wrap in a loop agent for retries
        // The loop will continue until quality checker escalates or max iterations reached
        <span class="cov0" title="0">relationshipLoop, err := loopagent.New(loopagent.Config{
                AgentConfig: agent.Config{
                        Name:        "RelationshipRetryLoop",
                        Description: "Retries relationship building until quality threshold is met",
                        SubAgents:   []agent.Agent{relationshipWithQuality},
                },
                MaxIterations: p.maxRetries,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create relationship loop agent: %w", err)
        }</span>

        // Compose into final sequential pipeline:
        // 1. Extract entities
        // 2. Process entities (add temp_ids)
        // 3. Build relationships with quality check loop
        <span class="cov0" title="0">return sequentialagent.New(sequentialagent.Config{
                AgentConfig: agent.Config{
                        Name:        "ExtractionPipeline",
                        Description: "Extracts entities and relationships from documents",
                        SubAgents:   []agent.Agent{entityExtractor, entityProcessor, relationshipLoop},
                },
        })</span>
}

// createEntityProcessorAgent creates an agent that processes raw entities to add temp_ids.
func (p *ExtractionPipeline) createEntityProcessorAgent() (agent.Agent, error) <span class="cov0" title="0">{
        return agent.New(agent.Config{
                Name:        "EntityProcessor",
                Description: "Processes extracted entities to add temp_ids for relationship building",
                Run: func(ctx agent.InvocationContext) iter.Seq2[*session.Event, error] </span><span class="cov0" title="0">{
                        return func(yield func(*session.Event, error) bool) </span><span class="cov0" title="0">{
                                state := ctx.Session().State()

                                // Get raw extracted entities
                                rawEntitiesAny, err := state.Get("extracted_entities_raw")
                                if err != nil </span><span class="cov0" title="0">{
                                        yield(nil, fmt.Errorf("no extracted entities found: %w", err))
                                        return
                                }</span>

                                // Parse the raw output
                                <span class="cov0" title="0">var entities []ExtractedEntity
                                switch v := rawEntitiesAny.(type) </span>{
                                case string:<span class="cov0" title="0">
                                        output, err := ParseEntityExtractionOutput(v)
                                        if err != nil </span><span class="cov0" title="0">{
                                                yield(nil, fmt.Errorf("failed to parse entity output: %w", err))
                                                return
                                        }</span>
                                        <span class="cov0" title="0">entities = output.Entities</span>
                                case *EntityExtractionOutput:<span class="cov0" title="0">
                                        entities = v.Entities</span>
                                case map[string]any:<span class="cov0" title="0">
                                        // Try to extract entities array from map
                                        if entArr, ok := v["entities"].([]any); ok </span><span class="cov0" title="0">{
                                                for _, e := range entArr </span><span class="cov0" title="0">{
                                                        data, _ := json.Marshal(e)
                                                        var entity ExtractedEntity
                                                        if err := json.Unmarshal(data, &amp;entity); err == nil </span><span class="cov0" title="0">{
                                                                entities = append(entities, entity)
                                                        }</span>
                                                }
                                        }
                                default:<span class="cov0" title="0">
                                        data, _ := json.Marshal(v)
                                        output, err := ParseEntityExtractionOutput(string(data))
                                        if err != nil </span><span class="cov0" title="0">{
                                                yield(nil, fmt.Errorf("failed to parse entity output from %T: %w", v, err))
                                                return
                                        }</span>
                                        <span class="cov0" title="0">entities = output.Entities</span>
                                }

                                // Generate temp_ids for entities
                                <span class="cov0" title="0">existingIDs := make(map[string]bool)
                                internalEntities := make([]InternalEntity, 0, len(entities))

                                for _, e := range entities </span><span class="cov0" title="0">{
                                        tempID := generateTempID(e.Name, e.Type, existingIDs)
                                        existingIDs[tempID] = true

                                        internalEntities = append(internalEntities, InternalEntity{
                                                TempID:           tempID,
                                                Name:             e.Name,
                                                Type:             e.Type,
                                                Description:      e.Description,
                                                Properties:       e.Properties,
                                                Action:           e.Action,
                                                ExistingEntityID: e.ExistingEntityID,
                                        })
                                }</span>

                                // Store processed entities
                                <span class="cov0" title="0">if err := state.Set("extracted_entities", internalEntities); err != nil </span><span class="cov0" title="0">{
                                        yield(nil, fmt.Errorf("failed to store processed entities: %w", err))
                                        return
                                }</span>

                                <span class="cov0" title="0">p.log.Debug("processed entities",
                                        slog.Int("count", len(internalEntities)),
                                )

                                // Yield a completion event
                                event := session.NewEvent(ctx.InvocationID())
                                event.Author = "EntityProcessor"
                                event.Content = genai.NewContentFromText(fmt.Sprintf("Processed %d entities with temp_ids", len(internalEntities)), "model")
                                yield(event, nil)</span>
                        }
                },
        })
}

// extractResults extracts the final results from session state.
func (p *ExtractionPipeline) extractResults(sess session.Session) (*ExtractionPipelineOutput, error) <span class="cov0" title="0">{
        state := sess.State()

        // Get extracted entities
        var entities []InternalEntity
        if entitiesRaw, err := state.Get("extracted_entities"); err == nil </span><span class="cov0" title="0">{
                switch v := entitiesRaw.(type) </span>{
                case []InternalEntity:<span class="cov0" title="0">
                        entities = v</span>
                default:<span class="cov0" title="0">
                        data, _ := json.Marshal(v)
                        if err := json.Unmarshal(data, &amp;entities); err != nil </span><span class="cov0" title="0">{
                                p.log.Warn("failed to parse entities from state", slog.String("error", err.Error()))
                        }</span>
                }
        }

        // Get extracted relationships
        <span class="cov0" title="0">var relationships []ExtractedRelationship
        if relsRaw, err := state.Get("extracted_relationships"); err == nil </span><span class="cov0" title="0">{
                switch v := relsRaw.(type) </span>{
                case []ExtractedRelationship:<span class="cov0" title="0">
                        relationships = v</span>
                case *RelationshipExtractionOutput:<span class="cov0" title="0">
                        relationships = v.Relationships</span>
                case string:<span class="cov0" title="0">
                        output, err := ParseRelationshipExtractionOutput(v)
                        if err == nil </span><span class="cov0" title="0">{
                                relationships = output.Relationships
                        }</span>
                default:<span class="cov0" title="0">
                        data, _ := json.Marshal(v)
                        var output RelationshipExtractionOutput
                        if err := json.Unmarshal(data, &amp;output); err == nil </span><span class="cov0" title="0">{
                                relationships = output.Relationships
                        }</span>
                }
        }

        <span class="cov0" title="0">p.log.Info("extraction pipeline completed",
                slog.Int("entity_count", len(entities)),
                slog.Int("relationship_count", len(relationships)),
        )

        return &amp;ExtractionPipelineOutput{
                Entities:      entities,
                Relationships: relationships,
        }, nil</span>
}

// generateTempID generates a unique temp_id for an entity.
func generateTempID(name, typeName string, existing map[string]bool) string <span class="cov8" title="1">{
        // Normalize the type and name
        typeSlug := strings.ToLower(typeName)
        typeSlug = regexp.MustCompile(`[^a-z0-9]+`).ReplaceAllString(typeSlug, "_")
        if len(typeSlug) &gt; 20 </span><span class="cov8" title="1">{
                typeSlug = typeSlug[:20]
        }</span>

        <span class="cov8" title="1">nameSlug := strings.ToLower(name)
        nameSlug = regexp.MustCompile(`[^a-z0-9]+`).ReplaceAllString(nameSlug, "_")
        if len(nameSlug) &gt; 20 </span><span class="cov8" title="1">{
                nameSlug = nameSlug[:20]
        }</span>

        <span class="cov8" title="1">baseID := fmt.Sprintf("%s_%s", typeSlug, nameSlug)
        id := baseID
        counter := 1

        for existing[id] </span><span class="cov8" title="1">{
                id = fmt.Sprintf("%s_%d", baseID, counter)
                counter++
        }</span>

        <span class="cov8" title="1">return id</span>
}

// CalculateOrphanRate calculates the percentage of entities not in any relationship.
func CalculateOrphanRate(entities []InternalEntity, relationships []ExtractedRelationship) float64 <span class="cov8" title="1">{
        if len(entities) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">connectedIDs := make(map[string]bool)
        for _, rel := range relationships </span><span class="cov8" title="1">{
                connectedIDs[rel.SourceRef] = true
                connectedIDs[rel.TargetRef] = true
        }</span>

        <span class="cov8" title="1">orphanCount := 0
        for _, e := range entities </span><span class="cov8" title="1">{
                if !connectedIDs[e.TempID] </span><span class="cov8" title="1">{
                        orphanCount++
                }</span>
        }

        <span class="cov8" title="1">return float64(orphanCount) / float64(len(entities))</span>
}

// GetOrphanTempIDs returns temp_ids of entities without relationships.
func GetOrphanTempIDs(entities []InternalEntity, relationships []ExtractedRelationship) []string <span class="cov8" title="1">{
        connectedIDs := make(map[string]bool)
        for _, rel := range relationships </span><span class="cov8" title="1">{
                connectedIDs[rel.SourceRef] = true
                connectedIDs[rel.TargetRef] = true
        }</span>

        <span class="cov8" title="1">var orphans []string
        for _, e := range entities </span><span class="cov8" title="1">{
                if !connectedIDs[e.TempID] </span><span class="cov8" title="1">{
                        orphans = append(orphans, e.TempID)
                }</span>
        }

        <span class="cov8" title="1">return orphans</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Package agents provides ADK-based extraction agents for entity and relationship extraction.
package agents

import (
        "fmt"
        "strings"
)

// EntityExtractorSystemPrompt is the base system prompt for entity extraction.
const EntityExtractorSystemPrompt = `You are an expert knowledge graph builder. Extract entities from the document.

For EACH entity, you MUST provide these four fields:
1. name: Clear, descriptive name of the entity (REQUIRED, top-level field)
2. type: Entity type from the allowed list (REQUIRED, top-level field)
3. description: Brief description of what this entity represents (top-level field)
4. properties: An object containing type-specific attributes (CRITICAL - see below)

CRITICAL INSTRUCTIONS FOR PROPERTIES:
- The "properties" field is an object that MUST contain type-specific attributes extracted from the document
- For Person entities: include role, occupation, title, father, mother, tribe, age, significance, etc.
- For Location entities: include region, country, location_type, significance, etc.
- For Event entities: include date, location, participants, outcome, etc.
- For Organization entities: include type, purpose, members, location, etc.
- NEVER return an empty properties object {} if there is ANY relevant information in the document
- Extract ALL attributes mentioned or implied in the text for each entity
- The properties object should NOT contain name, type, or description - those are top-level fields

RULES:
- Extract ALL entities that match the allowed types
- Be thorough - don't miss important entities
- Use consistent naming
- Keep descriptions concise but informative
- Only include properties that are explicitly mentioned or clearly implied in the document
- Do NOT guess or fabricate property values`

// RelationshipBuilderSystemPrompt is the base system prompt for relationship extraction.
const RelationshipBuilderSystemPrompt = `You are an expert at finding connections in knowledge graphs. Your job is to identify ALL meaningful relationships between entities.

For EACH relationship you find:
1. Identify the source entity (by temp_id)
2. Identify the target entity (by temp_id)
3. Choose a relationship type from the "Available Relationship Types" section below
4. Provide a description of this specific relationship instance

## CRITICAL RULES

### Completeness is Key
- EVERY entity should have at least one relationship (no orphans!)
- Use the EXACT temp_ids from the entity list
- Create MULTIPLE relationships for the same entity pair if there are different relationship types

### Group Actions Apply to ALL Members
- When text says "they went to Moab" and "they" refers to a family, create TRAVELS_TO for EACH person
- When text says "They were Ephrathites" about a family, create MEMBER_OF for EACH family member
- When text says "a man of Bethlehem... he and his wife and his two sons", ALL of them are from Bethlehem

### Type Constraints
- Check the source/target type constraints for each relationship type
- If a relationship type says "Person  Place", the source must be a Person and target must be a Place

## RELATIONSHIP DISCOVERY
1. **Family**: "his two sons were X and Y"  parent-child relationships for BOTH parents
2. **Marriage**: "his wife X", "took wives"  spousal relationships  
3. **Travel**: "went to X"  journey/travel relationships
4. **Residence**: "from Bethlehem", "lived there"  residence relationships
5. **Membership**: "They were Ephrathites"  group membership for each person
6. **Geography**: "Bethlehem in Judah"  geographic containment (Place in Place)`

// ObjectSchema represents a schema for an entity or relationship type.
type ObjectSchema struct {
        Name                 string                 `json:"name"`
        Description          string                 `json:"description,omitempty"`
        Properties           map[string]PropertyDef `json:"properties,omitempty"`
        Required             []string               `json:"required,omitempty"`
        ExtractionGuidelines string                 `json:"extraction_guidelines,omitempty"`
}

// PropertyDef defines a property in a schema.
type PropertyDef struct {
        Type        string `json:"type"`
        Description string `json:"description,omitempty"`
}

// RelationshipSchema represents a relationship type schema.
type RelationshipSchema struct {
        Name                  string   `json:"name"`
        Description           string   `json:"description,omitempty"`
        SourceTypes           []string `json:"source_types,omitempty"`
        TargetTypes           []string `json:"target_types,omitempty"`
        ExtractionGuidelines  string   `json:"extraction_guidelines,omitempty"`
}

// ExistingEntityContext provides context about an existing entity for identity resolution.
type ExistingEntityContext struct {
        ID          string  `json:"id"`
        Name        string  `json:"name"`
        TypeName    string  `json:"type_name"`
        Description string  `json:"description,omitempty"`
        Similarity  float64 `json:"similarity,omitempty"`
}

// InternalEntity represents an entity with a temp_id for internal processing.
type InternalEntity struct {
        TempID           string         `json:"temp_id"`
        Name             string         `json:"name"`
        Type             string         `json:"type"`
        Description      string         `json:"description,omitempty"`
        Properties       map[string]any `json:"properties,omitempty"`
        Action           EntityAction   `json:"action,omitempty"`
        ExistingEntityID string         `json:"existing_entity_id,omitempty"`
}

// BuildEntityExtractionPrompt builds a prompt for entity extraction.
func BuildEntityExtractionPrompt(
        documentText string,
        objectSchemas map[string]ObjectSchema,
        allowedTypes []string,
        existingEntities []ExistingEntityContext,
) string <span class="cov8" title="1">{
        // Determine types to extract
        typesToExtract := allowedTypes
        if len(typesToExtract) == 0 </span><span class="cov8" title="1">{
                typesToExtract = make([]string, 0, len(objectSchemas))
                for typeName := range objectSchemas </span><span class="cov8" title="1">{
                        typesToExtract = append(typesToExtract, typeName)
                }</span>
        }

        <span class="cov8" title="1">var sb strings.Builder

        // System prompt
        sb.WriteString(EntityExtractorSystemPrompt)
        sb.WriteString("\n\n## Entity Types and Their Properties\n\n")
        sb.WriteString(fmt.Sprintf("Extract ONLY these types: %s\n\n", strings.Join(typesToExtract, ", ")))

        // Top-level fields not to include in properties
        topLevelFields := map[string]bool{"name": true, "description": true, "type": true}

        // Add type descriptions with property schemas
        for _, typeName := range typesToExtract </span><span class="cov8" title="1">{
                schema, ok := objectSchemas[typeName]
                if !ok </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("### %s\n\n", typeName))
                        continue</span>
                }

                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("### %s\n", typeName))
                if schema.Description != "" </span><span class="cov8" title="1">{
                        sb.WriteString(schema.Description)
                        sb.WriteString("\n")
                }</span>

                // Include property definitions (excluding top-level fields)
                <span class="cov8" title="1">if len(schema.Properties) &gt; 0 </span><span class="cov8" title="1">{
                        additionalProps := make(map[string]PropertyDef)
                        for propName, propDef := range schema.Properties </span><span class="cov8" title="1">{
                                if !topLevelFields[propName] &amp;&amp; !strings.HasPrefix(propName, "_") </span><span class="cov8" title="1">{
                                        additionalProps[propName] = propDef
                                }</span>
                        }

                        <span class="cov8" title="1">if len(additionalProps) &gt; 0 </span><span class="cov8" title="1">{
                                sb.WriteString("**Additional Properties** (stored in `properties` object):\n")
                                for propName, propDef := range additionalProps </span><span class="cov8" title="1">{
                                        propType := propDef.Type
                                        if propType == "" </span><span class="cov8" title="1">{
                                                propType = "string"
                                        }</span>
                                        <span class="cov8" title="1">required := ""
                                        for _, req := range schema.Required </span><span class="cov8" title="1">{
                                                if req == propName </span><span class="cov8" title="1">{
                                                        required = " (required)"
                                                        break</span>
                                                }
                                        }
                                        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("- `%s` (%s)%s: %s\n", propName, propType, required, propDef.Description))</span>
                                }
                        }
                }
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        // Add existing entity context if provided
        <span class="cov8" title="1">if len(existingEntities) &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString(contextAwareExtractionRules)
                sb.WriteString("\n\n## Existing Entities in Knowledge Graph\n\n")
                sb.WriteString("These entities already exist. Use their exact names and IDs if the document references them:\n\n")

                // Group by type
                byType := make(map[string][]ExistingEntityContext)
                for _, entity := range existingEntities </span><span class="cov8" title="1">{
                        byType[entity.TypeName] = append(byType[entity.TypeName], entity)
                }</span>

                <span class="cov8" title="1">const maxPerType = 10
                const maxTotal = 50
                totalShown := 0

                for _, typeName := range typesToExtract </span><span class="cov8" title="1">{
                        if totalShown &gt;= maxTotal </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">entities, ok := byType[typeName]
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("### %s\n", typeName))
                        toShow := entities
                        if len(toShow) &gt; maxPerType </span><span class="cov8" title="1">{
                                toShow = toShow[:maxPerType]
                        }</span>

                        <span class="cov8" title="1">for _, entity := range toShow </span><span class="cov8" title="1">{
                                if totalShown &gt;= maxTotal </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">similarity := ""
                                if entity.Similarity &gt; 0 </span><span class="cov8" title="1">{
                                        similarity = fmt.Sprintf(" (similarity: %.0f%%)", entity.Similarity*100)
                                }</span>
                                <span class="cov8" title="1">desc := ""
                                if entity.Description != "" </span><span class="cov8" title="1">{
                                        d := entity.Description
                                        if len(d) &gt; 100 </span><span class="cov8" title="1">{
                                                d = d[:100]
                                        }</span>
                                        <span class="cov8" title="1">desc = " - " + d</span>
                                }
                                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("- **%s** [id: %s]%s%s\n", entity.Name, entity.ID, similarity, desc))
                                totalShown++</span>
                        }

                        <span class="cov8" title="1">if len(entities) &gt; maxPerType </span><span class="cov8" title="1">{
                                sb.WriteString(fmt.Sprintf("  _(and %d more)_\n", len(entities)-maxPerType))
                        }</span>
                }
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        // Add document
        <span class="cov8" title="1">sb.WriteString("\n## Document\n\n")
        sb.WriteString(documentText)
        sb.WriteString("\n\n")

        // Output format instructions
        hasExistingEntities := len(existingEntities) &gt; 0
        if hasExistingEntities </span><span class="cov8" title="1">{
                sb.WriteString(outputFormatWithContext)
        }</span> else<span class="cov8" title="1"> {
                sb.WriteString(outputFormatBasic)
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

// BuildRelationshipPrompt builds a prompt for relationship extraction.
func BuildRelationshipPrompt(
        entities []InternalEntity,
        relationshipSchemas map[string]RelationshipSchema,
        documentText string,
        existingEntities []ExistingEntityContext,
        orphanTempIDs []string,
) string <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString(RelationshipBuilderSystemPrompt)
        sb.WriteString("\n\n## Available Relationship Types\n\n")

        // Add relationship type definitions
        for typeName, schema := range relationshipSchemas </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("### %s\n", typeName))
                if schema.Description != "" </span><span class="cov8" title="1">{
                        sb.WriteString(schema.Description)
                        sb.WriteString("\n\n")
                }</span>

                // Add source/target constraints
                <span class="cov8" title="1">if len(schema.SourceTypes) &gt; 0 || len(schema.TargetTypes) &gt; 0 </span><span class="cov8" title="1">{
                        sourceStr := "any"
                        if len(schema.SourceTypes) &gt; 0 </span><span class="cov8" title="1">{
                                sourceStr = strings.Join(schema.SourceTypes, " or ")
                        }</span>
                        <span class="cov8" title="1">targetStr := "any"
                        if len(schema.TargetTypes) &gt; 0 </span><span class="cov8" title="1">{
                                targetStr = strings.Join(schema.TargetTypes, " or ")
                        }</span>
                        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("**Valid entity types:** %s  %s\n\n", sourceStr, targetStr))</span>
                }

                <span class="cov8" title="1">if schema.ExtractionGuidelines != "" </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("**Guidelines:**\n%s\n\n", schema.ExtractionGuidelines))
                }</span>
        }

        // Add entities section
        <span class="cov8" title="1">sb.WriteString("\n## Extracted Entities\n\n")
        sb.WriteString("Use these temp_ids when creating relationships:\n\n")

        for _, entity := range entities </span><span class="cov8" title="1">{
                desc := ""
                if entity.Description != "" </span><span class="cov8" title="1">{
                        d := entity.Description
                        if len(d) &gt; 80 </span><span class="cov8" title="1">{
                                d = d[:80] + "..."
                        }</span>
                        <span class="cov8" title="1">desc = " - " + d</span>
                }
                <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("- **%s** [temp_id: %s] (%s)%s\n", entity.Name, entity.TempID, entity.Type, desc))</span>
        }
        <span class="cov8" title="1">sb.WriteString("\n")

        // Add orphan focus if retrying
        if len(orphanTempIDs) &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString("## PRIORITY: Connect These Orphan Entities\n\n")
                sb.WriteString("The following entities have NO relationships yet. Find connections for them:\n")
                for _, id := range orphanTempIDs </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("- %s\n", id))
                }</span>
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        }

        // Add document context
        <span class="cov8" title="1">sb.WriteString("## Document\n\n")
        sb.WriteString(documentText)
        sb.WriteString("\n\n")

        // Output format
        sb.WriteString(relationshipOutputFormat)

        return sb.String()</span>
}

// Context-aware extraction rules
const contextAwareExtractionRules = `
CONTEXT-AWARE EXTRACTION RULES:
- Below is a list of existing entities already in the knowledge graph
- When you find an entity that MATCHES an existing one, use the SAME NAME and set action="enrich"
- When you find NEW information about an existing entity, include it in the description
- Only extract entities that are mentioned or referenced in THIS document
- Do NOT simply copy existing entities - only include them if the document mentions them
- For each entity, specify an "action":
  - "create" (default): This is a completely NEW entity not in the existing list
  - "enrich": This entity MATCHES an existing entity - new info should be merged
  - "reference": This entity is just a reference to an existing entity (for relationships only, no new info)
- When action is "enrich" or "reference", also provide "existing_entity_id" with the UUID from the existing entity`

// Basic output format (no existing entities)
const outputFormatBasic = `## Output Format

Return a JSON object with an "entities" key containing an array of entities.

Each entity must have:
- name (string): Entity name
- type (string): One of the allowed types above
- description (string, optional): Brief description
- properties (object, optional): Type-specific attributes found in the document

Example:
{
  "entities": [
    {
      "name": "John the Apostle",
      "type": "Person",
      "description": "One of the twelve apostles",
      "properties": {
        "role": "apostle",
        "occupation": "fisherman"
      }
    }
  ]
}

Extract all entities now.`

// Output format with existing entity context
const outputFormatWithContext = `## Output Format

Return a JSON object with an "entities" key containing an array of entities.

Each entity must have:
- name (string): Entity name (use exact names from existing entities when matching)
- type (string): One of the allowed types above
- description (string, optional): Brief description
- properties (object, optional): Type-specific attributes found in the document
- action (string, optional): "create" (new entity), "enrich" (update existing), or "reference" (just a reference)
- existing_entity_id (string, optional): UUID of existing entity when action is "enrich" or "reference"

Example:
{
  "entities": [
    {
      "name": "Jerusalem",
      "type": "Place",
      "description": "Holy city",
      "properties": {"region": "Judea"},
      "action": "enrich",
      "existing_entity_id": "abc-123-uuid"
    }
  ]
}

Extract all entities now.`

// Relationship output format
const relationshipOutputFormat = `## Output Format

Return a JSON object with a "relationships" key containing an array of relationships.

Each relationship must have:
- source_ref (string): temp_id of the source entity
- target_ref (string): temp_id of the target entity
- type (string): Relationship type from the allowed list above
- description (string, optional): Description of this relationship instance

Example:
{
  "relationships": [
    {
      "source_ref": "person_john",
      "target_ref": "organization_disciples",
      "type": "MEMBER_OF",
      "description": "John was one of the twelve disciples"
    }
  ]
}

Find ALL relationships between the entities now. Ensure no entity is left without at least one connection.`
</pre>
		
		<pre class="file" id="file42" style="display: none">// Package agents provides ADK-based extraction agents for entity and relationship extraction.
package agents

import (
        "fmt"
        "iter"
        "log/slog"

        "google.golang.org/adk/agent"
        "google.golang.org/adk/session"
        "google.golang.org/genai"
)

// QualityCheckerConfig holds configuration for the quality checker agent.
type QualityCheckerConfig struct {
        // OrphanThreshold is the max acceptable orphan rate (0.0-1.0).
        // Default is 0.3 (30% orphans allowed).
        OrphanThreshold float64

        // Logger for debug output.
        Logger *slog.Logger
}

// NewQualityCheckerAgent creates an agent that checks extraction quality.
// It calculates the orphan rate (entities not in any relationship).
// If quality passes, it escalates to break the loop.
// If quality fails, it stores orphan IDs in state for retry.
func NewQualityCheckerAgent(cfg QualityCheckerConfig) (agent.Agent, error) <span class="cov0" title="0">{
        threshold := cfg.OrphanThreshold
        if threshold &lt;= 0 </span><span class="cov0" title="0">{
                threshold = 0.3 // Default 30%
        }</span>

        <span class="cov0" title="0">log := cfg.Logger
        if log == nil </span><span class="cov0" title="0">{
                log = slog.Default()
        }</span>

        <span class="cov0" title="0">return agent.New(agent.Config{
                Name:        "QualityChecker",
                Description: "Checks extraction quality and decides whether to retry relationship building",
                Run: func(ctx agent.InvocationContext) iter.Seq2[*session.Event, error] </span><span class="cov0" title="0">{
                        return func(yield func(*session.Event, error) bool) </span><span class="cov0" title="0">{
                                state := ctx.Session().State()

                                // Get entities and relationships from state
                                entities, err := getEntitiesFromState(state)
                                if err != nil </span><span class="cov0" title="0">{
                                        yield(nil, fmt.Errorf("failed to get entities: %w", err))
                                        return
                                }</span>

                                <span class="cov0" title="0">relationships, err := getRelationshipsFromState(state)
                                if err != nil </span><span class="cov0" title="0">{
                                        // No relationships yet is OK on first iteration
                                        relationships = nil
                                }</span>

                                // Calculate orphan rate
                                <span class="cov0" title="0">orphanRate := CalculateOrphanRate(entities, relationships)
                                orphanIDs := GetOrphanTempIDs(entities, relationships)

                                log.Info("quality check",
                                        slog.Float64("orphan_rate", orphanRate),
                                        slog.Float64("threshold", threshold),
                                        slog.Int("orphan_count", len(orphanIDs)),
                                        slog.Int("entity_count", len(entities)),
                                        slog.Int("relationship_count", len(relationships)),
                                )

                                // Get current iteration from state
                                iteration := 1
                                if iterRaw, err := state.Get("retry_iteration"); err == nil </span><span class="cov0" title="0">{
                                        if i, ok := iterRaw.(int); ok </span><span class="cov0" title="0">{
                                                iteration = i
                                        }</span>
                                }

                                // Create the event
                                <span class="cov0" title="0">event := session.NewEvent(ctx.InvocationID())
                                event.Author = "QualityChecker"

                                if orphanRate &lt;= threshold </span><span class="cov0" title="0">{
                                        // Quality passes - escalate to break the loop
                                        log.Info("quality check passed, escalating",
                                                slog.Float64("orphan_rate", orphanRate),
                                        )
                                        event.Content = genai.NewContentFromText(
                                                fmt.Sprintf("Quality check passed. Orphan rate: %.2f%% (threshold: %.2f%%)",
                                                        orphanRate*100, threshold*100), "model")
                                        event.Actions.Escalate = true

                                        // Clear retry state
                                        event.Actions.StateDelta = map[string]any{
                                                "quality_passed": true,
                                                "final_orphan_rate": orphanRate,
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        // Quality fails - store orphan IDs for retry
                                        log.Info("quality check failed, will retry",
                                                slog.Float64("orphan_rate", orphanRate),
                                                slog.Int("iteration", iteration),
                                        )
                                        event.Content = genai.NewContentFromText(
                                                fmt.Sprintf("Quality check failed. Orphan rate: %.2f%% (threshold: %.2f%%). Retry iteration %d.",
                                                        orphanRate*100, threshold*100, iteration+1), "model")

                                        // Store state for retry
                                        event.Actions.StateDelta = map[string]any{
                                                "orphan_temp_ids":   orphanIDs,
                                                "retry_iteration":  iteration + 1,
                                                "quality_passed":   false,
                                                "last_orphan_rate": orphanRate,
                                        }
                                }</span>

                                <span class="cov0" title="0">yield(event, nil)</span>
                        }
                },
        })
}

// getEntitiesFromState retrieves entities from session state.
func getEntitiesFromState(state session.State) ([]InternalEntity, error) <span class="cov8" title="1">{
        raw, err := state.Get("extracted_entities")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">switch v := raw.(type) </span>{
        case []InternalEntity:<span class="cov8" title="1">
                return v, nil</span>
        case []any:<span class="cov8" title="1">
                var entities []InternalEntity
                for _, item := range v </span><span class="cov8" title="1">{
                        if e, ok := item.(InternalEntity); ok </span><span class="cov8" title="1">{
                                entities = append(entities, e)
                        }</span> else<span class="cov8" title="1"> if m, ok := item.(map[string]any); ok </span><span class="cov8" title="1">{
                                entity := InternalEntity{
                                        TempID:      getString(m, "temp_id"),
                                        Name:        getString(m, "name"),
                                        Type:        getString(m, "type"),
                                        Description: getString(m, "description"),
                                }
                                if entity.TempID != "" </span><span class="cov8" title="1">{
                                        entities = append(entities, entity)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return entities, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unexpected type for entities: %T", raw)</span>
        }
}

// getRelationshipsFromState retrieves relationships from session state.
func getRelationshipsFromState(state session.State) ([]ExtractedRelationship, error) <span class="cov8" title="1">{
        raw, err := state.Get("extracted_relationships")
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">switch v := raw.(type) </span>{
        case []ExtractedRelationship:<span class="cov8" title="1">
                return v, nil</span>
        case *RelationshipExtractionOutput:<span class="cov8" title="1">
                return v.Relationships, nil</span>
        case []any:<span class="cov8" title="1">
                var rels []ExtractedRelationship
                for _, item := range v </span><span class="cov8" title="1">{
                        if r, ok := item.(ExtractedRelationship); ok </span><span class="cov8" title="1">{
                                rels = append(rels, r)
                        }</span> else<span class="cov8" title="1"> if m, ok := item.(map[string]any); ok </span><span class="cov8" title="1">{
                                rel := ExtractedRelationship{
                                        SourceRef:   getString(m, "source_ref"),
                                        TargetRef:   getString(m, "target_ref"),
                                        Type:        getString(m, "type"),
                                        Description: getString(m, "description"),
                                }
                                if rel.SourceRef != "" &amp;&amp; rel.TargetRef != "" </span><span class="cov8" title="1">{
                                        rels = append(rels, rel)
                                }</span>
                        }
                }
                <span class="cov8" title="1">return rels, nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unexpected type for relationships: %T", raw)</span>
        }
}

// getString safely gets a string value from a map.
func getString(m map[string]any, key string) string <span class="cov8" title="1">{
        if v, ok := m[key].(string); ok </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">// Package agents provides ADK-based extraction agents for entity and relationship extraction.
package agents

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"
        "strings"

        "google.golang.org/adk/agent"
        "google.golang.org/adk/agent/llmagent"
        "google.golang.org/adk/model"
        "google.golang.org/genai"

        "github.com/emergent/emergent-core/pkg/adk"
)

// RelationshipBuilderConfig holds configuration for the relationship builder agent.
type RelationshipBuilderConfig struct {
        // Model is the ADK LLM model to use.
        Model model.LLM

        // GenerateConfig is the generation configuration.
        GenerateConfig *genai.GenerateContentConfig

        // OutputKey is the session state key for extracted relationships.
        // Default: "extracted_relationships"
        OutputKey string

        // Logger for debug output.
        Logger *slog.Logger
}

// NewRelationshipBuilderAgent creates an ADK agent for relationship extraction.
//
// The agent uses structured output (OutputSchema) to ensure valid JSON.
// Extracted relationships are stored in session state under the OutputKey.
//
// Required session state:
// - extracted_entities: []InternalEntity - entities extracted in previous step
// - document_text: string - the document text for context
//
// Optional session state:
// - relationship_schemas: map[string]RelationshipSchema - relationship type definitions
// - orphan_temp_ids: []string - entity temp_ids that need relationships (for retry)
func NewRelationshipBuilderAgent(cfg RelationshipBuilderConfig) (agent.Agent, error) <span class="cov0" title="0">{
        if cfg.Model == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("model is required")
        }</span>

        <span class="cov0" title="0">outputKey := cfg.OutputKey
        if outputKey == "" </span><span class="cov0" title="0">{
                outputKey = "extracted_relationships"
        }</span>

        <span class="cov0" title="0">log := cfg.Logger
        if log == nil </span><span class="cov0" title="0">{
                log = slog.Default()
        }</span>

        // Create the LLM agent with structured output
        <span class="cov0" title="0">agentCfg := llmagent.Config{
                Name:        "RelationshipBuilder",
                Description: "Builds relationships between extracted entities based on document context",

                Model:                 cfg.Model,
                GenerateContentConfig: cfg.GenerateConfig,

                // Use OutputSchema for structured JSON output
                OutputSchema: RelationshipExtractionSchema(),

                // Store output in session state
                OutputKey: outputKey,

                // Dynamic instruction built from extraction state
                InstructionProvider: func(ctx agent.ReadonlyContext) (string, error) </span><span class="cov0" title="0">{
                        state := ctx.ReadonlyState()

                        // Get extracted entities (required)
                        entitiesRaw, err := state.Get("extracted_entities")
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("extracted_entities is required in session state: %w", err)
                        }</span>

                        <span class="cov0" title="0">var entities []InternalEntity
                        switch e := entitiesRaw.(type) </span>{
                        case []InternalEntity:<span class="cov0" title="0">
                                entities = e</span>
                        case []any:<span class="cov0" title="0">
                                // Convert from generic slice
                                for _, item := range e </span><span class="cov0" title="0">{
                                        if data, err := json.Marshal(item); err == nil </span><span class="cov0" title="0">{
                                                var entity InternalEntity
                                                if err := json.Unmarshal(data, &amp;entity); err == nil </span><span class="cov0" title="0">{
                                                        entities = append(entities, entity)
                                                }</span>
                                        }
                                }
                        default:<span class="cov0" title="0">
                                return "", fmt.Errorf("extracted_entities must be []InternalEntity, got %T", entitiesRaw)</span>
                        }

                        <span class="cov0" title="0">if len(entities) == 0 </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("no entities to build relationships from")
                        }</span>

                        // Get document text (required)
                        <span class="cov0" title="0">documentTextRaw, err := state.Get("document_text")
                        if err != nil </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("document_text is required in session state: %w", err)
                        }</span>
                        <span class="cov0" title="0">documentText, ok := documentTextRaw.(string)
                        if !ok || documentText == "" </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("document_text must be a non-empty string")
                        }</span>

                        // Get optional parameters
                        <span class="cov0" title="0">relationshipSchemas := make(map[string]RelationshipSchema)
                        if schemasRaw, err := state.Get("relationship_schemas"); err == nil </span><span class="cov0" title="0">{
                                if schemas, ok := schemasRaw.(map[string]RelationshipSchema); ok </span><span class="cov0" title="0">{
                                        relationshipSchemas = schemas
                                }</span> else<span class="cov0" title="0"> if schemasMap, ok := schemasRaw.(map[string]any); ok </span><span class="cov0" title="0">{
                                        // Convert from generic map
                                        for k, v := range schemasMap </span><span class="cov0" title="0">{
                                                if schemaMap, ok := v.(map[string]any); ok </span><span class="cov0" title="0">{
                                                        relationshipSchemas[k] = convertToRelationshipSchema(schemaMap)
                                                }</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">var existingEntities []ExistingEntityContext
                        if entitiesRaw, err := state.Get("existing_entities"); err == nil </span><span class="cov0" title="0">{
                                if ents, ok := entitiesRaw.([]ExistingEntityContext); ok </span><span class="cov0" title="0">{
                                        existingEntities = ents
                                }</span>
                        }

                        <span class="cov0" title="0">var orphanTempIDs []string
                        if orphansRaw, err := state.Get("orphan_temp_ids"); err == nil </span><span class="cov0" title="0">{
                                if orphans, ok := orphansRaw.([]string); ok </span><span class="cov0" title="0">{
                                        orphanTempIDs = orphans
                                }</span>
                        }

                        // Build the relationship prompt
                        <span class="cov0" title="0">prompt := BuildRelationshipPrompt(
                                entities,
                                relationshipSchemas,
                                documentText,
                                existingEntities,
                                orphanTempIDs,
                        )

                        log.Debug("built relationship prompt",
                                slog.Int("prompt_length", len(prompt)),
                                slog.Int("entity_count", len(entities)),
                                slog.Int("schema_count", len(relationshipSchemas)),
                                slog.Int("orphan_count", len(orphanTempIDs)),
                        )

                        return prompt, nil</span>
                },
        }

        <span class="cov0" title="0">return llmagent.New(agentCfg)</span>
}

// RelationshipBuilderFactory creates relationship builder agents with a shared model factory.
type RelationshipBuilderFactory struct {
        modelFactory *adk.ModelFactory
        log          *slog.Logger
}

// NewRelationshipBuilderFactory creates a new factory for relationship builder agents.
func NewRelationshipBuilderFactory(modelFactory *adk.ModelFactory, log *slog.Logger) *RelationshipBuilderFactory <span class="cov0" title="0">{
        return &amp;RelationshipBuilderFactory{
                modelFactory: modelFactory,
                log:          log,
        }
}</span>

// CreateAgent creates a new relationship builder agent.
func (f *RelationshipBuilderFactory) CreateAgent(ctx context.Context) (agent.Agent, error) <span class="cov0" title="0">{
        llm, err := f.modelFactory.CreateModel(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create LLM model: %w", err)
        }</span>

        <span class="cov0" title="0">return NewRelationshipBuilderAgent(RelationshipBuilderConfig{
                Model:          llm,
                GenerateConfig: f.modelFactory.ExtractionGenerateConfig(),
                Logger:         f.log,
        })</span>
}

// ParseRelationshipExtractionOutput parses the relationship extraction output from session state.
func ParseRelationshipExtractionOutput(output any) (*RelationshipExtractionOutput, error) <span class="cov8" title="1">{
        if output == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("output is nil")
        }</span>

        // If it's already the right type, return it
        <span class="cov8" title="1">if result, ok := output.(*RelationshipExtractionOutput); ok </span><span class="cov8" title="1">{
                return result, nil
        }</span>

        // Try to parse as JSON string
        <span class="cov8" title="1">if str, ok := output.(string); ok </span><span class="cov8" title="1">{
                str = strings.TrimSpace(str)
                // Remove markdown code blocks if present
                str = strings.TrimPrefix(str, "```json")
                str = strings.TrimPrefix(str, "```")
                str = strings.TrimSuffix(str, "```")
                str = strings.TrimSpace(str)

                var result RelationshipExtractionOutput
                if err := json.Unmarshal([]byte(str), &amp;result); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to parse JSON: %w", err)
                }</span>
                <span class="cov8" title="1">return &amp;result, nil</span>
        }

        // Try to marshal and unmarshal for type conversion
        <span class="cov8" title="1">data, err := json.Marshal(output)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to marshal output: %w", err)
        }</span>

        <span class="cov8" title="1">var result RelationshipExtractionOutput
        if err := json.Unmarshal(data, &amp;result); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to unmarshal output: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// convertToRelationshipSchema converts a generic map to RelationshipSchema.
func convertToRelationshipSchema(m map[string]any) RelationshipSchema <span class="cov8" title="1">{
        schema := RelationshipSchema{}

        if name, ok := m["name"].(string); ok </span><span class="cov8" title="1">{
                schema.Name = name
        }</span>
        <span class="cov8" title="1">if desc, ok := m["description"].(string); ok </span><span class="cov8" title="1">{
                schema.Description = desc
        }</span>
        <span class="cov8" title="1">if st, ok := m["source_types"].([]any); ok </span><span class="cov8" title="1">{
                for _, t := range st </span><span class="cov8" title="1">{
                        if s, ok := t.(string); ok </span><span class="cov8" title="1">{
                                schema.SourceTypes = append(schema.SourceTypes, s)
                        }</span>
                }
        }
        <span class="cov8" title="1">if tt, ok := m["target_types"].([]any); ok </span><span class="cov8" title="1">{
                for _, t := range tt </span><span class="cov8" title="1">{
                        if s, ok := t.(string); ok </span><span class="cov8" title="1">{
                                schema.TargetTypes = append(schema.TargetTypes, s)
                        }</span>
                }
        }
        <span class="cov8" title="1">if g, ok := m["extraction_guidelines"].(string); ok </span><span class="cov8" title="1">{
                schema.ExtractionGuidelines = g
        }</span>

        <span class="cov8" title="1">return schema</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Package agents provides ADK-based extraction agents for entity and relationship extraction.
package agents

import (
        "google.golang.org/genai"
)

// EntityAction represents the action to take for an extracted entity.
type EntityAction string

const (
        // EntityActionCreate indicates a new entity not in existing context.
        EntityActionCreate EntityAction = "create"
        // EntityActionEnrich indicates an entity that matches existing, merge new info.
        EntityActionEnrich EntityAction = "enrich"
        // EntityActionReference indicates a pure reference to an existing entity.
        EntityActionReference EntityAction = "reference"
)

// ExtractedEntity represents an entity extracted by the LLM.
type ExtractedEntity struct {
        // Name is the human-readable name of the entity.
        Name string `json:"name"`
        // Type is the entity type (e.g., "Person", "Organization", "Location").
        Type string `json:"type"`
        // Description is a brief description of the entity.
        Description string `json:"description,omitempty"`
        // Properties contains type-specific attributes extracted from the document.
        Properties map[string]any `json:"properties,omitempty"`
        // Action indicates what to do with this entity (create/enrich/reference).
        Action EntityAction `json:"action,omitempty"`
        // ExistingEntityID is the UUID of an existing entity (when action is enrich/reference).
        ExistingEntityID string `json:"existing_entity_id,omitempty"`
}

// EntityExtractionOutput is the output schema for entity extraction.
type EntityExtractionOutput struct {
        Entities []ExtractedEntity `json:"entities"`
}

// ExtractedRelationship represents a relationship extracted by the LLM.
type ExtractedRelationship struct {
        // SourceRef is the temp_id of the source entity.
        SourceRef string `json:"source_ref"`
        // TargetRef is the temp_id of the target entity.
        TargetRef string `json:"target_ref"`
        // Type is the relationship type (e.g., "WORKS_FOR", "LOCATED_IN").
        Type string `json:"type"`
        // Description is an optional description of the relationship.
        Description string `json:"description,omitempty"`
}

// RelationshipExtractionOutput is the output schema for relationship extraction.
type RelationshipExtractionOutput struct {
        Relationships []ExtractedRelationship `json:"relationships"`
}

// EntityExtractionSchema returns the genai.Schema for entity extraction output.
// This schema is used with ADK's OutputSchema for structured JSON output.
func EntityExtractionSchema() *genai.Schema <span class="cov8" title="1">{
        return &amp;genai.Schema{
                Type:        genai.TypeObject,
                Description: "Output containing extracted entities from the document",
                Required:    []string{"entities"},
                Properties: map[string]*genai.Schema{
                        "entities": {
                                Type:        genai.TypeArray,
                                Description: "Array of extracted entities",
                                Items: &amp;genai.Schema{
                                        Type:     genai.TypeObject,
                                        Required: []string{"name", "type"},
                                        Properties: map[string]*genai.Schema{
                                                "name": {
                                                        Type:        genai.TypeString,
                                                        Description: "Human-readable name of the entity",
                                                },
                                                "type": {
                                                        Type:        genai.TypeString,
                                                        Description: "Entity type (e.g., 'Person', 'Organization', 'Location')",
                                                },
                                                "description": {
                                                        Type:        genai.TypeString,
                                                        Description: "Brief description of the entity",
                                                },
                                                "properties": {
                                                        Type:        genai.TypeObject,
                                                        Description: "Type-specific attributes extracted from the document (e.g., role, occupation, location)",
                                                },
                                                "action": {
                                                        Type:        genai.TypeString,
                                                        Description: "Action: 'create' (new entity), 'enrich' (update existing), 'reference' (just a reference)",
                                                        Enum:        []string{"create", "enrich", "reference"},
                                                },
                                                "existing_entity_id": {
                                                        Type:        genai.TypeString,
                                                        Description: "UUID of existing entity when action is 'enrich' or 'reference'",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>

// RelationshipExtractionSchema returns the genai.Schema for relationship extraction output.
func RelationshipExtractionSchema() *genai.Schema <span class="cov8" title="1">{
        return &amp;genai.Schema{
                Type:        genai.TypeObject,
                Description: "Output containing extracted relationships between entities",
                Required:    []string{"relationships"},
                Properties: map[string]*genai.Schema{
                        "relationships": {
                                Type:        genai.TypeArray,
                                Description: "Array of extracted relationships",
                                Items: &amp;genai.Schema{
                                        Type:     genai.TypeObject,
                                        Required: []string{"source_ref", "target_ref", "type"},
                                        Properties: map[string]*genai.Schema{
                                                "source_ref": {
                                                        Type:        genai.TypeString,
                                                        Description: "temp_id of the source entity",
                                                },
                                                "target_ref": {
                                                        Type:        genai.TypeString,
                                                        Description: "temp_id of the target entity",
                                                },
                                                "type": {
                                                        Type:        genai.TypeString,
                                                        Description: "Relationship type (e.g., 'WORKS_FOR', 'LOCATED_IN', 'PARENT_OF')",
                                                },
                                                "description": {
                                                        Type:        genai.TypeString,
                                                        Description: "Optional description of this specific relationship instance",
                                                },
                                        },
                                },
                        },
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file45" style="display: none">package extraction

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "math"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/logger"
)

// ChunkEmbeddingJobsService manages the chunk embedding job queue.
// It provides methods to enqueue, dequeue, and manage embedding jobs for document chunks.
//
// Key features:
// - Idempotent enqueue (won't create duplicate active jobs for same chunk)
// - Atomic dequeue with FOR UPDATE SKIP LOCKED
// - Exponential backoff for retries
// - Stale job recovery
// - Queue statistics
//
// Note: Jobs retry indefinitely until they succeed (no maxAttempts limit).
type ChunkEmbeddingJobsService struct {
        db  bun.IDB
        log *slog.Logger
        cfg *ChunkEmbeddingConfig
}

// ChunkEmbeddingConfig contains configuration for chunk embedding jobs
type ChunkEmbeddingConfig struct {
        // BaseRetryDelaySec is the base delay in seconds for retries (default: 60)
        BaseRetryDelaySec int
        // MaxRetryDelaySec is the maximum delay in seconds (default: 3600)
        MaxRetryDelaySec int
        // WorkerIntervalMs is the polling interval in milliseconds (default: 5000)
        WorkerIntervalMs int
        // WorkerBatchSize is the number of jobs to process per poll (default: 10)
        WorkerBatchSize int
}

// DefaultChunkEmbeddingConfig returns default configuration
func DefaultChunkEmbeddingConfig() *ChunkEmbeddingConfig <span class="cov8" title="1">{
        return &amp;ChunkEmbeddingConfig{
                BaseRetryDelaySec: 60,
                MaxRetryDelaySec:  3600,
                WorkerIntervalMs:  5000,
                WorkerBatchSize:   10,
        }
}</span>

// WorkerInterval returns the worker interval as a Duration
func (c *ChunkEmbeddingConfig) WorkerInterval() time.Duration <span class="cov8" title="1">{
        return time.Duration(c.WorkerIntervalMs) * time.Millisecond
}</span>

// NewChunkEmbeddingJobsService creates a new chunk embedding jobs service
func NewChunkEmbeddingJobsService(db bun.IDB, log *slog.Logger, cfg *ChunkEmbeddingConfig) *ChunkEmbeddingJobsService <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov0" title="0">{
                cfg = DefaultChunkEmbeddingConfig()
        }</span>
        <span class="cov8" title="1">return &amp;ChunkEmbeddingJobsService{
                db:  db,
                log: log.With(logger.Scope("chunk.embedding.jobs")),
                cfg: cfg,
        }</span>
}

// ChunkEnqueueOptions contains options for enqueuing a chunk embedding job
type ChunkEnqueueOptions struct {
        ChunkID    string     // Required: the chunk ID to generate embedding for
        Priority   int        // Optional: higher = more urgent (default: 0)
        ScheduleAt *time.Time // Optional: when to process (default: now)
}

// Enqueue creates a new chunk embedding job or returns existing active job.
// Idempotent: if an active (pending|processing) job exists for the chunk, returns it.
func (s *ChunkEmbeddingJobsService) Enqueue(ctx context.Context, opts ChunkEnqueueOptions) (*ChunkEmbeddingJob, error) <span class="cov8" title="1">{
        // Check for existing active job
        existing := &amp;ChunkEmbeddingJob{}
        err := s.db.NewSelect().
                Model(existing).
                Where("chunk_id = ?", opts.ChunkID).
                Where("status IN ('pending', 'processing')").
                Limit(1).
                Scan(ctx)

        if err == nil </span><span class="cov8" title="1">{
                // Active job exists, return it
                return existing, nil
        }</span>
        <span class="cov8" title="1">if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("check existing job: %w", err)
        }</span>

        // No active job, create new one
        <span class="cov8" title="1">scheduleAt := time.Now()
        if opts.ScheduleAt != nil </span><span class="cov8" title="1">{
                scheduleAt = *opts.ScheduleAt
        }</span>

        <span class="cov8" title="1">job := &amp;ChunkEmbeddingJob{
                ChunkID:      opts.ChunkID,
                Status:       JobStatusPending,
                AttemptCount: 0,
                Priority:     opts.Priority,
                ScheduledAt:  scheduleAt,
        }

        _, err = s.db.NewInsert().
                Model(job).
                Returning("*").
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("enqueue chunk embedding job: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Debug("enqueued chunk embedding job",
                slog.String("job_id", job.ID),
                slog.String("chunk_id", job.ChunkID),
                slog.Int("priority", job.Priority))

        return job, nil</span>
}

// EnqueueBatch creates multiple chunk embedding jobs in a single transaction.
// Skips chunks that already have active jobs.
func (s *ChunkEmbeddingJobsService) EnqueueBatch(ctx context.Context, chunkIDs []string, priority int) (int, error) <span class="cov8" title="1">{
        if len(chunkIDs) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Get chunks that already have active jobs
        <span class="cov8" title="1">var existingChunkIDs []string
        err := s.db.NewSelect().
                Model((*ChunkEmbeddingJob)(nil)).
                Column("chunk_id").
                Where("chunk_id IN (?)", bun.In(chunkIDs)).
                Where("status IN ('pending', 'processing')").
                Scan(ctx, &amp;existingChunkIDs)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("check existing jobs: %w", err)
        }</span>

        // Filter out chunks with existing jobs
        <span class="cov8" title="1">existingSet := make(map[string]bool, len(existingChunkIDs))
        for _, id := range existingChunkIDs </span><span class="cov8" title="1">{
                existingSet[id] = true
        }</span>

        <span class="cov8" title="1">var toEnqueue []string
        for _, id := range chunkIDs </span><span class="cov8" title="1">{
                if !existingSet[id] </span><span class="cov8" title="1">{
                        toEnqueue = append(toEnqueue, id)
                }</span>
        }

        <span class="cov8" title="1">if len(toEnqueue) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Create jobs
        <span class="cov8" title="1">now := time.Now()
        jobs := make([]*ChunkEmbeddingJob, len(toEnqueue))
        for i, chunkID := range toEnqueue </span><span class="cov8" title="1">{
                jobs[i] = &amp;ChunkEmbeddingJob{
                        ChunkID:      chunkID,
                        Status:       JobStatusPending,
                        AttemptCount: 0,
                        Priority:     priority,
                        ScheduledAt:  now,
                }
        }</span>

        <span class="cov8" title="1">_, err = s.db.NewInsert().
                Model(&amp;jobs).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("enqueue batch: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Debug("enqueued chunk embedding jobs batch",
                slog.Int("count", len(jobs)),
                slog.Int("skipped", len(existingChunkIDs)))

        return len(jobs), nil</span>
}

// Dequeue atomically claims jobs for processing.
// Uses PostgreSQL's FOR UPDATE SKIP LOCKED for concurrent workers.
func (s *ChunkEmbeddingJobsService) Dequeue(ctx context.Context, batchSize int) ([]*ChunkEmbeddingJob, error) <span class="cov8" title="1">{
        if batchSize &lt;= 0 </span><span class="cov0" title="0">{
                batchSize = s.cfg.WorkerBatchSize
        }</span>

        <span class="cov8" title="1">var jobs []*ChunkEmbeddingJob

        // Strategic SQL: FOR UPDATE SKIP LOCKED for concurrent workers
        // Order by priority DESC (higher = more urgent) then by scheduled_at ASC
        err := s.db.NewRaw(`WITH cte AS (
                SELECT id FROM kb.chunk_embedding_jobs
                WHERE status = 'pending' 
                        AND scheduled_at &lt;= now()
                ORDER BY priority DESC, scheduled_at ASC
                FOR UPDATE SKIP LOCKED
                LIMIT ?
        )
        UPDATE kb.chunk_embedding_jobs j 
        SET status = 'processing', 
                started_at = now(),
                attempt_count = attempt_count + 1,
                updated_at = now()
        FROM cte WHERE j.id = cte.id
        RETURNING j.*`, batchSize).Scan(ctx, &amp;jobs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dequeue chunk embedding jobs: %w", err)
        }</span>

        <span class="cov8" title="1">return jobs, nil</span>
}

// MarkCompleted marks a job as successfully completed
func (s *ChunkEmbeddingJobsService) MarkCompleted(ctx context.Context, id string) error <span class="cov8" title="1">{
        now := time.Now()
        _, err := s.db.NewUpdate().
                Model((*ChunkEmbeddingJob)(nil)).
                Set("status = ?", JobStatusCompleted).
                Set("completed_at = ?", now).
                Set("last_error = NULL").
                Set("updated_at = ?", now).
                Where("id = ?", id).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mark completed: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Debug("chunk embedding job completed", slog.String("job_id", id))
        return nil</span>
}

// MarkFailed marks a job as failed and schedules retry with exponential backoff.
// Unlike email jobs, chunk embedding jobs retry indefinitely (no max attempts).
func (s *ChunkEmbeddingJobsService) MarkFailed(ctx context.Context, id string, jobErr error) error <span class="cov8" title="1">{
        job := &amp;ChunkEmbeddingJob{}
        err := s.db.NewSelect().
                Model(job).
                Column("id", "attempt_count").
                Where("id = ?", id).
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        s.log.Warn("chunk embedding job not found when marking as failed", slog.String("job_id", id))
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("get job for mark failed: %w", err)</span>
        }

        <span class="cov8" title="1">errorMessage := truncateError(jobErr.Error())

        // Calculate exponential backoff: base * attempt^2, capped at max
        delaySeconds := int(math.Min(
                float64(s.cfg.MaxRetryDelaySec),
                float64(s.cfg.BaseRetryDelaySec)*float64(job.AttemptCount)*float64(job.AttemptCount),
        ))
        if delaySeconds &lt; s.cfg.BaseRetryDelaySec </span><span class="cov0" title="0">{
                delaySeconds = s.cfg.BaseRetryDelaySec
        }</span>

        // Requeue for retry
        <span class="cov8" title="1">_, updateErr := s.db.NewRaw(`UPDATE kb.chunk_embedding_jobs 
                SET status = 'pending', 
                        last_error = ?, 
                        scheduled_at = now() + (? || ' seconds')::interval,
                        updated_at = now()
                WHERE id = ?`,
                errorMessage, fmt.Sprintf("%d", delaySeconds), id).Exec(ctx)
        if updateErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requeue failed job: %w", updateErr)
        }</span>

        <span class="cov8" title="1">s.log.Warn("chunk embedding job failed, retrying",
                slog.String("job_id", id),
                slog.Int("attempt", job.AttemptCount),
                slog.Duration("retry_delay", time.Duration(delaySeconds)*time.Second),
                slog.String("error", errorMessage))

        return nil</span>
}

// RecoverStaleJobs recovers jobs stuck in 'processing' status.
// This can happen when the server restarts while jobs are being processed.
func (s *ChunkEmbeddingJobsService) RecoverStaleJobs(ctx context.Context, staleThresholdMinutes int) (int, error) <span class="cov8" title="1">{
        if staleThresholdMinutes &lt;= 0 </span><span class="cov0" title="0">{
                staleThresholdMinutes = 10
        }</span>

        <span class="cov8" title="1">result, err := s.db.NewRaw(`UPDATE kb.chunk_embedding_jobs 
                SET status = 'pending', 
                        started_at = NULL,
                        scheduled_at = now(),
                        updated_at = now()
                WHERE status = 'processing' 
                        AND started_at &lt; now() - (? || ' minutes')::interval`,
                fmt.Sprintf("%d", staleThresholdMinutes)).Exec(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("recover stale jobs: %w", err)
        }</span>

        <span class="cov8" title="1">count, _ := result.RowsAffected()

        if count &gt; 0 </span><span class="cov8" title="1">{
                s.log.Warn("recovered stale chunk embedding jobs",
                        slog.Int64("count", count),
                        slog.Int("threshold_minutes", staleThresholdMinutes))
        }</span>

        <span class="cov8" title="1">return int(count), nil</span>
}

// GetJob retrieves a job by ID
func (s *ChunkEmbeddingJobsService) GetJob(ctx context.Context, id string) (*ChunkEmbeddingJob, error) <span class="cov8" title="1">{
        job := &amp;ChunkEmbeddingJob{}
        err := s.db.NewSelect().
                Model(job).
                Where("id = ?", id).
                Scan(ctx)

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get job: %w", err)
        }</span>

        <span class="cov8" title="1">return job, nil</span>
}

// GetActiveJobForChunk returns the active job for a chunk, if any.
func (s *ChunkEmbeddingJobsService) GetActiveJobForChunk(ctx context.Context, chunkID string) (*ChunkEmbeddingJob, error) <span class="cov8" title="1">{
        job := &amp;ChunkEmbeddingJob{}
        err := s.db.NewSelect().
                Model(job).
                Where("chunk_id = ?", chunkID).
                Where("status IN ('pending', 'processing')").
                Order("created_at DESC").
                Limit(1).
                Scan(ctx)

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get active job for chunk: %w", err)
        }</span>

        <span class="cov8" title="1">return job, nil</span>
}

// Stats returns queue statistics
func (s *ChunkEmbeddingJobsService) Stats(ctx context.Context) (*ChunkEmbeddingQueueStats, error) <span class="cov8" title="1">{
        stats := &amp;ChunkEmbeddingQueueStats{}

        err := s.db.NewRaw(`SELECT 
                COUNT(*) FILTER (WHERE status = 'pending') as pending,
                COUNT(*) FILTER (WHERE status = 'processing') as processing,
                COUNT(*) FILTER (WHERE status = 'completed') as completed,
                COUNT(*) FILTER (WHERE status = 'failed') as failed
        FROM kb.chunk_embedding_jobs`).Scan(ctx, &amp;stats.Pending, &amp;stats.Processing, &amp;stats.Completed, &amp;stats.Failed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get stats: %w", err)
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// ChunkEmbeddingQueueStats contains queue statistics
type ChunkEmbeddingQueueStats struct {
        Pending    int64 `json:"pending"`
        Processing int64 `json:"processing"`
        Completed  int64 `json:"completed"`
        Failed     int64 `json:"failed"`
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package extraction

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/logger"
)

// ChunkEmbeddingWorker processes chunk embedding jobs from the queue.
// It follows the same pattern as GraphEmbeddingWorker:
// - Polling-based with configurable interval
// - Graceful shutdown waiting for current batch
// - Stale job recovery on startup
// - Metrics tracking
type ChunkEmbeddingWorker struct {
        jobs      *ChunkEmbeddingJobsService
        embeds    EmbeddingService
        db        bun.IDB
        cfg       *ChunkEmbeddingConfig
        log       *slog.Logger
        stopCh    chan struct{}
        stoppedCh chan struct{}
        running   bool
        mu        sync.Mutex
        wg        sync.WaitGroup

        // Metrics
        processedCount int64
        successCount   int64
        failureCount   int64
        metricsMu      sync.RWMutex
}

// NewChunkEmbeddingWorker creates a new chunk embedding worker
func NewChunkEmbeddingWorker(
        jobs *ChunkEmbeddingJobsService,
        embeds EmbeddingService,
        db bun.IDB,
        cfg *ChunkEmbeddingConfig,
        log *slog.Logger,
) *ChunkEmbeddingWorker <span class="cov8" title="1">{
        return &amp;ChunkEmbeddingWorker{
                jobs:   jobs,
                embeds: embeds,
                db:     db,
                cfg:    cfg,
                log:    log.With(logger.Scope("chunk.embedding.worker")),
        }
}</span>

// Start begins the worker's polling loop
func (w *ChunkEmbeddingWorker) Start(ctx context.Context) error <span class="cov8" title="1">{
        w.mu.Lock()
        if w.running </span><span class="cov0" title="0">{
                w.mu.Unlock()
                return nil
        }</span>

        // Check if embeddings are enabled
        <span class="cov8" title="1">if !w.embeds.IsEnabled() </span><span class="cov8" title="1">{
                w.log.Info("chunk embedding worker not started (embeddings not enabled)")
                w.mu.Unlock()
                return nil
        }</span>

        <span class="cov8" title="1">w.running = true
        w.stopCh = make(chan struct{})
        w.stoppedCh = make(chan struct{})
        w.mu.Unlock()

        // Recover stale jobs on startup
        go w.recoverStaleJobsOnStartup(ctx)

        w.log.Info("chunk embedding worker starting",
                slog.Duration("poll_interval", w.cfg.WorkerInterval()),
                slog.Int("batch_size", w.cfg.WorkerBatchSize))

        w.wg.Add(1)
        go w.run(ctx)

        return nil</span>
}

// Stop gracefully stops the worker, waiting for current batch to complete
func (w *ChunkEmbeddingWorker) Stop(ctx context.Context) error <span class="cov8" title="1">{
        w.mu.Lock()
        if !w.running </span><span class="cov0" title="0">{
                w.mu.Unlock()
                return nil
        }</span>
        <span class="cov8" title="1">w.running = false
        close(w.stopCh)
        w.mu.Unlock()

        w.log.Debug("waiting for chunk embedding worker to stop...")

        // Wait for worker to stop or context to be cancelled
        select </span>{
        case &lt;-w.stoppedCh:<span class="cov8" title="1">
                w.log.Info("chunk embedding worker stopped gracefully")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                w.log.Warn("chunk embedding worker stop timeout, forcing shutdown")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// recoverStaleJobsOnStartup recovers stale jobs on startup
func (w *ChunkEmbeddingWorker) recoverStaleJobsOnStartup(ctx context.Context) <span class="cov8" title="1">{
        recovered, err := w.jobs.RecoverStaleJobs(ctx, 10)
        if err != nil </span><span class="cov8" title="1">{
                w.log.Warn("failed to recover stale jobs on startup",
                        slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov8" title="1">if recovered &gt; 0 </span><span class="cov0" title="0">{
                w.log.Info("recovered stale chunk embedding jobs on startup",
                        slog.Int("count", recovered))
        }</span>
}

// run is the main worker loop
func (w *ChunkEmbeddingWorker) run(ctx context.Context) <span class="cov8" title="1">{
        defer w.wg.Done()
        defer close(w.stoppedCh)

        ticker := time.NewTicker(w.cfg.WorkerInterval())
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov8" title="1">
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if err := w.processBatch(ctx); err != nil </span><span class="cov0" title="0">{
                                w.log.Warn("process batch failed", slog.String("error", err.Error()))
                        }</span>
                }
        }
}

// processBatch processes a batch of chunk embedding jobs
func (w *ChunkEmbeddingWorker) processBatch(ctx context.Context) error <span class="cov8" title="1">{
        // Check if we should stop
        select </span>{
        case &lt;-w.stopCh:<span class="cov8" title="1">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">jobs, err := w.jobs.Dequeue(ctx, w.cfg.WorkerBatchSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(jobs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, job := range jobs </span><span class="cov8" title="1">{
                if err := w.processJob(ctx, job); err != nil </span><span class="cov8" title="1">{
                        w.log.Warn("process job failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", err.Error()))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// chunkRow represents the minimal data needed from a chunk for embedding
type chunkRow struct {
        ID         string `bun:"id,type:uuid"`
        DocumentID string `bun:"document_id,type:uuid"`
        ChunkIndex int    `bun:"chunk_index"`
        Text       string `bun:"text"`
}

// processJob processes a single chunk embedding job
func (w *ChunkEmbeddingWorker) processJob(ctx context.Context, job *ChunkEmbeddingJob) error <span class="cov8" title="1">{
        startTime := time.Now()

        // Fetch the chunk
        chunk := &amp;chunkRow{}
        err := w.db.NewSelect().
                TableExpr("kb.chunks").
                Column("id", "document_id", "chunk_index", "text").
                Where("id = ?", job.ChunkID).
                Scan(ctx, chunk)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                // Chunk doesn't exist, mark as failed
                if markErr := w.jobs.MarkFailed(ctx, job.ID, fmt.Errorf("chunk_missing")); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov0" title="0">w.incrementFailure()
                return fmt.Errorf("chunk not found: %s", job.ChunkID)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                // Database error
                if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov0" title="0">w.incrementFailure()
                return fmt.Errorf("fetch chunk: %w", err)</span>
        }

        <span class="cov8" title="1">textLength := len(chunk.Text)

        // Generate embedding
        embeddingStartTime := time.Now()
        result, err := w.embeds.EmbedQueryWithUsage(ctx, chunk.Text)
        embeddingDurationMs := time.Since(embeddingStartTime).Milliseconds()

        if err != nil </span><span class="cov8" title="1">{
                // Embedding failed
                if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov8" title="1">w.incrementFailure()
                return fmt.Errorf("generate embedding: %w", err)</span>
        }

        <span class="cov8" title="1">if result == nil || len(result.Embedding) == 0 </span><span class="cov0" title="0">{
                // No embedding returned (likely noop client)
                err := fmt.Errorf("no embedding returned")
                if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov0" title="0">w.incrementFailure()
                return err</span>
        }

        // Update the chunk with the embedding
        // Note: embedding is vector(768), we need to use raw SQL for pgvector
        <span class="cov8" title="1">now := time.Now()
        _, err = w.db.NewRaw(`UPDATE kb.chunks 
                SET embedding = ?::vector, 
                        updated_at = ?
                WHERE id = ?`,
                vectorToString(result.Embedding), now, job.ChunkID).Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                // Update failed
                if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov0" title="0">w.incrementFailure()
                return fmt.Errorf("update embedding: %w", err)</span>
        }

        // Mark job as completed
        <span class="cov8" title="1">if err := w.jobs.MarkCompleted(ctx, job.ID); err != nil </span><span class="cov0" title="0">{
                w.log.Error("failed to mark job as completed",
                        slog.String("job_id", job.ID),
                        slog.String("error", err.Error()))
                return err
        }</span>

        <span class="cov8" title="1">totalDurationMs := time.Since(startTime).Milliseconds()

        w.log.Debug("generated embedding for chunk",
                slog.String("chunk_id", chunk.ID),
                slog.String("document_id", chunk.DocumentID),
                slog.Int("chunk_index", chunk.ChunkIndex),
                slog.Int("embedding_dims", len(result.Embedding)),
                slog.Int("text_length", textLength),
                slog.Int64("embedding_duration_ms", embeddingDurationMs),
                slog.Int64("total_duration_ms", totalDurationMs))

        w.incrementSuccess()
        return nil</span>
}

// incrementSuccess increments both processed and success counters
func (w *ChunkEmbeddingWorker) incrementSuccess() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.successCount++
        w.metricsMu.Unlock()
}</span>

// incrementFailure increments both processed and failure counters
func (w *ChunkEmbeddingWorker) incrementFailure() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.failureCount++
        w.metricsMu.Unlock()
}</span>

// Metrics returns current worker metrics
func (w *ChunkEmbeddingWorker) Metrics() ChunkEmbeddingWorkerMetrics <span class="cov8" title="1">{
        w.metricsMu.RLock()
        defer w.metricsMu.RUnlock()

        return ChunkEmbeddingWorkerMetrics{
                Processed: w.processedCount,
                Succeeded: w.successCount,
                Failed:    w.failureCount,
        }
}</span>

// ChunkEmbeddingWorkerMetrics contains worker metrics
type ChunkEmbeddingWorkerMetrics struct {
        Processed int64 `json:"processed"`
        Succeeded int64 `json:"succeeded"`
        Failed    int64 `json:"failed"`
}

// IsRunning returns whether the worker is currently running
func (w *ChunkEmbeddingWorker) IsRunning() bool <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        return w.running
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package extraction

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "math"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/logger"
)

// DocumentParsingJobsService manages the document parsing job queue.
// It provides methods to create, dequeue, and manage parsing jobs for documents.
//
// Key features:
// - Create jobs with organization/project scoping
// - Atomic dequeue with FOR UPDATE SKIP LOCKED
// - Retry with exponential backoff (limited by maxRetries)
// - Retry-pending status for scheduled retries
// - Stale job recovery
// - Queue statistics
//
// Unlike embedding jobs, parsing jobs use maxRetries to limit retry attempts.
type DocumentParsingJobsService struct {
        db  bun.IDB
        log *slog.Logger
        cfg *DocumentParsingConfig
}

// DocumentParsingConfig contains configuration for document parsing jobs
type DocumentParsingConfig struct {
        // BaseRetryDelayMs is the base delay in milliseconds for retries (default: 10000)
        BaseRetryDelayMs int
        // MaxRetryDelayMs is the maximum delay in milliseconds (default: 300000 = 5 minutes)
        MaxRetryDelayMs int
        // RetryMultiplier is the exponential backoff multiplier (default: 3)
        RetryMultiplier float64
        // DefaultMaxRetries is the default max retries for new jobs (default: 3)
        DefaultMaxRetries int
        // WorkerIntervalMs is the polling interval in milliseconds (default: 5000)
        WorkerIntervalMs int
        // WorkerBatchSize is the number of jobs to process per poll (default: 5)
        WorkerBatchSize int
        // StaleThresholdMinutes is the threshold for considering a job stale (default: 10)
        StaleThresholdMinutes int
}

// DefaultDocumentParsingConfig returns default configuration
func DefaultDocumentParsingConfig() *DocumentParsingConfig <span class="cov8" title="1">{
        return &amp;DocumentParsingConfig{
                BaseRetryDelayMs:      10000,  // 10 seconds
                MaxRetryDelayMs:       300000, // 5 minutes
                RetryMultiplier:       3.0,
                DefaultMaxRetries:     3,
                WorkerIntervalMs:      5000,
                WorkerBatchSize:       5,
                StaleThresholdMinutes: 10,
        }
}</span>

// WorkerInterval returns the worker interval as a Duration
func (c *DocumentParsingConfig) WorkerInterval() time.Duration <span class="cov8" title="1">{
        return time.Duration(c.WorkerIntervalMs) * time.Millisecond
}</span>

// NewDocumentParsingJobsService creates a new document parsing jobs service
func NewDocumentParsingJobsService(db bun.IDB, log *slog.Logger, cfg *DocumentParsingConfig) *DocumentParsingJobsService <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov0" title="0">{
                cfg = DefaultDocumentParsingConfig()
        }</span>
        <span class="cov8" title="1">return &amp;DocumentParsingJobsService{
                db:  db,
                log: log.With(logger.Scope("document.parsing.jobs")),
                cfg: cfg,
        }</span>
}

// CreateJobOptions contains options for creating a document parsing job
type CreateJobOptions struct {
        OrganizationID   string                 // Required: the organization ID
        ProjectID        string                 // Required: the project ID
        SourceType       string                 // Required: 'file_upload', 'web_page', etc.
        SourceFilename   *string                // Optional: original filename
        MimeType         *string                // Optional: MIME type
        FileSizeBytes    *int64                 // Optional: file size in bytes
        StorageKey       *string                // Optional: S3/MinIO storage key
        DocumentID       *string                // Optional: existing document ID
        ExtractionJobID  *string                // Optional: linked extraction job ID
        Metadata         map[string]interface{} // Optional: additional metadata
        MaxRetries       *int                   // Optional: override default max retries
}

// CreateJob creates a new document parsing job.
func (s *DocumentParsingJobsService) CreateJob(ctx context.Context, opts CreateJobOptions) (*DocumentParsingJob, error) <span class="cov8" title="1">{
        maxRetries := s.cfg.DefaultMaxRetries
        if opts.MaxRetries != nil </span><span class="cov8" title="1">{
                maxRetries = *opts.MaxRetries
        }</span>

        <span class="cov8" title="1">metadata := opts.Metadata
        if metadata == nil </span><span class="cov8" title="1">{
                metadata = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">job := &amp;DocumentParsingJob{
                OrganizationID:  opts.OrganizationID,
                ProjectID:       opts.ProjectID,
                Status:          JobStatusPending,
                SourceType:      opts.SourceType,
                SourceFilename:  opts.SourceFilename,
                MimeType:        opts.MimeType,
                FileSizeBytes:   opts.FileSizeBytes,
                StorageKey:      opts.StorageKey,
                DocumentID:      opts.DocumentID,
                ExtractionJobID: opts.ExtractionJobID,
                Metadata:        JSON(metadata),
                RetryCount:      0,
                MaxRetries:      maxRetries,
        }

        _, err := s.db.NewInsert().
                Model(job).
                Returning("*").
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create document parsing job: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Debug("created document parsing job",
                slog.String("job_id", job.ID),
                slog.String("source_type", job.SourceType),
                slog.String("source_filename", ptrToString(job.SourceFilename)))

        return job, nil</span>
}

// Dequeue atomically claims jobs for processing.
// Uses PostgreSQL's FOR UPDATE SKIP LOCKED for concurrent workers.
// Includes both 'pending' jobs and 'retry_pending' jobs whose nextRetryAt has passed.
func (s *DocumentParsingJobsService) Dequeue(ctx context.Context, batchSize int) ([]*DocumentParsingJob, error) <span class="cov8" title="1">{
        if batchSize &lt;= 0 </span><span class="cov0" title="0">{
                batchSize = s.cfg.WorkerBatchSize
        }</span>

        <span class="cov8" title="1">var jobs []*DocumentParsingJob

        // Strategic SQL: FOR UPDATE SKIP LOCKED for concurrent workers
        // Include retry_pending jobs whose nextRetryAt has passed
        err := s.db.NewRaw(`WITH cte AS (
                SELECT id FROM kb.document_parsing_jobs
                WHERE (status = 'pending')
                   OR (status = 'retry_pending' AND next_retry_at &lt;= now())
                ORDER BY created_at ASC
                FOR UPDATE SKIP LOCKED
                LIMIT ?
        )
        UPDATE kb.document_parsing_jobs j 
        SET status = 'processing', 
                started_at = now(),
                updated_at = now()
        FROM cte WHERE j.id = cte.id
        RETURNING j.*`, batchSize).Scan(ctx, &amp;jobs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dequeue document parsing jobs: %w", err)
        }</span>

        <span class="cov8" title="1">if len(jobs) &gt; 0 </span><span class="cov8" title="1">{
                s.log.Debug("dequeued document parsing jobs", slog.Int("count", len(jobs)))
        }</span>

        <span class="cov8" title="1">return jobs, nil</span>
}

// MarkCompleted marks a job as successfully completed with parsed content
func (s *DocumentParsingJobsService) MarkCompleted(ctx context.Context, id string, result MarkCompletedResult) error <span class="cov8" title="1">{
        now := time.Now()

        // Build metadata update
        metadata := result.Metadata
        if metadata == nil </span><span class="cov8" title="1">{
                metadata = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">metadata["completedAt"] = now.Format(time.RFC3339)
        if result.ParsedContent != "" </span><span class="cov8" title="1">{
                metadata["characterCount"] = len(result.ParsedContent)
        }</span>

        <span class="cov8" title="1">_, err := s.db.NewUpdate().
                Model((*DocumentParsingJob)(nil)).
                Set("status = ?", JobStatusCompleted).
                Set("parsed_content = ?", result.ParsedContent).
                Set("document_id = ?", result.DocumentID).
                Set("metadata = metadata || ?::jsonb", metadata).
                Set("completed_at = ?", now).
                Set("error_message = NULL").
                Set("updated_at = ?", now).
                Where("id = ?", id).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mark completed: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Debug("document parsing job completed",
                slog.String("job_id", id),
                slog.Int("content_length", len(result.ParsedContent)))
        return nil</span>
}

// MarkCompletedResult contains the result of a completed parsing job
type MarkCompletedResult struct {
        ParsedContent string                 // The extracted text content
        DocumentID    *string                // The created/updated document ID
        Metadata      map[string]interface{} // Additional metadata to store
}

// MarkFailed marks a job as failed and schedules retry if retries remain.
// Uses exponential backoff with the configured multiplier.
func (s *DocumentParsingJobsService) MarkFailed(ctx context.Context, id string, jobErr error) error <span class="cov8" title="1">{
        job := &amp;DocumentParsingJob{}
        err := s.db.NewSelect().
                Model(job).
                Column("id", "retry_count", "max_retries", "metadata").
                Where("id = ?", id).
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        s.log.Warn("document parsing job not found when marking as failed", slog.String("job_id", id))
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("get job for mark failed: %w", err)</span>
        }

        <span class="cov8" title="1">errorMessage := truncateError(jobErr.Error())
        shouldRetry := job.RetryCount &lt; job.MaxRetries

        if shouldRetry </span><span class="cov8" title="1">{
                // Schedule retry with exponential backoff
                delayMs := s.calculateRetryDelay(job.RetryCount)
                nextRetryAt := time.Now().Add(time.Duration(delayMs) * time.Millisecond)

                // Update metadata with retry info
                metadata := map[string]interface{}{
                        "lastError":    errorMessage,
                        "lastFailedAt": time.Now().Format(time.RFC3339),
                }

                _, updateErr := s.db.NewUpdate().
                        Model((*DocumentParsingJob)(nil)).
                        Set("status = 'retry_pending'").
                        Set("error_message = ?", errorMessage).
                        Set("retry_count = retry_count + 1").
                        Set("next_retry_at = ?", nextRetryAt).
                        Set("metadata = metadata || ?::jsonb", metadata).
                        Set("updated_at = now()").
                        Where("id = ?", id).
                        Exec(ctx)
                if updateErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("schedule retry: %w", updateErr)
                }</span>

                <span class="cov8" title="1">s.log.Warn("document parsing job failed, scheduled retry",
                        slog.String("job_id", id),
                        slog.Int("retry", job.RetryCount+1),
                        slog.Int("max_retries", job.MaxRetries),
                        slog.Time("next_retry_at", nextRetryAt),
                        slog.String("error", errorMessage))</span>
        } else<span class="cov8" title="1"> {
                // No more retries - mark as dead letter
                metadata := map[string]interface{}{
                        "lastError": errorMessage,
                        "failedAt":  time.Now().Format(time.RFC3339),
                }

                _, updateErr := s.db.NewUpdate().
                        Model((*DocumentParsingJob)(nil)).
                        Set("status = ?", JobStatusDeadLetter).
                        Set("error_message = ?", errorMessage).
                        Set("completed_at = now()").
                        Set("metadata = metadata || ?::jsonb", metadata).
                        Set("updated_at = now()").
                        Where("id = ?", id).
                        Exec(ctx)
                if updateErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("mark as dead letter: %w", updateErr)
                }</span>

                <span class="cov8" title="1">s.log.Error("document parsing job moved to dead letter queue",
                        slog.String("job_id", id),
                        slog.Int("attempts", job.RetryCount+1),
                        slog.String("error", errorMessage))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// RecoverStaleJobs recovers jobs stuck in 'processing' status.
// This can happen when the server restarts while jobs are being processed.
func (s *DocumentParsingJobsService) RecoverStaleJobs(ctx context.Context, staleThresholdMinutes int) (int, error) <span class="cov8" title="1">{
        if staleThresholdMinutes &lt;= 0 </span><span class="cov0" title="0">{
                staleThresholdMinutes = s.cfg.StaleThresholdMinutes
        }</span>

        <span class="cov8" title="1">result, err := s.db.NewRaw(`UPDATE kb.document_parsing_jobs 
                SET status = 'pending', 
                        started_at = NULL,
                        updated_at = now()
                WHERE status = 'processing' 
                        AND started_at &lt; now() - (? || ' minutes')::interval`,
                fmt.Sprintf("%d", staleThresholdMinutes)).Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("recover stale jobs: %w", err)
        }</span>

        <span class="cov8" title="1">count, _ := result.RowsAffected()

        if count &gt; 0 </span><span class="cov8" title="1">{
                s.log.Warn("recovered stale document parsing jobs",
                        slog.Int64("count", count),
                        slog.Int("threshold_minutes", staleThresholdMinutes))
        }</span>

        <span class="cov8" title="1">return int(count), nil</span>
}

// GetJob retrieves a job by ID
func (s *DocumentParsingJobsService) GetJob(ctx context.Context, id string) (*DocumentParsingJob, error) <span class="cov8" title="1">{
        job := &amp;DocumentParsingJob{}
        err := s.db.NewSelect().
                Model(job).
                Where("id = ?", id).
                Scan(ctx)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get job: %w", err)
        }</span>

        <span class="cov8" title="1">return job, nil</span>
}

// FindByProject returns jobs for a project with pagination
func (s *DocumentParsingJobsService) FindByProject(ctx context.Context, projectID string, limit, offset int) ([]*DocumentParsingJob, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>

        <span class="cov8" title="1">var jobs []*DocumentParsingJob
        err := s.db.NewSelect().
                Model(&amp;jobs).
                Where("project_id = ?", projectID).
                Order("created_at DESC").
                Limit(limit).
                Offset(offset).
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("find by project: %w", err)
        }</span>

        <span class="cov8" title="1">return jobs, nil</span>
}

// FindByStatus returns jobs with a specific status
func (s *DocumentParsingJobsService) FindByStatus(ctx context.Context, status JobStatus, limit int) ([]*DocumentParsingJob, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov8" title="1">var jobs []*DocumentParsingJob
        err := s.db.NewSelect().
                Model(&amp;jobs).
                Where("status = ?", status).
                Order("created_at ASC").
                Limit(limit).
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("find by status: %w", err)
        }</span>

        <span class="cov8" title="1">return jobs, nil</span>
}

// FindByDocumentID returns jobs associated with a document
func (s *DocumentParsingJobsService) FindByDocumentID(ctx context.Context, documentID string) ([]*DocumentParsingJob, error) <span class="cov8" title="1">{
        var jobs []*DocumentParsingJob
        err := s.db.NewSelect().
                Model(&amp;jobs).
                Where("document_id = ?", documentID).
                Order("created_at DESC").
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("find by document: %w", err)
        }</span>

        <span class="cov8" title="1">return jobs, nil</span>
}

// CancelJobsForDocument cancels pending/processing jobs for a document
func (s *DocumentParsingJobsService) CancelJobsForDocument(ctx context.Context, documentID string) (int, error) <span class="cov8" title="1">{
        result, err := s.db.NewUpdate().
                Model((*DocumentParsingJob)(nil)).
                Set("status = ?", JobStatusFailed).
                Set("error_message = 'Cancelled by user'").
                Set("completed_at = now()").
                Set("updated_at = now()").
                Where("document_id = ?", documentID).
                Where("status IN ('pending', 'processing', 'retry_pending')").
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("cancel jobs for document: %w", err)
        }</span>

        <span class="cov8" title="1">count, _ := result.RowsAffected()

        if count &gt; 0 </span><span class="cov8" title="1">{
                s.log.Info("cancelled parsing jobs for document",
                        slog.String("document_id", documentID),
                        slog.Int64("count", count))
        }</span>

        <span class="cov8" title="1">return int(count), nil</span>
}

// UpdateStatus updates a job's status with optional field updates
func (s *DocumentParsingJobsService) UpdateStatus(ctx context.Context, id string, status JobStatus, updates *JobStatusUpdates) error <span class="cov8" title="1">{
        query := s.db.NewUpdate().
                Model((*DocumentParsingJob)(nil)).
                Set("status = ?", status).
                Set("updated_at = now()").
                Where("id = ?", id)

        if updates != nil </span><span class="cov8" title="1">{
                if updates.ParsedContent != nil </span><span class="cov8" title="1">{
                        query = query.Set("parsed_content = ?", *updates.ParsedContent)
                }</span>
                <span class="cov8" title="1">if updates.ErrorMessage != nil </span><span class="cov0" title="0">{
                        query = query.Set("error_message = ?", *updates.ErrorMessage)
                }</span>
                <span class="cov8" title="1">if updates.DocumentID != nil </span><span class="cov0" title="0">{
                        query = query.Set("document_id = ?", *updates.DocumentID)
                }</span>
                <span class="cov8" title="1">if updates.Metadata != nil </span><span class="cov8" title="1">{
                        query = query.Set("metadata = metadata || ?::jsonb", updates.Metadata)
                }</span>
        }

        <span class="cov8" title="1">_, err := query.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update status: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// JobStatusUpdates contains optional updates when changing job status
type JobStatusUpdates struct {
        ParsedContent *string
        ErrorMessage  *string
        DocumentID    *string
        Metadata      map[string]interface{}
}

// Stats returns queue statistics
func (s *DocumentParsingJobsService) Stats(ctx context.Context) (*DocumentParsingQueueStats, error) <span class="cov8" title="1">{
        stats := &amp;DocumentParsingQueueStats{}

        err := s.db.NewRaw(`SELECT 
                COUNT(*) FILTER (WHERE status = 'pending') as pending,
                COUNT(*) FILTER (WHERE status = 'processing') as processing,
                COUNT(*) FILTER (WHERE status = 'retry_pending') as retry_pending,
                COUNT(*) FILTER (WHERE status = 'completed') as completed,
                COUNT(*) FILTER (WHERE status = 'failed') as failed
        FROM kb.document_parsing_jobs`).Scan(ctx,
                &amp;stats.Pending, &amp;stats.Processing, &amp;stats.RetryPending, &amp;stats.Completed, &amp;stats.Failed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get stats: %w", err)
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// DocumentParsingQueueStats contains queue statistics
type DocumentParsingQueueStats struct {
        Pending      int64 `json:"pending"`
        Processing   int64 `json:"processing"`
        RetryPending int64 `json:"retryPending"`
        Completed    int64 `json:"completed"`
        Failed       int64 `json:"failed"`
}

// calculateRetryDelay calculates the retry delay using exponential backoff.
// Formula: base * multiplier^retryCount, capped at max
func (s *DocumentParsingJobsService) calculateRetryDelay(retryCount int) int <span class="cov8" title="1">{
        delay := float64(s.cfg.BaseRetryDelayMs) * math.Pow(s.cfg.RetryMultiplier, float64(retryCount))
        if delay &gt; float64(s.cfg.MaxRetryDelayMs) </span><span class="cov8" title="1">{
                delay = float64(s.cfg.MaxRetryDelayMs)
        }</span>
        <span class="cov8" title="1">return int(delay)</span>
}

// ptrToString safely converts a string pointer to string for logging
func ptrToString(s *string) string <span class="cov8" title="1">{
        if s == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return *s</span>
}

// RetryPendingStatus is the status value for jobs waiting for retry
const RetryPendingStatus JobStatus = "retry_pending"
</pre>
		
		<pre class="file" id="file48" style="display: none">package extraction

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "sync"
        "time"

        "github.com/emergent/emergent-core/internal/storage"
        "github.com/emergent/emergent-core/pkg/kreuzberg"
        "github.com/emergent/emergent-core/pkg/logger"
)

// DocumentParsingWorker processes document parsing jobs.
// It polls for pending jobs, downloads documents from storage,
// sends them to Kreuzberg for text extraction, and stores the results.
type DocumentParsingWorker struct {
        log             *slog.Logger
        jobsService     *DocumentParsingJobsService
        kreuzbergClient *kreuzberg.Client
        storageService  *storage.Service

        // Polling configuration
        interval  time.Duration
        batchSize int

        // Shutdown control
        stopCh   chan struct{}
        doneCh   chan struct{}
        stopOnce sync.Once
}

// DocumentParsingWorkerConfig contains configuration for the worker
type DocumentParsingWorkerConfig struct {
        Interval  time.Duration
        BatchSize int
}

// NewDocumentParsingWorker creates a new document parsing worker
func NewDocumentParsingWorker(
        jobsService *DocumentParsingJobsService,
        kreuzbergClient *kreuzberg.Client,
        storageService *storage.Service,
        cfg *DocumentParsingWorkerConfig,
        log *slog.Logger,
) *DocumentParsingWorker <span class="cov0" title="0">{
        interval := 5 * time.Second
        batchSize := 5
        if cfg != nil </span><span class="cov0" title="0">{
                if cfg.Interval &gt; 0 </span><span class="cov0" title="0">{
                        interval = cfg.Interval
                }</span>
                <span class="cov0" title="0">if cfg.BatchSize &gt; 0 </span><span class="cov0" title="0">{
                        batchSize = cfg.BatchSize
                }</span>
        }

        <span class="cov0" title="0">return &amp;DocumentParsingWorker{
                log:              log.With(logger.Scope("document.parsing.worker")),
                jobsService:      jobsService,
                kreuzbergClient:  kreuzbergClient,
                storageService:   storageService,
                interval:         interval,
                batchSize:        batchSize,
                stopCh:           make(chan struct{}),
                doneCh:           make(chan struct{}),
        }</span>
}

// Start begins the worker polling loop
func (w *DocumentParsingWorker) Start() <span class="cov0" title="0">{
        w.log.Info("starting document parsing worker",
                slog.Duration("interval", w.interval),
                slog.Int("batch_size", w.batchSize),
        )

        // Recover any stale jobs on startup
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        recovered, err := w.jobsService.RecoverStaleJobs(ctx, 0)
        cancel()
        if err != nil </span><span class="cov0" title="0">{
                w.log.Error("failed to recover stale jobs", logger.Error(err))
        }</span> else<span class="cov0" title="0"> if recovered &gt; 0 </span><span class="cov0" title="0">{
                w.log.Info("recovered stale document parsing jobs", slog.Int("count", recovered))
        }</span>

        <span class="cov0" title="0">ticker := time.NewTicker(w.interval)
        defer ticker.Stop()
        defer close(w.doneCh)

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        w.log.Info("document parsing worker stopped")
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        w.poll()</span>
                }
        }
}

// Stop gracefully stops the worker
func (w *DocumentParsingWorker) Stop() <span class="cov0" title="0">{
        w.stopOnce.Do(func() </span><span class="cov0" title="0">{
                w.log.Info("stopping document parsing worker...")
                close(w.stopCh)

                // Wait for completion with timeout
                select </span>{
                case &lt;-w.doneCh:<span class="cov0" title="0">
                        w.log.Info("document parsing worker stopped gracefully")</span>
                case &lt;-time.After(30 * time.Second):<span class="cov0" title="0">
                        w.log.Warn("document parsing worker stop timed out")</span>
                }
        })
}

// poll dequeues and processes a batch of jobs
func (w *DocumentParsingWorker) poll() <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        jobs, err := w.jobsService.Dequeue(ctx, w.batchSize)
        if err != nil </span><span class="cov0" title="0">{
                w.log.Error("failed to dequeue jobs", logger.Error(err))
                return
        }</span>

        <span class="cov0" title="0">if len(jobs) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">w.log.Debug("processing document parsing jobs", slog.Int("count", len(jobs)))

        for _, job := range jobs </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>
                default:<span class="cov0" title="0">
                        w.processJob(ctx, job)</span>
                }
        }
}

// processJob handles a single document parsing job
func (w *DocumentParsingWorker) processJob(ctx context.Context, job *DocumentParsingJob) <span class="cov0" title="0">{
        startTime := time.Now()
        jobLog := w.log.With(
                slog.String("job_id", job.ID),
                slog.String("source_type", job.SourceType),
                slog.String("filename", ptrToString(job.SourceFilename)),
        )

        jobLog.Info("processing document parsing job")

        // Determine how to process the document
        mimeType := ptrToString(job.MimeType)
        filename := ptrToString(job.SourceFilename)
        storageKey := ptrToString(job.StorageKey)

        // Check if storage key is available
        if storageKey == "" </span><span class="cov0" title="0">{
                err := fmt.Errorf("no storage key for document parsing job")
                jobLog.Error("job missing storage key", logger.Error(err))
                w.markFailed(ctx, job, err)
                return
        }</span>

        // Check processing path
        <span class="cov0" title="0">isEmail := kreuzberg.IsEmailFile(mimeType, filename)
        useKreuzberg := !isEmail &amp;&amp; kreuzberg.ShouldUseKreuzberg(mimeType, filename)

        var parsedContent string
        var extractionMethod string
        var err error

        if isEmail </span><span class="cov0" title="0">{
                // Email files - use native email parser (not yet implemented in Go)
                // For now, mark as failed with clear message
                err = fmt.Errorf("email parsing not yet implemented in Go server")
                jobLog.Warn("email parsing not implemented", slog.String("mime_type", mimeType))
                w.markFailed(ctx, job, err)
                return
        }</span> else<span class="cov0" title="0"> if useKreuzberg </span><span class="cov0" title="0">{
                // Binary document - use Kreuzberg for extraction
                parsedContent, err = w.extractWithKreuzberg(ctx, storageKey, filename, mimeType)
                extractionMethod = "kreuzberg"
        }</span> else<span class="cov0" title="0"> {
                // Plain text - read directly from storage
                parsedContent, err = w.extractPlainText(ctx, storageKey)
                extractionMethod = "plain_text"
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                jobLog.Error("document extraction failed",
                        slog.String("method", extractionMethod),
                        logger.Error(err),
                )
                w.markFailed(ctx, job, err)
                return
        }</span>

        // Mark job as completed
        <span class="cov0" title="0">result := MarkCompletedResult{
                ParsedContent: parsedContent,
                DocumentID:    job.DocumentID,
                Metadata: map[string]interface{}{
                        "extractionMethod": extractionMethod,
                        "processingTimeMs": time.Since(startTime).Milliseconds(),
                },
        }

        if err := w.jobsService.MarkCompleted(ctx, job.ID, result); err != nil </span><span class="cov0" title="0">{
                jobLog.Error("failed to mark job completed", logger.Error(err))
                return
        }</span>

        <span class="cov0" title="0">jobLog.Info("document parsing completed",
                slog.String("method", extractionMethod),
                slog.Int("content_length", len(parsedContent)),
                slog.Duration("duration", time.Since(startTime)),
        )</span>
}

// extractWithKreuzberg downloads a file and sends it to Kreuzberg for extraction
func (w *DocumentParsingWorker) extractWithKreuzberg(ctx context.Context, storageKey, filename, mimeType string) (string, error) <span class="cov0" title="0">{
        // Download file from storage
        content, err := w.downloadFile(ctx, storageKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("download file: %w", err)
        }</span>

        // Send to Kreuzberg
        <span class="cov0" title="0">result, err := w.kreuzbergClient.ExtractText(ctx, content, filename, mimeType, nil)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("kreuzberg extraction: %w", err)
        }</span>

        <span class="cov0" title="0">return result.Content, nil</span>
}

// extractPlainText downloads a plain text file directly
func (w *DocumentParsingWorker) extractPlainText(ctx context.Context, storageKey string) (string, error) <span class="cov0" title="0">{
        content, err := w.downloadFile(ctx, storageKey)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("download file: %w", err)
        }</span>

        <span class="cov0" title="0">return string(content), nil</span>
}

// downloadFile downloads a file from storage
func (w *DocumentParsingWorker) downloadFile(ctx context.Context, storageKey string) ([]byte, error) <span class="cov0" title="0">{
        if !w.storageService.Enabled() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("storage service not enabled")
        }</span>

        <span class="cov0" title="0">reader, err := w.storageService.Download(ctx, storageKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("download from storage: %w", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        content, err := io.ReadAll(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read file content: %w", err)
        }</span>

        <span class="cov0" title="0">return content, nil</span>
}

// markFailed marks a job as failed
func (w *DocumentParsingWorker) markFailed(ctx context.Context, job *DocumentParsingJob, err error) <span class="cov0" title="0">{
        if markErr := w.jobsService.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                w.log.Error("failed to mark job as failed",
                        slog.String("job_id", job.ID),
                        logger.Error(markErr),
                )
        }</span>
}

// JobsService returns the underlying jobs service for testing/management
func (w *DocumentParsingWorker) JobsService() *DocumentParsingJobsService <span class="cov0" title="0">{
        return w.jobsService
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package extraction

import (
        "encoding/json"
        "time"

        "github.com/uptrace/bun"
)

// JobStatus represents the processing status of an extraction job
type JobStatus string

const (
        JobStatusPending    JobStatus = "pending"
        JobStatusProcessing JobStatus = "processing"
        JobStatusCompleted  JobStatus = "completed"
        JobStatusFailed     JobStatus = "failed"
        JobStatusCancelled  JobStatus = "cancelled"
        JobStatusDeadLetter JobStatus = "dead_letter" // Permanently failed after max retries
)

// ------------------------------------------------------------------
// DocumentParsingJob - Parses uploaded documents (PDF, DOCX, etc.)
// ------------------------------------------------------------------

// DocumentParsingJob represents a document parsing job in kb.document_parsing_jobs.
// These jobs parse uploaded files and extract text content.
type DocumentParsingJob struct {
        bun.BaseModel `bun:"table:kb.document_parsing_jobs,alias:dpj"`

        ID               string     `bun:"id,pk,type:uuid,default:gen_random_uuid()"`
        OrganizationID   string     `bun:"organization_id,notnull,type:uuid"`
        ProjectID        string     `bun:"project_id,notnull,type:uuid"`
        Status           JobStatus  `bun:"status,notnull,default:'pending'"`
        SourceType       string     `bun:"source_type,notnull"`         // 'file_upload', 'web_page', etc.
        SourceFilename   *string    `bun:"source_filename"`             // Original filename
        MimeType         *string    `bun:"mime_type"`                   // e.g., 'application/pdf'
        FileSizeBytes    *int64     `bun:"file_size_bytes"`
        StorageKey       *string    `bun:"storage_key"`                 // S3/MinIO object key
        DocumentID       *string    `bun:"document_id,type:uuid"`       // Created document ID after parsing
        ExtractionJobID  *string    `bun:"extraction_job_id,type:uuid"` // Linked extraction job
        ParsedContent    *string    `bun:"parsed_content"`              // Extracted text
        Metadata         JSON       `bun:"metadata,type:jsonb,default:'{}'"`
        ErrorMessage     *string    `bun:"error_message"`
        RetryCount       int        `bun:"retry_count,default:0"`
        MaxRetries       int        `bun:"max_retries,default:3"`
        NextRetryAt      *time.Time `bun:"next_retry_at"`
        CreatedAt        time.Time  `bun:"created_at,notnull,default:now()"`
        StartedAt        *time.Time `bun:"started_at"`
        CompletedAt      *time.Time `bun:"completed_at"`
        UpdatedAt        time.Time  `bun:"updated_at,notnull,default:now()"`
}

// ------------------------------------------------------------------
// ChunkEmbeddingJob - Generates embeddings for document chunks
// ------------------------------------------------------------------

// ChunkEmbeddingJob represents a chunk embedding job in kb.chunk_embedding_jobs.
// These jobs generate vector embeddings for document chunks.
type ChunkEmbeddingJob struct {
        bun.BaseModel `bun:"table:kb.chunk_embedding_jobs,alias:cej"`

        ID           string     `bun:"id,pk,type:uuid,default:uuid_generate_v4()"`
        ChunkID      string     `bun:"chunk_id,notnull,type:uuid"` // Reference to kb.chunks
        Status       JobStatus  `bun:"status,notnull,default:'pending'"`
        AttemptCount int        `bun:"attempt_count,notnull,default:0"`
        LastError    *string    `bun:"last_error"`
        Priority     int        `bun:"priority,notnull,default:0"`
        ScheduledAt  time.Time  `bun:"scheduled_at,notnull,default:now()"`
        StartedAt    *time.Time `bun:"started_at"`
        CompletedAt  *time.Time `bun:"completed_at"`
        CreatedAt    time.Time  `bun:"created_at,notnull,default:now()"`
        UpdatedAt    time.Time  `bun:"updated_at,notnull,default:now()"`
}

// ------------------------------------------------------------------
// GraphEmbeddingJob - Generates embeddings for graph objects
// ------------------------------------------------------------------

// GraphEmbeddingJob represents a graph embedding job in kb.graph_embedding_jobs.
// These jobs generate vector embeddings for graph objects (entities).
type GraphEmbeddingJob struct {
        bun.BaseModel `bun:"table:kb.graph_embedding_jobs,alias:gej"`

        ID           string     `bun:"id,pk,type:uuid,default:uuid_generate_v4()"`
        ObjectID     string     `bun:"object_id,notnull,type:uuid"` // Reference to kb.graph_objects
        Status       JobStatus  `bun:"status,notnull"`
        AttemptCount int        `bun:"attempt_count,notnull,default:0"`
        LastError    *string    `bun:"last_error"`
        Priority     int        `bun:"priority,notnull,default:0"`
        ScheduledAt  time.Time  `bun:"scheduled_at,notnull,default:now()"`
        StartedAt    *time.Time `bun:"started_at"`
        CompletedAt  *time.Time `bun:"completed_at"`
        CreatedAt    time.Time  `bun:"created_at,notnull,default:now()"`
        UpdatedAt    time.Time  `bun:"updated_at,notnull,default:now()"`
}

// ------------------------------------------------------------------
// ObjectExtractionJob - Extracts entities/objects from content
// ------------------------------------------------------------------

// JobType represents the type of extraction job
type JobType string

const (
        JobTypeFullExtraction JobType = "full_extraction"
        JobTypeReextraction   JobType = "reextraction"
        JobTypeIncremental    JobType = "incremental"
)

// ObjectExtractionJob represents an object extraction job in kb.object_extraction_jobs.
// These jobs extract structured entities (people, organizations, concepts, etc.) from content.
type ObjectExtractionJob struct {
        bun.BaseModel `bun:"table:kb.object_extraction_jobs,alias:oej"`

        ID                   string       `bun:"id,pk,type:uuid,default:uuid_generate_v4()"`
        ProjectID            string       `bun:"project_id,notnull,type:uuid"`
        DocumentID           *string      `bun:"document_id,type:uuid"`         // Optional: specific document
        ChunkID              *string      `bun:"chunk_id,type:uuid"`            // Optional: specific chunk
        JobType              JobType      `bun:"job_type,notnull,default:'full_extraction'"`
        Status               JobStatus    `bun:"status,notnull,default:'pending'"`
        EnabledTypes         []string     `bun:"enabled_types,array,notnull,default:'{}'"`      // Entity types to extract
        ExtractionConfig     JSON         `bun:"extraction_config,type:jsonb,notnull,default:'{}'"` // LLM/extraction settings
        ObjectsCreated       int          `bun:"objects_created,notnull,default:0"`
        RelationshipsCreated int          `bun:"relationships_created,notnull,default:0"`
        SuggestionsCreated   int          `bun:"suggestions_created,notnull,default:0"`
        TotalItems           int          `bun:"total_items,notnull,default:0"`
        ProcessedItems       int          `bun:"processed_items,notnull,default:0"`
        SuccessfulItems      int          `bun:"successful_items,notnull,default:0"`
        FailedItems          int          `bun:"failed_items,notnull,default:0"`
        StartedAt            *time.Time   `bun:"started_at"`
        CompletedAt          *time.Time   `bun:"completed_at"`
        ErrorMessage         *string      `bun:"error_message"`
        ErrorDetails         JSON         `bun:"error_details,type:jsonb"`
        RetryCount           int          `bun:"retry_count,notnull,default:0"`
        MaxRetries           int          `bun:"max_retries,notnull,default:3"`
        CreatedBy            *string      `bun:"created_by,type:uuid"`
        ReprocessingOf       *string      `bun:"reprocessing_of,type:uuid"` // ID of job being reprocessed
        SourceType           *string      `bun:"source_type"`               // 'document', 'chunk', 'manual'
        SourceID             *string      `bun:"source_id"`
        SourceMetadata       JSON         `bun:"source_metadata,type:jsonb,notnull,default:'{}'"`
        DebugInfo            JSON         `bun:"debug_info,type:jsonb"`
        Logs                 JSONArray    `bun:"logs,type:jsonb,notnull,default:'[]'"`
        DiscoveredTypes      JSONArray    `bun:"discovered_types,type:jsonb,default:'[]'"`
        CreatedObjects       JSONArray    `bun:"created_objects,type:jsonb,default:'[]'"`
        CreatedAt            time.Time    `bun:"created_at,notnull,default:now()"`
        UpdatedAt            time.Time    `bun:"updated_at,notnull,default:now()"`
}

// ------------------------------------------------------------------
// DataSourceSyncJob - Syncs data from external sources (ClickUp, etc.)
// ------------------------------------------------------------------

// TriggerType represents what triggered the sync
type TriggerType string

const (
        TriggerTypeManual    TriggerType = "manual"
        TriggerTypeScheduled TriggerType = "scheduled"
        TriggerTypeWebhook   TriggerType = "webhook"
)

// DataSourceSyncJob represents a data source sync job in kb.data_source_sync_jobs.
// These jobs sync data from external integrations (ClickUp, Notion, etc.).
type DataSourceSyncJob struct {
        bun.BaseModel `bun:"table:kb.data_source_sync_jobs,alias:dssj"`

        ID                string      `bun:"id,pk,type:uuid,default:gen_random_uuid()"`
        IntegrationID     string      `bun:"integration_id,notnull,type:uuid"`
        ProjectID         string      `bun:"project_id,notnull,type:uuid"`
        ConfigurationID   *string     `bun:"configuration_id,type:uuid"`
        ConfigurationName *string     `bun:"configuration_name"`
        Status            JobStatus   `bun:"status,notnull,default:'pending'"`
        TotalItems        int         `bun:"total_items,notnull,default:0"`
        ProcessedItems    int         `bun:"processed_items,notnull,default:0"`
        SuccessfulItems   int         `bun:"successful_items,notnull,default:0"`
        FailedItems       int         `bun:"failed_items,notnull,default:0"`
        SkippedItems      int         `bun:"skipped_items,notnull,default:0"`
        CurrentPhase      *string     `bun:"current_phase"` // 'fetching', 'processing', 'embedding', etc.
        StatusMessage     *string     `bun:"status_message"`
        SyncOptions       JSON        `bun:"sync_options,type:jsonb,notnull,default:'{}'"`
        DocumentIDs       JSONArray   `bun:"document_ids,type:jsonb,notnull,default:'[]'"` // Created document IDs
        Logs              JSONArray   `bun:"logs,type:jsonb,notnull,default:'[]'"`
        ErrorMessage      *string     `bun:"error_message"`
        ErrorDetails      JSON        `bun:"error_details,type:jsonb"`
        TriggeredBy       *string     `bun:"triggered_by,type:uuid"` // User who triggered
        TriggerType       TriggerType `bun:"trigger_type,notnull,default:'manual'"`
        CreatedAt         time.Time   `bun:"created_at,notnull,default:now()"`
        StartedAt         *time.Time  `bun:"started_at"`
        CompletedAt       *time.Time  `bun:"completed_at"`
        UpdatedAt         time.Time   `bun:"updated_at,notnull,default:now()"`
}

// ------------------------------------------------------------------
// Helper types
// ------------------------------------------------------------------

// JSON is a helper type for JSONB columns (objects)
type JSON map[string]interface{}

// Scan implements sql.Scanner for JSON
func (j *JSON) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                *j = nil
                return nil
        }</span>
        <span class="cov8" title="1">bytes, ok := value.([]byte)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(bytes, j)</span>
}

// JSONArray is a helper type for JSONB columns that store arrays
type JSONArray []interface{}

// Scan implements sql.Scanner for JSONArray
func (j *JSONArray) Scan(value interface{}) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                *j = nil
                return nil
        }</span>
        <span class="cov8" title="1">bytes, ok := value.([]byte)
        if !ok </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(bytes, j)</span>
}

// LogEntry represents a log entry in job logs
type LogEntry struct {
        Timestamp time.Time `json:"timestamp"`
        Level     string    `json:"level"` // info, warn, error
        Message   string    `json:"message"`
        Details   JSON      `json:"details,omitempty"`
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package extraction

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "math"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/logger"
)

// GraphEmbeddingJobsService manages the graph embedding job queue.
// It provides methods to enqueue, dequeue, and manage embedding jobs for graph objects.
//
// Key features:
// - Idempotent enqueue (won't create duplicate active jobs for same object)
// - Atomic dequeue with FOR UPDATE SKIP LOCKED
// - Exponential backoff for retries
// - Stale job recovery
// - Queue statistics
//
// Note: Jobs retry indefinitely until they succeed (no maxAttempts limit).
type GraphEmbeddingJobsService struct {
        db  bun.IDB
        log *slog.Logger
        cfg *GraphEmbeddingConfig
}

// GraphEmbeddingConfig contains configuration for graph embedding jobs
type GraphEmbeddingConfig struct {
        // BaseRetryDelaySec is the base delay in seconds for retries (default: 60)
        BaseRetryDelaySec int
        // MaxRetryDelaySec is the maximum delay in seconds (default: 3600)
        MaxRetryDelaySec int
        // WorkerIntervalMs is the polling interval in milliseconds (default: 5000)
        WorkerIntervalMs int
        // WorkerBatchSize is the number of jobs to process per poll (default: 10)
        WorkerBatchSize int
}

// DefaultGraphEmbeddingConfig returns default configuration
func DefaultGraphEmbeddingConfig() *GraphEmbeddingConfig <span class="cov8" title="1">{
        return &amp;GraphEmbeddingConfig{
                BaseRetryDelaySec: 60,
                MaxRetryDelaySec:  3600,
                WorkerIntervalMs:  5000,
                WorkerBatchSize:   10,
        }
}</span>

// WorkerInterval returns the worker interval as a Duration
func (c *GraphEmbeddingConfig) WorkerInterval() time.Duration <span class="cov8" title="1">{
        return time.Duration(c.WorkerIntervalMs) * time.Millisecond
}</span>

// NewGraphEmbeddingJobsService creates a new graph embedding jobs service
func NewGraphEmbeddingJobsService(db bun.IDB, log *slog.Logger, cfg *GraphEmbeddingConfig) *GraphEmbeddingJobsService <span class="cov8" title="1">{
        if cfg == nil </span><span class="cov0" title="0">{
                cfg = DefaultGraphEmbeddingConfig()
        }</span>
        <span class="cov8" title="1">return &amp;GraphEmbeddingJobsService{
                db:  db,
                log: log.With(logger.Scope("graph.embedding.jobs")),
                cfg: cfg,
        }</span>
}

// EnqueueOptions contains options for enqueuing a graph embedding job
type EnqueueOptions struct {
        ObjectID   string // Required: the graph object ID to generate embedding for
        Priority   int    // Optional: higher = more urgent (default: 0)
        ScheduleAt *time.Time // Optional: when to process (default: now)
}

// Enqueue creates a new graph embedding job or returns existing active job.
// Idempotent: if an active (pending|processing) job exists for the object, returns it.
func (s *GraphEmbeddingJobsService) Enqueue(ctx context.Context, opts EnqueueOptions) (*GraphEmbeddingJob, error) <span class="cov8" title="1">{
        // Check for existing active job
        existing := &amp;GraphEmbeddingJob{}
        err := s.db.NewSelect().
                Model(existing).
                Where("object_id = ?", opts.ObjectID).
                Where("status IN ('pending', 'processing')").
                Limit(1).
                Scan(ctx)

        if err == nil </span><span class="cov8" title="1">{
                // Active job exists, return it
                return existing, nil
        }</span>
        <span class="cov8" title="1">if err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("check existing job: %w", err)
        }</span>

        // No active job, create new one
        <span class="cov8" title="1">scheduleAt := time.Now()
        if opts.ScheduleAt != nil </span><span class="cov8" title="1">{
                scheduleAt = *opts.ScheduleAt
        }</span>

        <span class="cov8" title="1">job := &amp;GraphEmbeddingJob{
                ObjectID:     opts.ObjectID,
                Status:       JobStatusPending,
                AttemptCount: 0,
                Priority:     opts.Priority,
                ScheduledAt:  scheduleAt,
        }

        _, err = s.db.NewInsert().
                Model(job).
                Returning("*").
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("enqueue graph embedding job: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Debug("enqueued graph embedding job",
                slog.String("job_id", job.ID),
                slog.String("object_id", job.ObjectID),
                slog.Int("priority", job.Priority))

        return job, nil</span>
}

// EnqueueBatch creates multiple graph embedding jobs in a single transaction.
// Skips objects that already have active jobs.
func (s *GraphEmbeddingJobsService) EnqueueBatch(ctx context.Context, objectIDs []string, priority int) (int, error) <span class="cov8" title="1">{
        if len(objectIDs) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Get objects that already have active jobs
        <span class="cov8" title="1">var existingObjectIDs []string
        err := s.db.NewSelect().
                Model((*GraphEmbeddingJob)(nil)).
                Column("object_id").
                Where("object_id IN (?)", bun.In(objectIDs)).
                Where("status IN ('pending', 'processing')").
                Scan(ctx, &amp;existingObjectIDs)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("check existing jobs: %w", err)
        }</span>

        // Filter out objects with existing jobs
        <span class="cov8" title="1">existingSet := make(map[string]bool, len(existingObjectIDs))
        for _, id := range existingObjectIDs </span><span class="cov8" title="1">{
                existingSet[id] = true
        }</span>

        <span class="cov8" title="1">var toEnqueue []string
        for _, id := range objectIDs </span><span class="cov8" title="1">{
                if !existingSet[id] </span><span class="cov8" title="1">{
                        toEnqueue = append(toEnqueue, id)
                }</span>
        }

        <span class="cov8" title="1">if len(toEnqueue) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        // Create jobs
        <span class="cov8" title="1">now := time.Now()
        jobs := make([]*GraphEmbeddingJob, len(toEnqueue))
        for i, objectID := range toEnqueue </span><span class="cov8" title="1">{
                jobs[i] = &amp;GraphEmbeddingJob{
                        ObjectID:     objectID,
                        Status:       JobStatusPending,
                        AttemptCount: 0,
                        Priority:     priority,
                        ScheduledAt:  now,
                }
        }</span>

        <span class="cov8" title="1">_, err = s.db.NewInsert().
                Model(&amp;jobs).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("enqueue batch: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Debug("enqueued graph embedding jobs batch",
                slog.Int("count", len(jobs)),
                slog.Int("skipped", len(existingObjectIDs)))

        return len(jobs), nil</span>
}

// Dequeue atomically claims jobs for processing.
// Uses PostgreSQL's FOR UPDATE SKIP LOCKED for concurrent workers.
func (s *GraphEmbeddingJobsService) Dequeue(ctx context.Context, batchSize int) ([]*GraphEmbeddingJob, error) <span class="cov8" title="1">{
        if batchSize &lt;= 0 </span><span class="cov0" title="0">{
                batchSize = s.cfg.WorkerBatchSize
        }</span>

        <span class="cov8" title="1">var jobs []*GraphEmbeddingJob

        // Strategic SQL: FOR UPDATE SKIP LOCKED for concurrent workers
        // Order by priority DESC (higher = more urgent) then by scheduled_at ASC
        err := s.db.NewRaw(`WITH cte AS (
                SELECT id FROM kb.graph_embedding_jobs
                WHERE status = 'pending' 
                        AND scheduled_at &lt;= now()
                ORDER BY priority DESC, scheduled_at ASC
                FOR UPDATE SKIP LOCKED
                LIMIT ?
        )
        UPDATE kb.graph_embedding_jobs j 
        SET status = 'processing', 
                started_at = now(),
                attempt_count = attempt_count + 1,
                updated_at = now()
        FROM cte WHERE j.id = cte.id
        RETURNING j.*`, batchSize).Scan(ctx, &amp;jobs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dequeue graph embedding jobs: %w", err)
        }</span>

        <span class="cov8" title="1">return jobs, nil</span>
}

// MarkCompleted marks a job as successfully completed
func (s *GraphEmbeddingJobsService) MarkCompleted(ctx context.Context, id string) error <span class="cov8" title="1">{
        now := time.Now()
        _, err := s.db.NewUpdate().
                Model((*GraphEmbeddingJob)(nil)).
                Set("status = ?", JobStatusCompleted).
                Set("completed_at = ?", now).
                Set("last_error = NULL").
                Set("updated_at = ?", now).
                Where("id = ?", id).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mark completed: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Debug("graph embedding job completed", slog.String("job_id", id))
        return nil</span>
}

// MarkFailed marks a job as failed and schedules retry with exponential backoff.
// Unlike email jobs, graph embedding jobs retry indefinitely (no max attempts).
func (s *GraphEmbeddingJobsService) MarkFailed(ctx context.Context, id string, jobErr error) error <span class="cov8" title="1">{
        job := &amp;GraphEmbeddingJob{}
        err := s.db.NewSelect().
                Model(job).
                Column("id", "attempt_count").
                Where("id = ?", id).
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        s.log.Warn("graph embedding job not found when marking as failed", slog.String("job_id", id))
                        return nil
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("get job for mark failed: %w", err)</span>
        }

        <span class="cov8" title="1">errorMessage := truncateError(jobErr.Error())

        // Calculate exponential backoff: base * attempt^2, capped at max
        delaySeconds := int(math.Min(
                float64(s.cfg.MaxRetryDelaySec),
                float64(s.cfg.BaseRetryDelaySec)*float64(job.AttemptCount)*float64(job.AttemptCount),
        ))
        if delaySeconds &lt; s.cfg.BaseRetryDelaySec </span><span class="cov0" title="0">{
                delaySeconds = s.cfg.BaseRetryDelaySec
        }</span>

        // Requeue for retry
        <span class="cov8" title="1">_, updateErr := s.db.NewRaw(`UPDATE kb.graph_embedding_jobs 
                SET status = 'pending', 
                        last_error = ?, 
                        scheduled_at = now() + (? || ' seconds')::interval,
                        updated_at = now()
                WHERE id = ?`,
                errorMessage, fmt.Sprintf("%d", delaySeconds), id).Exec(ctx)
        if updateErr != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("requeue failed job: %w", updateErr)
        }</span>

        <span class="cov8" title="1">s.log.Warn("graph embedding job failed, retrying",
                slog.String("job_id", id),
                slog.Int("attempt", job.AttemptCount),
                slog.Duration("retry_delay", time.Duration(delaySeconds)*time.Second),
                slog.String("error", errorMessage))

        return nil</span>
}

// RecoverStaleJobs recovers jobs stuck in 'processing' status.
// This can happen when the server restarts while jobs are being processed.
func (s *GraphEmbeddingJobsService) RecoverStaleJobs(ctx context.Context, staleThresholdMinutes int) (int, error) <span class="cov8" title="1">{
        if staleThresholdMinutes &lt;= 0 </span><span class="cov0" title="0">{
                staleThresholdMinutes = 10
        }</span>

        <span class="cov8" title="1">result, err := s.db.NewRaw(`UPDATE kb.graph_embedding_jobs 
                SET status = 'pending', 
                        started_at = NULL,
                        scheduled_at = now(),
                        updated_at = now()
                WHERE status = 'processing' 
                        AND started_at &lt; now() - (? || ' minutes')::interval`,
                fmt.Sprintf("%d", staleThresholdMinutes)).Exec(ctx)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("recover stale jobs: %w", err)
        }</span>

        <span class="cov8" title="1">count, _ := result.RowsAffected()

        if count &gt; 0 </span><span class="cov8" title="1">{
                s.log.Warn("recovered stale graph embedding jobs",
                        slog.Int64("count", count),
                        slog.Int("threshold_minutes", staleThresholdMinutes))
        }</span>

        <span class="cov8" title="1">return int(count), nil</span>
}

// GetJob retrieves a job by ID
func (s *GraphEmbeddingJobsService) GetJob(ctx context.Context, id string) (*GraphEmbeddingJob, error) <span class="cov8" title="1">{
        job := &amp;GraphEmbeddingJob{}
        err := s.db.NewSelect().
                Model(job).
                Where("id = ?", id).
                Scan(ctx)

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get job: %w", err)
        }</span>

        <span class="cov8" title="1">return job, nil</span>
}

// GetActiveJobForObject returns the active job for an object, if any.
func (s *GraphEmbeddingJobsService) GetActiveJobForObject(ctx context.Context, objectID string) (*GraphEmbeddingJob, error) <span class="cov8" title="1">{
        job := &amp;GraphEmbeddingJob{}
        err := s.db.NewSelect().
                Model(job).
                Where("object_id = ?", objectID).
                Where("status IN ('pending', 'processing')").
                Order("created_at DESC").
                Limit(1).
                Scan(ctx)

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get active job for object: %w", err)
        }</span>

        <span class="cov8" title="1">return job, nil</span>
}

// Stats returns queue statistics
func (s *GraphEmbeddingJobsService) Stats(ctx context.Context) (*GraphEmbeddingQueueStats, error) <span class="cov8" title="1">{
        stats := &amp;GraphEmbeddingQueueStats{}

        err := s.db.NewRaw(`SELECT 
                COUNT(*) FILTER (WHERE status = 'pending') as pending,
                COUNT(*) FILTER (WHERE status = 'processing') as processing,
                COUNT(*) FILTER (WHERE status = 'completed') as completed,
                COUNT(*) FILTER (WHERE status = 'failed') as failed
        FROM kb.graph_embedding_jobs`).Scan(ctx, &amp;stats.Pending, &amp;stats.Processing, &amp;stats.Completed, &amp;stats.Failed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get stats: %w", err)
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// GraphEmbeddingQueueStats contains queue statistics
type GraphEmbeddingQueueStats struct {
        Pending    int64 `json:"pending"`
        Processing int64 `json:"processing"`
        Completed  int64 `json:"completed"`
        Failed     int64 `json:"failed"`
}

// truncateError truncates an error message to 1000 characters
func truncateError(msg string) string <span class="cov8" title="1">{
        if len(msg) &gt; 1000 </span><span class="cov8" title="1">{
                return msg[:1000]
        }</span>
        <span class="cov8" title="1">return msg</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package extraction

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/embeddings/vertex"
        "github.com/emergent/emergent-core/pkg/logger"
)

// EmbeddingService is the interface for embedding services used by the worker.
// This allows for dependency injection and testing.
type EmbeddingService interface {
        IsEnabled() bool
        EmbedQueryWithUsage(ctx context.Context, query string) (*vertex.EmbedResult, error)
}

// GraphEmbeddingWorker processes graph embedding jobs from the queue.
// It follows the same pattern as NestJS workers:
// - Polling-based with configurable interval
// - Graceful shutdown waiting for current batch
// - Stale job recovery on startup
// - Metrics tracking
type GraphEmbeddingWorker struct {
        jobs    *GraphEmbeddingJobsService
        embeds  EmbeddingService
        db      bun.IDB
        cfg     *GraphEmbeddingConfig
        log     *slog.Logger
        stopCh  chan struct{}
        stoppedCh chan struct{}
        running bool
        mu      sync.Mutex
        wg      sync.WaitGroup

        // Metrics
        processedCount int64
        successCount   int64
        failureCount   int64
        metricsMu      sync.RWMutex
}

// NewGraphEmbeddingWorker creates a new graph embedding worker
func NewGraphEmbeddingWorker(
        jobs *GraphEmbeddingJobsService,
        embeds EmbeddingService,
        db bun.IDB,
        cfg *GraphEmbeddingConfig,
        log *slog.Logger,
) *GraphEmbeddingWorker <span class="cov8" title="1">{
        return &amp;GraphEmbeddingWorker{
                jobs:   jobs,
                embeds: embeds,
                db:     db,
                cfg:    cfg,
                log:    log.With(logger.Scope("graph.embedding.worker")),
        }
}</span>

// Start begins the worker's polling loop
func (w *GraphEmbeddingWorker) Start(ctx context.Context) error <span class="cov8" title="1">{
        w.mu.Lock()
        if w.running </span><span class="cov0" title="0">{
                w.mu.Unlock()
                return nil
        }</span>

        // Check if embeddings are enabled
        <span class="cov8" title="1">if !w.embeds.IsEnabled() </span><span class="cov8" title="1">{
                w.log.Info("graph embedding worker not started (embeddings not enabled)")
                w.mu.Unlock()
                return nil
        }</span>

        <span class="cov8" title="1">w.running = true
        w.stopCh = make(chan struct{})
        w.stoppedCh = make(chan struct{})
        w.mu.Unlock()

        // Recover stale jobs on startup
        go w.recoverStaleJobsOnStartup(ctx)

        w.log.Info("graph embedding worker starting",
                slog.Duration("poll_interval", w.cfg.WorkerInterval()),
                slog.Int("batch_size", w.cfg.WorkerBatchSize))

        w.wg.Add(1)
        go w.run(ctx)

        return nil</span>
}

// Stop gracefully stops the worker, waiting for current batch to complete
func (w *GraphEmbeddingWorker) Stop(ctx context.Context) error <span class="cov8" title="1">{
        w.mu.Lock()
        if !w.running </span><span class="cov0" title="0">{
                w.mu.Unlock()
                return nil
        }</span>
        <span class="cov8" title="1">w.running = false
        close(w.stopCh)
        w.mu.Unlock()

        w.log.Debug("waiting for graph embedding worker to stop...")

        // Wait for worker to stop or context to be cancelled
        select </span>{
        case &lt;-w.stoppedCh:<span class="cov8" title="1">
                w.log.Info("graph embedding worker stopped gracefully")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                w.log.Warn("graph embedding worker stop timeout, forcing shutdown")</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// recoverStaleJobsOnStartup recovers stale jobs on startup
func (w *GraphEmbeddingWorker) recoverStaleJobsOnStartup(ctx context.Context) <span class="cov8" title="1">{
        recovered, err := w.jobs.RecoverStaleJobs(ctx, 10)
        if err != nil </span><span class="cov8" title="1">{
                w.log.Warn("failed to recover stale jobs on startup",
                        slog.String("error", err.Error()))
                return
        }</span>
        <span class="cov8" title="1">if recovered &gt; 0 </span><span class="cov0" title="0">{
                w.log.Info("recovered stale graph embedding jobs on startup",
                        slog.Int("count", recovered))
        }</span>
}

// run is the main worker loop
func (w *GraphEmbeddingWorker) run(ctx context.Context) <span class="cov8" title="1">{
        defer w.wg.Done()
        defer close(w.stoppedCh)

        ticker := time.NewTicker(w.cfg.WorkerInterval())
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov8" title="1">
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if err := w.processBatch(ctx); err != nil </span><span class="cov0" title="0">{
                                w.log.Warn("process batch failed", slog.String("error", err.Error()))
                        }</span>
                }
        }
}

// processBatch processes a batch of graph embedding jobs
func (w *GraphEmbeddingWorker) processBatch(ctx context.Context) error <span class="cov8" title="1">{
        // Check if we should stop
        select </span>{
        case &lt;-w.stopCh:<span class="cov8" title="1">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov8" title="1"></span>
        }

        <span class="cov8" title="1">jobs, err := w.jobs.Dequeue(ctx, w.cfg.WorkerBatchSize)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(jobs) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, job := range jobs </span><span class="cov8" title="1">{
                if err := w.processJob(ctx, job); err != nil </span><span class="cov8" title="1">{
                        w.log.Warn("process job failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", err.Error()))
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// graphObjectRow represents the minimal data needed from a graph object for embedding
type graphObjectRow struct {
        ID         string                 `bun:"id,type:uuid"`
        Type       string                 `bun:"type"`
        Key        *string                `bun:"key"`
        Properties map[string]interface{} `bun:"properties,type:jsonb"`
        ProjectID  string                 `bun:"project_id,type:uuid"`
}

// processJob processes a single graph embedding job
func (w *GraphEmbeddingWorker) processJob(ctx context.Context, job *GraphEmbeddingJob) error <span class="cov8" title="1">{
        startTime := time.Now()

        // Fetch the graph object
        obj := &amp;graphObjectRow{}
        err := w.db.NewSelect().
                TableExpr("kb.graph_objects").
                Column("id", "type", "key", "properties", "project_id").
                Where("id = ?", job.ObjectID).
                Scan(ctx, obj)

        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                // Object doesn't exist, mark as failed with a short error
                if markErr := w.jobs.MarkFailed(ctx, job.ID, fmt.Errorf("object_missing")); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov8" title="1">w.incrementFailure()
                return fmt.Errorf("object not found: %s", job.ObjectID)</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                // Database error
                if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov0" title="0">w.incrementFailure()
                return fmt.Errorf("fetch object: %w", err)</span>
        }

        // Extract text for embedding
        <span class="cov8" title="1">text := w.extractText(obj)
        textLength := len(text)

        // Generate embedding
        embeddingStartTime := time.Now()
        result, err := w.embeds.EmbedQueryWithUsage(ctx, text)
        embeddingDurationMs := time.Since(embeddingStartTime).Milliseconds()

        if err != nil </span><span class="cov8" title="1">{
                // Embedding failed
                if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov8" title="1">w.incrementFailure()
                return fmt.Errorf("generate embedding: %w", err)</span>
        }

        <span class="cov8" title="1">if result == nil || len(result.Embedding) == 0 </span><span class="cov0" title="0">{
                // No embedding returned (likely noop client)
                err := fmt.Errorf("no embedding returned")
                if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov0" title="0">w.incrementFailure()
                return err</span>
        }

        // Update the graph object with the embedding
        // Note: embedding_v2 is vector(768), we need to use raw SQL for pgvector
        <span class="cov8" title="1">now := time.Now()
        _, err = w.db.NewRaw(`UPDATE kb.graph_objects 
                SET embedding_v2 = ?::vector, 
                        embedding_updated_at = ?,
                        updated_at = ?
                WHERE id = ?`,
                vectorToString(result.Embedding), now, now, job.ObjectID).Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                // Update failed
                if markErr := w.jobs.MarkFailed(ctx, job.ID, err); markErr != nil </span><span class="cov0" title="0">{
                        w.log.Error("failed to mark job as failed",
                                slog.String("job_id", job.ID),
                                slog.String("error", markErr.Error()))
                }</span>
                <span class="cov0" title="0">w.incrementFailure()
                return fmt.Errorf("update embedding: %w", err)</span>
        }

        // Mark job as completed
        <span class="cov8" title="1">if err := w.jobs.MarkCompleted(ctx, job.ID); err != nil </span><span class="cov0" title="0">{
                w.log.Error("failed to mark job as completed",
                        slog.String("job_id", job.ID),
                        slog.String("error", err.Error()))
                return err
        }</span>

        <span class="cov8" title="1">totalDurationMs := time.Since(startTime).Milliseconds()

        w.log.Debug("generated embedding for graph object",
                slog.String("object_id", obj.ID),
                slog.String("object_type", obj.Type),
                slog.Int("embedding_dims", len(result.Embedding)),
                slog.Int("text_length", textLength),
                slog.Int64("embedding_duration_ms", embeddingDurationMs),
                slog.Int64("total_duration_ms", totalDurationMs))

        w.incrementSuccess()
        return nil</span>
}

// extractText extracts text from a graph object for embedding.
// Follows the same heuristic as NestJS: join type, key, and all primitive leaf values.
func (w *GraphEmbeddingWorker) extractText(obj *graphObjectRow) string <span class="cov8" title="1">{
        tokens := []string{obj.Type}
        if obj.Key != nil </span><span class="cov8" title="1">{
                tokens = append(tokens, *obj.Key)
        }</span>

        // Walk properties recursively
        <span class="cov8" title="1">var walk func(v interface{})
        walk = func(v interface{}) </span><span class="cov8" title="1">{
                if v == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">switch val := v.(type) </span>{
                case string:<span class="cov8" title="1">
                        tokens = append(tokens, val)</span>
                case float64:<span class="cov8" title="1">
                        tokens = append(tokens, fmt.Sprintf("%v", val))</span>
                case bool:<span class="cov8" title="1">
                        tokens = append(tokens, fmt.Sprintf("%v", val))</span>
                case []interface{}:<span class="cov8" title="1">
                        for _, x := range val </span><span class="cov8" title="1">{
                                walk(x)
                        }</span>
                case map[string]interface{}:<span class="cov8" title="1">
                        for _, x := range val </span><span class="cov8" title="1">{
                                walk(x)
                        }</span>
                }
        }
        <span class="cov8" title="1">walk(obj.Properties)

        // Join with spaces
        result := ""
        for i, token := range tokens </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        result += " "
                }</span>
                <span class="cov8" title="1">result += token</span>
        }
        <span class="cov8" title="1">return result</span>
}

// vectorToString converts a float32 slice to PostgreSQL vector string format
func vectorToString(v []float32) string <span class="cov8" title="1">{
        if len(v) == 0 </span><span class="cov8" title="1">{
                return "[]"
        }</span>
        <span class="cov8" title="1">result := "["
        for i, val := range v </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        result += ","
                }</span>
                <span class="cov8" title="1">result += fmt.Sprintf("%f", val)</span>
        }
        <span class="cov8" title="1">result += "]"
        return result</span>
}

// incrementSuccess increments both processed and success counters
func (w *GraphEmbeddingWorker) incrementSuccess() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.successCount++
        w.metricsMu.Unlock()
}</span>

// incrementFailure increments both processed and failure counters
func (w *GraphEmbeddingWorker) incrementFailure() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.failureCount++
        w.metricsMu.Unlock()
}</span>

// Metrics returns current worker metrics
func (w *GraphEmbeddingWorker) Metrics() GraphEmbeddingWorkerMetrics <span class="cov8" title="1">{
        w.metricsMu.RLock()
        defer w.metricsMu.RUnlock()

        return GraphEmbeddingWorkerMetrics{
                Processed: w.processedCount,
                Succeeded: w.successCount,
                Failed:    w.failureCount,
        }
}</span>

// GraphEmbeddingWorkerMetrics contains worker metrics
type GraphEmbeddingWorkerMetrics struct {
        Processed int64 `json:"processed"`
        Succeeded int64 `json:"succeeded"`
        Failed    int64 `json:"failed"`
}

// IsRunning returns whether the worker is currently running
func (w *GraphEmbeddingWorker) IsRunning() bool <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        return w.running
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">package extraction

import (
        "context"
        "log/slog"
        "time"

        "github.com/uptrace/bun"
        "go.uber.org/fx"

        "github.com/emergent/emergent-core/domain/documents"
        "github.com/emergent/emergent-core/domain/graph"
        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/internal/storage"
        "github.com/emergent/emergent-core/pkg/adk"
        "github.com/emergent/emergent-core/pkg/embeddings"
        "github.com/emergent/emergent-core/pkg/kreuzberg"
)

// Module provides extraction functionality including job queues and workers
var Module = fx.Module("extraction",
        fx.Provide(
                NewExtractionConfig,
                provideGraphEmbeddingJobsService,
                provideGraphEmbeddingWorker,
                provideChunkEmbeddingJobsService,
                provideChunkEmbeddingWorker,
                provideDocumentParsingJobsService,
                provideDocumentParsingWorker,
                provideObjectExtractionJobsService,
                provideTemplatePackSchemaProvider,
                provideObjectExtractionWorker,
        ),
        fx.Invoke(
                RegisterGraphEmbeddingWorkerLifecycle,
                RegisterChunkEmbeddingWorkerLifecycle,
                RegisterDocumentParsingWorkerLifecycle,
                RegisterObjectExtractionWorkerLifecycle,
        ),
)

// ExtractionConfig contains configuration for all extraction services
type ExtractionConfig struct {
        GraphEmbedding    *GraphEmbeddingConfig
        ChunkEmbedding    *ChunkEmbeddingConfig
        DocumentParsing   *DocumentParsingConfig
        ObjectExtraction  *ObjectExtractionConfig
}

// NewExtractionConfig creates extraction configuration from app config
func NewExtractionConfig(cfg *config.Config) *ExtractionConfig <span class="cov8" title="1">{
        return &amp;ExtractionConfig{
                GraphEmbedding:   DefaultGraphEmbeddingConfig(),
                ChunkEmbedding:   DefaultChunkEmbeddingConfig(),
                DocumentParsing:  DefaultDocumentParsingConfig(),
                ObjectExtraction: DefaultObjectExtractionConfig(),
        }
}</span>

// provideGraphEmbeddingJobsService creates graph embedding jobs service with fx
func provideGraphEmbeddingJobsService(db bun.IDB, log *slog.Logger, cfg *ExtractionConfig) *GraphEmbeddingJobsService <span class="cov0" title="0">{
        return NewGraphEmbeddingJobsService(db, log, cfg.GraphEmbedding)
}</span>

// provideGraphEmbeddingWorker creates graph embedding worker with fx
func provideGraphEmbeddingWorker(
        jobs *GraphEmbeddingJobsService,
        embeds *embeddings.Service,
        db bun.IDB,
        cfg *ExtractionConfig,
        log *slog.Logger,
) *GraphEmbeddingWorker <span class="cov0" title="0">{
        return NewGraphEmbeddingWorker(jobs, embeds, db, cfg.GraphEmbedding, log)
}</span>

// RegisterGraphEmbeddingWorkerLifecycle registers the worker with fx lifecycle
func RegisterGraphEmbeddingWorkerLifecycle(lc fx.Lifecycle, worker *GraphEmbeddingWorker) <span class="cov0" title="0">{
        lc.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        return worker.Start(ctx)
                }</span>,
                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                        return worker.Stop(ctx)
                }</span>,
        })
}

// provideChunkEmbeddingJobsService creates chunk embedding jobs service with fx
func provideChunkEmbeddingJobsService(db bun.IDB, log *slog.Logger, cfg *ExtractionConfig) *ChunkEmbeddingJobsService <span class="cov0" title="0">{
        return NewChunkEmbeddingJobsService(db, log, cfg.ChunkEmbedding)
}</span>

// provideChunkEmbeddingWorker creates chunk embedding worker with fx
func provideChunkEmbeddingWorker(
        jobs *ChunkEmbeddingJobsService,
        embeds *embeddings.Service,
        db bun.IDB,
        cfg *ExtractionConfig,
        log *slog.Logger,
) *ChunkEmbeddingWorker <span class="cov0" title="0">{
        return NewChunkEmbeddingWorker(jobs, embeds, db, cfg.ChunkEmbedding, log)
}</span>

// RegisterChunkEmbeddingWorkerLifecycle registers the chunk embedding worker with fx lifecycle
func RegisterChunkEmbeddingWorkerLifecycle(lc fx.Lifecycle, worker *ChunkEmbeddingWorker) <span class="cov0" title="0">{
        lc.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        return worker.Start(ctx)
                }</span>,
                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                        return worker.Stop(ctx)
                }</span>,
        })
}

// provideDocumentParsingJobsService creates document parsing jobs service with fx
func provideDocumentParsingJobsService(db bun.IDB, log *slog.Logger, cfg *ExtractionConfig) *DocumentParsingJobsService <span class="cov0" title="0">{
        return NewDocumentParsingJobsService(db, log, cfg.DocumentParsing)
}</span>

// provideObjectExtractionJobsService creates object extraction jobs service with fx
func provideObjectExtractionJobsService(db bun.IDB, log *slog.Logger, cfg *ExtractionConfig) *ObjectExtractionJobsService <span class="cov0" title="0">{
        return NewObjectExtractionJobsService(db, log, cfg.ObjectExtraction)
}</span>

// provideTemplatePackSchemaProvider creates template pack schema provider with fx
func provideTemplatePackSchemaProvider(db bun.IDB, log *slog.Logger) *TemplatePackSchemaProvider <span class="cov0" title="0">{
        return NewTemplatePackSchemaProvider(db, log)
}</span>

// provideObjectExtractionWorker creates object extraction worker with fx
func provideObjectExtractionWorker(
        jobs *ObjectExtractionJobsService,
        graphService *graph.Service,
        docService *documents.Service,
        schemaProvider *TemplatePackSchemaProvider,
        modelFactory *adk.ModelFactory,
        cfg *ExtractionConfig,
        log *slog.Logger,
) *ObjectExtractionWorker <span class="cov0" title="0">{
        workerConfig := &amp;ObjectExtractionWorkerConfig{
                PollInterval:    time.Duration(cfg.ObjectExtraction.WorkerIntervalMs) * time.Millisecond,
                OrphanThreshold: 0.3,
                MaxRetries:      uint(cfg.ObjectExtraction.DefaultMaxRetries),
        }
        return NewObjectExtractionWorker(jobs, graphService, docService, schemaProvider, modelFactory, workerConfig, log)
}</span>

// RegisterObjectExtractionWorkerLifecycle registers the object extraction worker with fx lifecycle
func RegisterObjectExtractionWorkerLifecycle(lc fx.Lifecycle, worker *ObjectExtractionWorker) <span class="cov0" title="0">{
        lc.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        worker.Start(ctx)
                        return nil
                }</span>,
                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                        worker.Stop()
                        return nil
                }</span>,
        })
}

// provideDocumentParsingWorker creates document parsing worker with fx
func provideDocumentParsingWorker(
        jobs *DocumentParsingJobsService,
        kreuzbergClient *kreuzberg.Client,
        storageService *storage.Service,
        cfg *ExtractionConfig,
        log *slog.Logger,
) *DocumentParsingWorker <span class="cov0" title="0">{
        workerConfig := &amp;DocumentParsingWorkerConfig{
                Interval:  time.Duration(cfg.DocumentParsing.WorkerIntervalMs) * time.Millisecond,
                BatchSize: cfg.DocumentParsing.WorkerBatchSize,
        }
        return NewDocumentParsingWorker(jobs, kreuzbergClient, storageService, workerConfig, log)
}</span>

// RegisterDocumentParsingWorkerLifecycle registers the document parsing worker with fx lifecycle
func RegisterDocumentParsingWorkerLifecycle(lc fx.Lifecycle, worker *DocumentParsingWorker) <span class="cov0" title="0">{
        lc.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        go worker.Start()
                        return nil
                }</span>,
                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                        worker.Stop()
                        return nil
                }</span>,
        })
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package extraction

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/logger"
)

// ObjectExtractionConfig holds configuration for object extraction jobs
type ObjectExtractionConfig struct {
        // DefaultMaxRetries is the maximum number of retry attempts (default: 3)
        DefaultMaxRetries int
        // WorkerIntervalMs is the polling interval for the worker (default: 5000)
        WorkerIntervalMs int
        // WorkerBatchSize is the number of jobs to process in each batch (default: 5)
        WorkerBatchSize int
        // StaleThresholdMinutes is how long a job can be 'processing' before recovery (default: 30)
        StaleThresholdMinutes int
}

// DefaultObjectExtractionConfig returns default configuration
func DefaultObjectExtractionConfig() *ObjectExtractionConfig <span class="cov8" title="1">{
        return &amp;ObjectExtractionConfig{
                DefaultMaxRetries:     3,
                WorkerIntervalMs:      5000,
                WorkerBatchSize:       5,
                StaleThresholdMinutes: 30,
        }
}</span>

// ObjectExtractionJobsService manages object extraction jobs
type ObjectExtractionJobsService struct {
        db     bun.IDB
        log    *slog.Logger
        config *ObjectExtractionConfig
}

// NewObjectExtractionJobsService creates a new object extraction jobs service
func NewObjectExtractionJobsService(db bun.IDB, log *slog.Logger, config *ObjectExtractionConfig) *ObjectExtractionJobsService <span class="cov8" title="1">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultObjectExtractionConfig()
        }</span>
        <span class="cov8" title="1">return &amp;ObjectExtractionJobsService{
                db:     db,
                log:    log.With(logger.Scope("object-extraction-jobs")),
                config: config,
        }</span>
}

// CreateJobOptions contains options for creating an object extraction job
type CreateObjectExtractionJobOptions struct {
        ProjectID        string
        DocumentID       *string   // Optional: specific document
        ChunkID          *string   // Optional: specific chunk
        JobType          JobType   // full_extraction, reextraction, incremental
        EnabledTypes     []string  // Entity types to extract
        ExtractionConfig JSON      // LLM/extraction settings
        SourceType       *string   // 'document', 'chunk', 'manual'
        SourceID         *string
        SourceMetadata   JSON
        CreatedBy        *string // User who created the job
        ReprocessingOf   *string // ID of job being reprocessed
}

// CreateJob creates a new object extraction job
func (s *ObjectExtractionJobsService) CreateJob(ctx context.Context, opts CreateObjectExtractionJobOptions) (*ObjectExtractionJob, error) <span class="cov8" title="1">{
        now := time.Now().UTC()

        // Defaults
        jobType := opts.JobType
        if jobType == "" </span><span class="cov8" title="1">{
                jobType = JobTypeFullExtraction
        }</span>

        <span class="cov8" title="1">enabledTypes := opts.EnabledTypes
        if enabledTypes == nil </span><span class="cov8" title="1">{
                enabledTypes = []string{}
        }</span>

        <span class="cov8" title="1">extractionConfig := opts.ExtractionConfig
        if extractionConfig == nil </span><span class="cov8" title="1">{
                extractionConfig = JSON{}
        }</span>

        <span class="cov8" title="1">sourceMetadata := opts.SourceMetadata
        if sourceMetadata == nil </span><span class="cov8" title="1">{
                sourceMetadata = JSON{}
        }</span>

        <span class="cov8" title="1">job := &amp;ObjectExtractionJob{
                ProjectID:        opts.ProjectID,
                DocumentID:       opts.DocumentID,
                ChunkID:          opts.ChunkID,
                JobType:          jobType,
                Status:           JobStatusPending,
                EnabledTypes:     enabledTypes,
                ExtractionConfig: extractionConfig,
                SourceType:       opts.SourceType,
                SourceID:         opts.SourceID,
                SourceMetadata:   sourceMetadata,
                CreatedBy:        opts.CreatedBy,
                ReprocessingOf:   opts.ReprocessingOf,
                MaxRetries:       s.config.DefaultMaxRetries,
                Logs:             JSONArray{},
                CreatedAt:        now,
                UpdatedAt:        now,
        }

        _, err := s.db.NewInsert().
                Model(job).
                Returning("*").
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to create object extraction job",
                        slog.String("projectId", opts.ProjectID),
                        logger.Error(err))
                return nil, fmt.Errorf("create object extraction job: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Info("created object extraction job",
                slog.String("id", job.ID),
                slog.String("projectId", opts.ProjectID),
                slog.String("jobType", string(jobType)))

        return job, nil</span>
}

// Dequeue claims the next pending job for processing using FOR UPDATE SKIP LOCKED
// Returns nil if no jobs are available
func (s *ObjectExtractionJobsService) Dequeue(ctx context.Context) (*ObjectExtractionJob, error) <span class="cov8" title="1">{
        job := new(ObjectExtractionJob)
        now := time.Now().UTC()

        // Use a transaction for atomic read-and-update
        err := s.db.RunInTx(ctx, &amp;sql.TxOptions{}, func(ctx context.Context, tx bun.Tx) error </span><span class="cov8" title="1">{
                // Find the oldest pending job and lock it
                // Only one job per project can run at a time (unless allow_parallel_extraction)
                err := tx.NewSelect().
                        Model(job).
                        Where("status = ?", JobStatusPending).
                        Where(`NOT EXISTS (
                                SELECT 1 FROM kb.object_extraction_jobs running
                                WHERE running.project_id = oej.project_id
                                  AND running.status = 'processing'
                        )`).
                        OrderExpr("created_at ASC").
                        Limit(1).
                        For("UPDATE SKIP LOCKED").
                        Scan(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                                return err // Will be handled below
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("select pending job: %w", err)</span>
                }

                // Update job to processing status
                <span class="cov8" title="1">job.Status = JobStatusProcessing
                job.StartedAt = &amp;now
                job.UpdatedAt = now

                _, err = tx.NewUpdate().
                        Model(job).
                        Column("status", "started_at", "updated_at").
                        WherePK().
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("update job status: %w", err)
                }</span>

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                return nil, nil // No jobs available
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s.log.Debug("dequeued object extraction job",
                slog.String("id", job.ID),
                slog.String("projectId", job.ProjectID))

        return job, nil</span>
}

// MarkCompleted marks a job as completed with results
func (s *ObjectExtractionJobsService) MarkCompleted(ctx context.Context, jobID string, results ObjectExtractionResults) error <span class="cov8" title="1">{
        now := time.Now().UTC()

        _, err := s.db.NewUpdate().
                Model((*ObjectExtractionJob)(nil)).
                Set("status = ?", JobStatusCompleted).
                Set("completed_at = ?", now).
                Set("updated_at = ?", now).
                Set("objects_created = ?", results.ObjectsCreated).
                Set("relationships_created = ?", results.RelationshipsCreated).
                Set("suggestions_created = ?", results.SuggestionsCreated).
                Set("total_items = ?", results.TotalItems).
                Set("processed_items = ?", results.ProcessedItems).
                Set("successful_items = ?", results.SuccessfulItems).
                Set("failed_items = ?", results.FailedItems).
                Set("discovered_types = ?", results.DiscoveredTypes).
                Set("created_objects = ?", results.CreatedObjects).
                Set("debug_info = ?", results.DebugInfo).
                Where("id = ?", jobID).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to mark job completed",
                        slog.String("id", jobID),
                        logger.Error(err))
                return fmt.Errorf("mark completed: %w", err)
        }</span>

        <span class="cov8" title="1">s.log.Info("object extraction job completed",
                slog.String("id", jobID),
                slog.Int("objectsCreated", results.ObjectsCreated),
                slog.Int("successfulItems", results.SuccessfulItems))

        return nil</span>
}

// ObjectExtractionResults contains the results of an object extraction job
type ObjectExtractionResults struct {
        ObjectsCreated       int
        RelationshipsCreated int
        SuggestionsCreated   int
        TotalItems           int
        ProcessedItems       int
        SuccessfulItems      int
        FailedItems          int
        DiscoveredTypes      JSONArray
        CreatedObjects       JSONArray
        DebugInfo            JSON
}

// MarkFailed marks a job as failed with an error message
// If retries are available, schedules a retry; otherwise marks as permanently failed
func (s *ObjectExtractionJobsService) MarkFailed(ctx context.Context, jobID string, errorMessage string, errorDetails JSON) error <span class="cov8" title="1">{
        now := time.Now().UTC()

        // Get current retry count
        job := new(ObjectExtractionJob)
        err := s.db.NewSelect().
                Model(job).
                Column("retry_count", "max_retries").
                Where("id = ?", jobID).
                Scan(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("get job for retry check: %w", err)
        }</span>

        <span class="cov8" title="1">newRetryCount := job.RetryCount + 1

        if newRetryCount &gt;= job.MaxRetries </span><span class="cov8" title="1">{
                // Move to dead letter queue
                _, err = s.db.NewUpdate().
                        Model((*ObjectExtractionJob)(nil)).
                        Set("status = ?", JobStatusDeadLetter).
                        Set("completed_at = ?", now).
                        Set("updated_at = ?", now).
                        Set("error_message = ?", errorMessage).
                        Set("error_details = ?", errorDetails).
                        Set("retry_count = ?", newRetryCount).
                        Where("id = ?", jobID).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("mark as dead letter: %w", err)
                }</span>

                <span class="cov8" title="1">s.log.Warn("object extraction job moved to dead letter queue",
                        slog.String("id", jobID),
                        slog.String("error", errorMessage),
                        slog.Int("retryCount", newRetryCount))</span>
        } else<span class="cov8" title="1"> {
                // Schedule retry - reset to pending
                _, err = s.db.NewUpdate().
                        Model((*ObjectExtractionJob)(nil)).
                        Set("status = ?", JobStatusPending).
                        Set("updated_at = ?", now).
                        Set("error_message = ?", errorMessage).
                        Set("error_details = ?", errorDetails).
                        Set("retry_count = ?", newRetryCount).
                        Set("started_at = NULL").
                        Where("id = ?", jobID).
                        Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("schedule retry: %w", err)
                }</span>

                <span class="cov8" title="1">s.log.Info("object extraction job scheduled for retry",
                        slog.String("id", jobID),
                        slog.Int("retryCount", newRetryCount),
                        slog.Int("maxRetries", job.MaxRetries))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// UpdateProgress updates the progress of a running job
func (s *ObjectExtractionJobsService) UpdateProgress(ctx context.Context, jobID string, processed, total int) error <span class="cov8" title="1">{
        now := time.Now().UTC()

        _, err := s.db.NewUpdate().
                Model((*ObjectExtractionJob)(nil)).
                Set("processed_items = ?", processed).
                Set("total_items = ?", total).
                Set("updated_at = ?", now).
                Where("id = ?", jobID).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("update progress: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CancelJob cancels a pending or processing job
func (s *ObjectExtractionJobsService) CancelJob(ctx context.Context, jobID string) error <span class="cov8" title="1">{
        now := time.Now().UTC()

        res, err := s.db.NewUpdate().
                Model((*ObjectExtractionJob)(nil)).
                Set("status = ?", JobStatusCancelled).
                Set("completed_at = ?", now).
                Set("updated_at = ?", now).
                Where("id = ?", jobID).
                Where("status IN (?)", bun.In([]JobStatus{JobStatusPending, JobStatusProcessing})).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("cancel job: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := res.RowsAffected()
        if rowsAffected == 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("job not found or already completed")
        }</span>

        <span class="cov8" title="1">s.log.Info("object extraction job cancelled", slog.String("id", jobID))
        return nil</span>
}

// RecoverStaleJobs resets jobs stuck in 'processing' status back to 'pending'
func (s *ObjectExtractionJobsService) RecoverStaleJobs(ctx context.Context) (int, error) <span class="cov8" title="1">{
        threshold := time.Now().UTC().Add(-time.Duration(s.config.StaleThresholdMinutes) * time.Minute)
        now := time.Now().UTC()

        res, err := s.db.NewUpdate().
                Model((*ObjectExtractionJob)(nil)).
                Set("status = ?", JobStatusPending).
                Set("started_at = NULL").
                Set("updated_at = ?", now).
                Where("status = ?", JobStatusProcessing).
                Where("started_at &lt; ?", threshold).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("recover stale jobs: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := res.RowsAffected()
        if rowsAffected &gt; 0 </span><span class="cov8" title="1">{
                s.log.Warn("recovered stale object extraction jobs",
                        slog.Int64("count", rowsAffected),
                        slog.Int("thresholdMinutes", s.config.StaleThresholdMinutes))
        }</span>

        <span class="cov8" title="1">return int(rowsAffected), nil</span>
}

// FindByID finds a job by ID
func (s *ObjectExtractionJobsService) FindByID(ctx context.Context, jobID string) (*ObjectExtractionJob, error) <span class="cov8" title="1">{
        job := new(ObjectExtractionJob)
        err := s.db.NewSelect().
                Model(job).
                Where("id = ?", jobID).
                Scan(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("find by id: %w", err)</span>
        }
        <span class="cov8" title="1">return job, nil</span>
}

// FindByProject finds all jobs for a project with optional status filter
func (s *ObjectExtractionJobsService) FindByProject(ctx context.Context, projectID string, status *JobStatus, limit int) ([]*ObjectExtractionJob, error) <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov8" title="1">query := s.db.NewSelect().
                Model((*ObjectExtractionJob)(nil)).
                Where("project_id = ?", projectID).
                OrderExpr("created_at DESC").
                Limit(limit)

        if status != nil </span><span class="cov8" title="1">{
                query = query.Where("status = ?", *status)
        }</span>

        <span class="cov8" title="1">var jobs []*ObjectExtractionJob
        err := query.Scan(ctx, &amp;jobs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("find by project: %w", err)
        }</span>

        <span class="cov8" title="1">return jobs, nil</span>
}

// FindByDocument finds all jobs for a specific document
func (s *ObjectExtractionJobsService) FindByDocument(ctx context.Context, documentID string) ([]*ObjectExtractionJob, error) <span class="cov8" title="1">{
        var jobs []*ObjectExtractionJob
        err := s.db.NewSelect().
                Model(&amp;jobs).
                Where("document_id = ?", documentID).
                OrderExpr("created_at DESC").
                Scan(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("find by document: %w", err)
        }</span>
        <span class="cov8" title="1">return jobs, nil</span>
}

// ObjectExtractionStats contains statistics about object extraction jobs
type ObjectExtractionStats struct {
        Pending    int64 `json:"pending"`
        Processing int64 `json:"processing"`
        Completed  int64 `json:"completed"`
        Failed     int64 `json:"failed"`
        Cancelled  int64 `json:"cancelled"`
        Total      int64 `json:"total"`
}

// Stats returns statistics about object extraction jobs
func (s *ObjectExtractionJobsService) Stats(ctx context.Context, projectID *string) (*ObjectExtractionStats, error) <span class="cov8" title="1">{
        query := s.db.NewSelect().
                Model((*ObjectExtractionJob)(nil)).
                Column("status").
                ColumnExpr("COUNT(*) as count")

        if projectID != nil </span><span class="cov8" title="1">{
                query = query.Where("project_id = ?", *projectID)
        }</span>

        <span class="cov8" title="1">query = query.Group("status")

        var results []struct {
                Status JobStatus `bun:"status"`
                Count  int64     `bun:"count"`
        }

        err := query.Scan(ctx, &amp;results)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get stats: %w", err)
        }</span>

        <span class="cov8" title="1">stats := &amp;ObjectExtractionStats{}
        for _, r := range results </span><span class="cov8" title="1">{
                stats.Total += r.Count
                switch r.Status </span>{
                case JobStatusPending:<span class="cov8" title="1">
                        stats.Pending = r.Count</span>
                case JobStatusProcessing:<span class="cov0" title="0">
                        stats.Processing = r.Count</span>
                case JobStatusCompleted:<span class="cov8" title="1">
                        stats.Completed = r.Count</span>
                case JobStatusFailed:<span class="cov8" title="1">
                        stats.Failed = r.Count</span>
                case JobStatusCancelled:<span class="cov8" title="1">
                        stats.Cancelled = r.Count</span>
                }
        }

        <span class="cov8" title="1">return stats, nil</span>
}

// BulkCancelByProject cancels all pending/processing jobs for a project
func (s *ObjectExtractionJobsService) BulkCancelByProject(ctx context.Context, projectID string) (int, error) <span class="cov8" title="1">{
        now := time.Now().UTC()

        res, err := s.db.NewUpdate().
                Model((*ObjectExtractionJob)(nil)).
                Set("status = ?", JobStatusCancelled).
                Set("completed_at = ?", now).
                Set("updated_at = ?", now).
                Where("project_id = ?", projectID).
                Where("status IN (?)", bun.In([]JobStatus{JobStatusPending, JobStatusProcessing})).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("bulk cancel: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := res.RowsAffected()
        s.log.Info("bulk cancelled object extraction jobs",
                slog.String("projectId", projectID),
                slog.Int64("count", rowsAffected))

        return int(rowsAffected), nil</span>
}

// BulkRetryFailed resets all failed jobs for a project back to pending
func (s *ObjectExtractionJobsService) BulkRetryFailed(ctx context.Context, projectID string) (int, error) <span class="cov8" title="1">{
        now := time.Now().UTC()

        res, err := s.db.NewUpdate().
                Model((*ObjectExtractionJob)(nil)).
                Set("status = ?", JobStatusPending).
                Set("error_message = NULL").
                Set("error_details = NULL").
                Set("started_at = NULL").
                Set("completed_at = NULL").
                Set("updated_at = ?", now).
                Where("project_id = ?", projectID).
                Where("status = ?", JobStatusFailed).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("bulk retry: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := res.RowsAffected()
        s.log.Info("bulk retried failed object extraction jobs",
                slog.String("projectId", projectID),
                slog.Int64("count", rowsAffected))

        return int(rowsAffected), nil</span>
}

// DeleteCompleted deletes all completed/failed/cancelled jobs for a project
func (s *ObjectExtractionJobsService) DeleteCompleted(ctx context.Context, projectID string) (int, error) <span class="cov8" title="1">{
        res, err := s.db.NewDelete().
                Model((*ObjectExtractionJob)(nil)).
                Where("project_id = ?", projectID).
                Where("status IN (?)", bun.In([]JobStatus{JobStatusCompleted, JobStatusFailed, JobStatusCancelled})).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("delete completed: %w", err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := res.RowsAffected()
        s.log.Info("deleted completed object extraction jobs",
                slog.String("projectId", projectID),
                slog.Int64("count", rowsAffected))

        return int(rowsAffected), nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// Package extraction provides object extraction job processing.
package extraction

import (
        "context"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/google/uuid"

        "github.com/emergent/emergent-core/domain/documents"
        "github.com/emergent/emergent-core/domain/extraction/agents"
        "github.com/emergent/emergent-core/domain/graph"
        "github.com/emergent/emergent-core/pkg/adk"
        "github.com/emergent/emergent-core/pkg/logger"
)

// ObjectExtractionWorkerConfig holds configuration for the extraction worker.
type ObjectExtractionWorkerConfig struct {
        // PollInterval is how often to check for new jobs. Default: 5 seconds.
        PollInterval time.Duration

        // OrphanThreshold is the max acceptable orphan rate (0.0-1.0). Default: 0.3.
        OrphanThreshold float64

        // MaxRetries is the max number of relationship extraction retries. Default: 3.
        MaxRetries uint
}

// DefaultObjectExtractionWorkerConfig returns default worker configuration.
func DefaultObjectExtractionWorkerConfig() *ObjectExtractionWorkerConfig <span class="cov8" title="1">{
        return &amp;ObjectExtractionWorkerConfig{
                PollInterval:    5 * time.Second,
                OrphanThreshold: 0.3,
                MaxRetries:      3,
        }
}</span>

// SchemaProvider provides object and relationship schemas for extraction.
// This interface allows different implementations (e.g., from database, config, etc.).
type SchemaProvider interface {
        // GetProjectSchemas returns object and relationship schemas for a project.
        GetProjectSchemas(ctx context.Context, projectID string) (*ExtractionSchemas, error)
}

// ExtractionSchemas holds the schemas needed for extraction.
type ExtractionSchemas struct {
        ObjectSchemas       map[string]agents.ObjectSchema
        RelationshipSchemas map[string]agents.RelationshipSchema
}

// ObjectExtractionWorker processes object extraction jobs.
type ObjectExtractionWorker struct {
        jobsService    *ObjectExtractionJobsService
        graphService   *graph.Service
        docService     *documents.Service
        schemaProvider SchemaProvider
        modelFactory   *adk.ModelFactory
        config         *ObjectExtractionWorkerConfig
        log            *slog.Logger

        stopCh chan struct{}
        wg     sync.WaitGroup
}

// NewObjectExtractionWorker creates a new extraction worker.
func NewObjectExtractionWorker(
        jobsService *ObjectExtractionJobsService,
        graphService *graph.Service,
        docService *documents.Service,
        schemaProvider SchemaProvider,
        modelFactory *adk.ModelFactory,
        config *ObjectExtractionWorkerConfig,
        log *slog.Logger,
) *ObjectExtractionWorker <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = DefaultObjectExtractionWorkerConfig()
        }</span>
        <span class="cov0" title="0">return &amp;ObjectExtractionWorker{
                jobsService:    jobsService,
                graphService:   graphService,
                docService:     docService,
                schemaProvider: schemaProvider,
                modelFactory:   modelFactory,
                config:         config,
                log:            log.With(logger.Scope("object-extraction-worker")),
                stopCh:         make(chan struct{}),
        }</span>
}

// Start begins processing jobs in the background.
func (w *ObjectExtractionWorker) Start(ctx context.Context) <span class="cov0" title="0">{
        w.wg.Add(1)
        go w.run(ctx)
        w.log.Info("object extraction worker started",
                slog.Duration("poll_interval", w.config.PollInterval))
}</span>

// Stop gracefully stops the worker.
func (w *ObjectExtractionWorker) Stop() <span class="cov0" title="0">{
        close(w.stopCh)
        w.wg.Wait()
        w.log.Info("object extraction worker stopped")
}</span>

// run is the main worker loop.
func (w *ObjectExtractionWorker) run(ctx context.Context) <span class="cov0" title="0">{
        defer w.wg.Done()

        ticker := time.NewTicker(w.config.PollInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := w.processNextJob(ctx); err != nil </span><span class="cov0" title="0">{
                                w.log.Error("error processing job", logger.Error(err))
                        }</span>
                }
        }
}

// processNextJob dequeues and processes the next available job.
func (w *ObjectExtractionWorker) processNextJob(ctx context.Context) error <span class="cov0" title="0">{
        job, err := w.jobsService.Dequeue(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("dequeue job: %w", err)
        }</span>
        <span class="cov0" title="0">if job == nil </span><span class="cov0" title="0">{
                return nil // No jobs available
        }</span>

        <span class="cov0" title="0">w.log.Info("processing extraction job",
                slog.String("job_id", job.ID),
                slog.String("project_id", job.ProjectID),
                slog.String("job_type", string(job.JobType)))

        // Process the job
        result, err := w.processJob(ctx, job)
        if err != nil </span><span class="cov0" title="0">{
                w.log.Error("job failed",
                        slog.String("job_id", job.ID),
                        logger.Error(err))

                return w.jobsService.MarkFailed(ctx, job.ID, err.Error(), JSON{
                        "error_type": "processing_error",
                })
        }</span>

        // Mark completed
        <span class="cov0" title="0">return w.jobsService.MarkCompleted(ctx, job.ID, *result)</span>
}

// processJob processes a single extraction job.
func (w *ObjectExtractionWorker) processJob(ctx context.Context, job *ObjectExtractionJob) (*ObjectExtractionResults, error) <span class="cov0" title="0">{
        // Load document text
        documentText, err := w.loadDocumentText(ctx, job)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("load document text: %w", err)
        }</span>

        <span class="cov0" title="0">if documentText == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no document text to extract from")
        }</span>

        // Load schemas
        <span class="cov0" title="0">schemas, err := w.loadSchemas(ctx, job)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("load schemas: %w", err)
        }</span>

        // Create and run the extraction pipeline
        <span class="cov0" title="0">pipeline, err := agents.NewExtractionPipeline(agents.ExtractionPipelineConfig{
                ModelFactory:    w.modelFactory,
                OrphanThreshold: w.config.OrphanThreshold,
                MaxRetries:      w.config.MaxRetries,
                Logger:          w.log,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create pipeline: %w", err)
        }</span>

        // Run extraction
        <span class="cov0" title="0">pipelineOutput, err := pipeline.Run(ctx, agents.ExtractionPipelineInput{
                DocumentText:        documentText,
                ObjectSchemas:       schemas.ObjectSchemas,
                RelationshipSchemas: schemas.RelationshipSchemas,
                AllowedTypes:        job.EnabledTypes,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("run pipeline: %w", err)
        }</span>

        // Create graph objects and relationships
        <span class="cov0" title="0">result, err := w.persistResults(ctx, job, pipelineOutput)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("persist results: %w", err)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// loadDocumentText loads the text content for extraction.
func (w *ObjectExtractionWorker) loadDocumentText(ctx context.Context, job *ObjectExtractionJob) (string, error) <span class="cov0" title="0">{
        // Check source type
        sourceType := ""
        if job.SourceType != nil </span><span class="cov0" title="0">{
                sourceType = *job.SourceType
        }</span>

        <span class="cov0" title="0">switch sourceType </span>{
        case "manual":<span class="cov0" title="0">
                // Get text from source metadata
                if job.SourceMetadata != nil </span><span class="cov0" title="0">{
                        if text, ok := job.SourceMetadata["text"].(string); ok </span><span class="cov0" title="0">{
                                return text, nil
                        }</span>
                }
                <span class="cov0" title="0">return "", fmt.Errorf("manual source type requires text in source_metadata")</span>

        case "document", "":<span class="cov0" title="0">
                // Load from document
                if job.DocumentID == nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("document source type requires document_id")
                }</span>
                <span class="cov0" title="0">doc, err := w.docService.GetByID(ctx, job.ProjectID, *job.DocumentID)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("get document: %w", err)
                }</span>
                <span class="cov0" title="0">if doc.Content == nil || *doc.Content == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("document has no content")
                }</span>
                <span class="cov0" title="0">return *doc.Content, nil</span>

        default:<span class="cov0" title="0">
                return "", fmt.Errorf("unsupported source type: %s", sourceType)</span>
        }
}

// loadSchemas loads object and relationship schemas for the project.
func (w *ObjectExtractionWorker) loadSchemas(ctx context.Context, job *ObjectExtractionJob) (*ExtractionSchemas, error) <span class="cov0" title="0">{
        if w.schemaProvider != nil </span><span class="cov0" title="0">{
                return w.schemaProvider.GetProjectSchemas(ctx, job.ProjectID)
        }</span>

        // Fall back to extraction config if no schema provider
        <span class="cov0" title="0">schemas := &amp;ExtractionSchemas{
                ObjectSchemas:       make(map[string]agents.ObjectSchema),
                RelationshipSchemas: make(map[string]agents.RelationshipSchema),
        }

        // Try to get schemas from job's extraction config
        if job.ExtractionConfig != nil </span><span class="cov0" title="0">{
                if objSchemas, ok := job.ExtractionConfig["object_schemas"].(map[string]any); ok </span><span class="cov0" title="0">{
                        for name, schema := range objSchemas </span><span class="cov0" title="0">{
                                if schemaMap, ok := schema.(map[string]any); ok </span><span class="cov0" title="0">{
                                        schemas.ObjectSchemas[name] = convertToObjectSchema(schemaMap)
                                }</span>
                        }
                }
                <span class="cov0" title="0">if relSchemas, ok := job.ExtractionConfig["relationship_schemas"].(map[string]any); ok </span><span class="cov0" title="0">{
                        for name, schema := range relSchemas </span><span class="cov0" title="0">{
                                if schemaMap, ok := schema.(map[string]any); ok </span><span class="cov0" title="0">{
                                        schemas.RelationshipSchemas[name] = convertToRelationshipSchema(schemaMap)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return schemas, nil</span>
}

// persistResults creates graph objects and relationships from extraction results.
func (w *ObjectExtractionWorker) persistResults(
        ctx context.Context,
        job *ObjectExtractionJob,
        output *agents.ExtractionPipelineOutput,
) (*ObjectExtractionResults, error) <span class="cov0" title="0">{
        projectID, err := uuid.Parse(job.ProjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse project_id: %w", err)
        }</span>

        // Map temp_id -&gt; created object ID
        <span class="cov0" title="0">tempIDToObjectID := make(map[string]uuid.UUID)

        // Create graph objects
        objectsCreated := 0
        for _, entity := range output.Entities </span><span class="cov0" title="0">{
                properties := map[string]any{
                        "name":        entity.Name,
                        "description": entity.Description,
                }
                for k, v := range entity.Properties </span><span class="cov0" title="0">{
                        properties[k] = v
                }</span>

                // Add extraction metadata
                <span class="cov0" title="0">properties["_extraction_job_id"] = job.ID
                if job.SourceType != nil </span><span class="cov0" title="0">{
                        properties["_extraction_source"] = *job.SourceType
                }</span>

                <span class="cov0" title="0">graphObj, err := w.graphService.Create(ctx, projectID, &amp;graph.CreateGraphObjectRequest{
                        Type:       entity.Type,
                        Properties: properties,
                        Status:     stringPtr("suggested"),
                }, nil)
                if err != nil </span><span class="cov0" title="0">{
                        w.log.Warn("failed to create graph object",
                                slog.String("name", entity.Name),
                                slog.String("type", entity.Type),
                                logger.Error(err))
                        continue</span>
                }

                <span class="cov0" title="0">tempIDToObjectID[entity.TempID] = graphObj.ID
                objectsCreated++</span>
        }

        // Create relationships
        <span class="cov0" title="0">relationshipsCreated := 0
        for _, rel := range output.Relationships </span><span class="cov0" title="0">{
                srcID, srcOK := tempIDToObjectID[rel.SourceRef]
                dstID, dstOK := tempIDToObjectID[rel.TargetRef]

                if !srcOK || !dstOK </span><span class="cov0" title="0">{
                        w.log.Warn("relationship references unknown temp_id",
                                slog.String("source_ref", rel.SourceRef),
                                slog.String("target_ref", rel.TargetRef),
                                slog.Bool("src_found", srcOK),
                                slog.Bool("dst_found", dstOK))
                        continue</span>
                }

                <span class="cov0" title="0">properties := map[string]any{
                        "description":          rel.Description,
                        "_extraction_job_id":   job.ID,
                }

                _, err := w.graphService.CreateRelationship(ctx, projectID, &amp;graph.CreateGraphRelationshipRequest{
                        Type:       rel.Type,
                        SrcID:      srcID,
                        DstID:      dstID,
                        Properties: properties,
                })
                if err != nil </span><span class="cov0" title="0">{
                        w.log.Warn("failed to create relationship",
                                slog.String("type", rel.Type),
                                logger.Error(err))
                        continue</span>
                }
                <span class="cov0" title="0">relationshipsCreated++</span>
        }

        // Calculate discovered types
        <span class="cov0" title="0">discoveredTypes := make([]any, 0)
        typeSet := make(map[string]bool)
        for _, entity := range output.Entities </span><span class="cov0" title="0">{
                if !typeSet[entity.Type] </span><span class="cov0" title="0">{
                        typeSet[entity.Type] = true
                        discoveredTypes = append(discoveredTypes, entity.Type)
                }</span>
        }

        <span class="cov0" title="0">return &amp;ObjectExtractionResults{
                ObjectsCreated:       objectsCreated,
                RelationshipsCreated: relationshipsCreated,
                TotalItems:           len(output.Entities),
                ProcessedItems:       len(output.Entities),
                SuccessfulItems:      objectsCreated,
                FailedItems:          len(output.Entities) - objectsCreated,
                DiscoveredTypes:      discoveredTypes,
                DebugInfo: JSON{
                        "entity_count":       len(output.Entities),
                        "relationship_count": len(output.Relationships),
                        "orphan_rate":        agents.CalculateOrphanRate(output.Entities, output.Relationships),
                },
        }, nil</span>
}

// convertToObjectSchema converts a generic map to ObjectSchema.
func convertToObjectSchema(m map[string]any) agents.ObjectSchema <span class="cov8" title="1">{
        schema := agents.ObjectSchema{}

        if name, ok := m["name"].(string); ok </span><span class="cov8" title="1">{
                schema.Name = name
        }</span>
        <span class="cov8" title="1">if desc, ok := m["description"].(string); ok </span><span class="cov8" title="1">{
                schema.Description = desc
        }</span>
        <span class="cov8" title="1">if props, ok := m["properties"].(map[string]any); ok </span><span class="cov8" title="1">{
                schema.Properties = make(map[string]agents.PropertyDef)
                for k, v := range props </span><span class="cov8" title="1">{
                        if propMap, ok := v.(map[string]any); ok </span><span class="cov8" title="1">{
                                propDef := agents.PropertyDef{}
                                if t, ok := propMap["type"].(string); ok </span><span class="cov8" title="1">{
                                        propDef.Type = t
                                }</span>
                                <span class="cov8" title="1">if d, ok := propMap["description"].(string); ok </span><span class="cov8" title="1">{
                                        propDef.Description = d
                                }</span>
                                <span class="cov8" title="1">schema.Properties[k] = propDef</span>
                        }
                }
        }
        <span class="cov8" title="1">if req, ok := m["required"].([]any); ok </span><span class="cov8" title="1">{
                for _, r := range req </span><span class="cov8" title="1">{
                        if s, ok := r.(string); ok </span><span class="cov8" title="1">{
                                schema.Required = append(schema.Required, s)
                        }</span>
                }
        }

        <span class="cov8" title="1">return schema</span>
}

// convertToRelationshipSchema converts a generic map to RelationshipSchema.
func convertToRelationshipSchema(m map[string]any) agents.RelationshipSchema <span class="cov8" title="1">{
        schema := agents.RelationshipSchema{}

        if name, ok := m["name"].(string); ok </span><span class="cov8" title="1">{
                schema.Name = name
        }</span>
        <span class="cov8" title="1">if desc, ok := m["description"].(string); ok </span><span class="cov8" title="1">{
                schema.Description = desc
        }</span>
        <span class="cov8" title="1">if st, ok := m["source_types"].([]any); ok </span><span class="cov8" title="1">{
                for _, t := range st </span><span class="cov8" title="1">{
                        if s, ok := t.(string); ok </span><span class="cov8" title="1">{
                                schema.SourceTypes = append(schema.SourceTypes, s)
                        }</span>
                }
        }
        <span class="cov8" title="1">if tt, ok := m["target_types"].([]any); ok </span><span class="cov8" title="1">{
                for _, t := range tt </span><span class="cov8" title="1">{
                        if s, ok := t.(string); ok </span><span class="cov8" title="1">{
                                schema.TargetTypes = append(schema.TargetTypes, s)
                        }</span>
                }
        }
        <span class="cov8" title="1">if g, ok := m["extraction_guidelines"].(string); ok </span><span class="cov8" title="1">{
                schema.ExtractionGuidelines = g
        }</span>

        <span class="cov8" title="1">return schema</span>
}

// stringPtr returns a pointer to a string.
func stringPtr(s string) *string <span class="cov8" title="1">{
        return &amp;s
}</span>
</pre>
		
		<pre class="file" id="file55" style="display: none">// Package extraction provides object extraction job processing.
package extraction

import (
        "context"
        "database/sql"
        "encoding/json"
        "fmt"
        "log/slog"
        "time"

        "github.com/emergent/emergent-core/domain/extraction/agents"
        "github.com/emergent/emergent-core/pkg/logger"
        "github.com/uptrace/bun"
)

// GraphTemplatePack represents a template pack from kb.graph_template_packs.
// Template packs are GLOBAL resources shared across all organizations.
type GraphTemplatePack struct {
        bun.BaseModel `bun:"kb.graph_template_packs,alias:gtp"`

        ID                      string         `bun:"id,pk,type:uuid"`
        Name                    string         `bun:"name,notnull"`
        Version                 string         `bun:"version,notnull"`
        ParentVersionID         *string        `bun:"parent_version_id,type:uuid"`
        Draft                   bool           `bun:"draft,default:false"`
        Description             *string        `bun:"description"`
        Author                  *string        `bun:"author"`
        License                 *string        `bun:"license"`
        RepositoryURL           *string        `bun:"repository_url"`
        DocumentationURL        *string        `bun:"documentation_url"`
        Source                  *string        `bun:"source"` // manual, discovered, imported, system
        DiscoveryJobID          *string        `bun:"discovery_job_id,type:uuid"`
        PendingReview           bool           `bun:"pending_review,default:false"`
        ObjectTypeSchemas       JSON           `bun:"object_type_schemas,type:jsonb,notnull"`
        RelationshipTypeSchemas JSON           `bun:"relationship_type_schemas,type:jsonb,default:'{}'"`
        UIConfigs               JSON           `bun:"ui_configs,type:jsonb,default:'{}'"`
        ExtractionPrompts       JSON           `bun:"extraction_prompts,type:jsonb,default:'{}'"`
        SQLViews                JSON           `bun:"sql_views,type:jsonb,default:'[]'"`
        Signature               *string        `bun:"signature"`
        Checksum                *string        `bun:"checksum"`
        PublishedAt             time.Time      `bun:"published_at,default:now()"`
        DeprecatedAt            *time.Time     `bun:"deprecated_at"`
        SupersededBy            *string        `bun:"superseded_by"`
        CreatedAt               time.Time      `bun:"created_at,default:now()"`
        UpdatedAt               time.Time      `bun:"updated_at,default:now()"`
}

// ProjectTemplatePack represents a template pack installation for a project.
// Maps kb.project_template_packs table.
type ProjectTemplatePack struct {
        bun.BaseModel `bun:"kb.project_template_packs,alias:ptp"`

        ID             string                      `bun:"id,pk,type:uuid"`
        ProjectID      string                      `bun:"project_id,notnull,type:uuid"`
        TemplatePackID string                      `bun:"template_pack_id,notnull,type:uuid"`
        InstalledAt    time.Time                   `bun:"installed_at,default:now()"`
        InstalledBy    *string                     `bun:"installed_by,type:uuid"`
        Active         bool                        `bun:"active,default:true"`
        Customizations *TemplatePackCustomizations `bun:"customizations,type:jsonb,default:'{}'"`
        CreatedAt      time.Time                   `bun:"created_at,default:now()"`
        UpdatedAt      time.Time                   `bun:"updated_at,default:now()"`

        // Joined fields
        TemplatePack *GraphTemplatePack `bun:"rel:belongs-to,join:template_pack_id=id"`
}

// TemplatePackCustomizations holds installation-specific customizations.
type TemplatePackCustomizations struct {
        EnabledTypes    []string       `json:"enabledTypes,omitempty"`
        DisabledTypes   []string       `json:"disabledTypes,omitempty"`
        SchemaOverrides map[string]any `json:"schemaOverrides,omitempty"`
}

// Scan implements sql.Scanner for TemplatePackCustomizations.
func (c *TemplatePackCustomizations) Scan(value any) error <span class="cov8" title="1">{
        if value == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">switch v := value.(type) </span>{
        case []byte:<span class="cov8" title="1">
                return json.Unmarshal(v, c)</span>
        case string:<span class="cov8" title="1">
                return json.Unmarshal([]byte(v), c)</span>
        default:<span class="cov8" title="1">
                return fmt.Errorf("unsupported type for TemplatePackCustomizations: %T", value)</span>
        }
}

// Value implements driver.Valuer for TemplatePackCustomizations.
func (c TemplatePackCustomizations) Value() (any, error) <span class="cov8" title="1">{
        return json.Marshal(c)
}</span>

// TemplatePackSchemaProvider implements SchemaProvider by loading schemas
// from template packs assigned to a project.
type TemplatePackSchemaProvider struct {
        db  bun.IDB
        log *slog.Logger
}

// NewTemplatePackSchemaProvider creates a new template pack schema provider.
func NewTemplatePackSchemaProvider(db bun.IDB, log *slog.Logger) *TemplatePackSchemaProvider <span class="cov0" title="0">{
        return &amp;TemplatePackSchemaProvider{
                db:  db,
                log: log.With(logger.Scope("template-pack-schema-provider")),
        }
}</span>

// GetProjectSchemas loads and merges schemas from all active template packs for a project.
// Later packs override earlier ones for the same type.
func (p *TemplatePackSchemaProvider) GetProjectSchemas(
        ctx context.Context,
        projectID string,
) (*ExtractionSchemas, error) <span class="cov0" title="0">{
        // Get all active template pack assignments for this project
        var assignments []ProjectTemplatePack
        err := p.db.NewSelect().
                Model(&amp;assignments).
                Relation("TemplatePack").
                Where("ptp.project_id = ?", projectID).
                Where("ptp.active = true").
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return &amp;ExtractionSchemas{
                                ObjectSchemas:       make(map[string]agents.ObjectSchema),
                                RelationshipSchemas: make(map[string]agents.RelationshipSchema),
                        }, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("query project template packs: %w", err)</span>
        }

        <span class="cov0" title="0">if len(assignments) == 0 </span><span class="cov0" title="0">{
                return &amp;ExtractionSchemas{
                        ObjectSchemas:       make(map[string]agents.ObjectSchema),
                        RelationshipSchemas: make(map[string]agents.RelationshipSchema),
                }, nil
        }</span>

        // Merge all schemas from all packs
        <span class="cov0" title="0">objectSchemas := make(map[string]agents.ObjectSchema)
        relationshipSchemas := make(map[string]agents.RelationshipSchema)

        for _, assignment := range assignments </span><span class="cov0" title="0">{
                if assignment.TemplatePack == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">pack := assignment.TemplatePack

                // Apply customizations
                enabledTypes := make(map[string]bool)
                disabledTypes := make(map[string]bool)
                var schemaOverrides map[string]any

                if assignment.Customizations != nil </span><span class="cov0" title="0">{
                        for _, t := range assignment.Customizations.EnabledTypes </span><span class="cov0" title="0">{
                                enabledTypes[t] = true
                        }</span>
                        <span class="cov0" title="0">for _, t := range assignment.Customizations.DisabledTypes </span><span class="cov0" title="0">{
                                disabledTypes[t] = true
                        }</span>
                        <span class="cov0" title="0">schemaOverrides = assignment.Customizations.SchemaOverrides</span>
                }

                // Merge object type schemas
                <span class="cov0" title="0">objSchemas := parseObjectTypeSchemas(pack.ObjectTypeSchemas)
                for typeName, schema := range objSchemas </span><span class="cov0" title="0">{
                        // Skip disabled types
                        if disabledTypes[typeName] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // If enabledTypes is set, only include those types
                        <span class="cov0" title="0">if len(enabledTypes) &gt; 0 &amp;&amp; !enabledTypes[typeName] </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Apply schema overrides if present
                        <span class="cov0" title="0">if overrides, ok := schemaOverrides[typeName]; ok </span><span class="cov0" title="0">{
                                schema = applySchemaOverrides(schema, overrides)
                        }</span>

                        <span class="cov0" title="0">objectSchemas[typeName] = schema</span>
                }

                // Merge relationship type schemas
                <span class="cov0" title="0">relSchemas := parseRelationshipTypeSchemas(pack.RelationshipTypeSchemas)
                for typeName, schema := range relSchemas </span><span class="cov0" title="0">{
                        // Skip disabled types
                        if disabledTypes[typeName] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // If enabledTypes is set, only include those types
                        <span class="cov0" title="0">if len(enabledTypes) &gt; 0 &amp;&amp; !enabledTypes[typeName] </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">relationshipSchemas[typeName] = schema</span>
                }

                <span class="cov0" title="0">p.log.Debug("merged template pack schemas",
                        slog.String("pack_name", pack.Name),
                        slog.String("pack_version", pack.Version),
                        slog.Int("object_types", len(objSchemas)),
                        slog.Int("relationship_types", len(relSchemas)))</span>
        }

        <span class="cov0" title="0">p.log.Info("loaded project schemas",
                slog.String("project_id", projectID),
                slog.Int("template_packs", len(assignments)),
                slog.Int("object_types", len(objectSchemas)),
                slog.Int("relationship_types", len(relationshipSchemas)))

        return &amp;ExtractionSchemas{
                ObjectSchemas:       objectSchemas,
                RelationshipSchemas: relationshipSchemas,
        }, nil</span>
}

// parseObjectTypeSchemas converts JSON object_type_schemas to map of ObjectSchema.
func parseObjectTypeSchemas(raw JSON) map[string]agents.ObjectSchema <span class="cov8" title="1">{
        schemas := make(map[string]agents.ObjectSchema)
        if raw == nil </span><span class="cov8" title="1">{
                return schemas
        }</span>

        <span class="cov8" title="1">for typeName, schemaRaw := range raw </span><span class="cov8" title="1">{
                schemaMap, ok := schemaRaw.(map[string]any)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">schema := agents.ObjectSchema{
                        Name: typeName,
                }

                if desc, ok := schemaMap["description"].(string); ok </span><span class="cov8" title="1">{
                        schema.Description = desc
                }</span>

                <span class="cov8" title="1">if props, ok := schemaMap["properties"].(map[string]any); ok </span><span class="cov8" title="1">{
                        schema.Properties = make(map[string]agents.PropertyDef)
                        for propName, propRaw := range props </span><span class="cov8" title="1">{
                                propMap, ok := propRaw.(map[string]any)
                                if !ok </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">propDef := agents.PropertyDef{}
                                if t, ok := propMap["type"].(string); ok </span><span class="cov8" title="1">{
                                        propDef.Type = t
                                }</span>
                                <span class="cov8" title="1">if d, ok := propMap["description"].(string); ok </span><span class="cov8" title="1">{
                                        propDef.Description = d
                                }</span>
                                <span class="cov8" title="1">schema.Properties[propName] = propDef</span>
                        }
                }

                <span class="cov8" title="1">if req, ok := schemaMap["required"].([]any); ok </span><span class="cov8" title="1">{
                        for _, r := range req </span><span class="cov8" title="1">{
                                if s, ok := r.(string); ok </span><span class="cov8" title="1">{
                                        schema.Required = append(schema.Required, s)
                                }</span>
                        }
                }

                // Check for extraction_guidelines in extraction_prompts
                <span class="cov8" title="1">if guidelines, ok := schemaMap["extraction_guidelines"].(string); ok </span><span class="cov8" title="1">{
                        schema.ExtractionGuidelines = guidelines
                }</span>

                <span class="cov8" title="1">schemas[typeName] = schema</span>
        }

        <span class="cov8" title="1">return schemas</span>
}

// parseRelationshipTypeSchemas converts JSON relationship_type_schemas to map of RelationshipSchema.
func parseRelationshipTypeSchemas(raw JSON) map[string]agents.RelationshipSchema <span class="cov8" title="1">{
        schemas := make(map[string]agents.RelationshipSchema)
        if raw == nil </span><span class="cov8" title="1">{
                return schemas
        }</span>

        <span class="cov8" title="1">for typeName, schemaRaw := range raw </span><span class="cov8" title="1">{
                schemaMap, ok := schemaRaw.(map[string]any)
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">schema := agents.RelationshipSchema{
                        Name: typeName,
                }

                if desc, ok := schemaMap["description"].(string); ok </span><span class="cov8" title="1">{
                        schema.Description = desc
                }</span>

                <span class="cov8" title="1">if st, ok := schemaMap["source_types"].([]any); ok </span><span class="cov8" title="1">{
                        for _, t := range st </span><span class="cov8" title="1">{
                                if s, ok := t.(string); ok </span><span class="cov8" title="1">{
                                        schema.SourceTypes = append(schema.SourceTypes, s)
                                }</span>
                        }
                }

                <span class="cov8" title="1">if tt, ok := schemaMap["target_types"].([]any); ok </span><span class="cov8" title="1">{
                        for _, t := range tt </span><span class="cov8" title="1">{
                                if s, ok := t.(string); ok </span><span class="cov8" title="1">{
                                        schema.TargetTypes = append(schema.TargetTypes, s)
                                }</span>
                        }
                }

                <span class="cov8" title="1">if guidelines, ok := schemaMap["extraction_guidelines"].(string); ok </span><span class="cov8" title="1">{
                        schema.ExtractionGuidelines = guidelines
                }</span>

                <span class="cov8" title="1">schemas[typeName] = schema</span>
        }

        <span class="cov8" title="1">return schemas</span>
}

// applySchemaOverrides merges overrides into the base schema.
func applySchemaOverrides(base agents.ObjectSchema, overrides any) agents.ObjectSchema <span class="cov8" title="1">{
        overrideMap, ok := overrides.(map[string]any)
        if !ok </span><span class="cov8" title="1">{
                return base
        }</span>

        // Override description
        <span class="cov8" title="1">if desc, ok := overrideMap["description"].(string); ok </span><span class="cov8" title="1">{
                base.Description = desc
        }</span>

        // Merge properties
        <span class="cov8" title="1">if props, ok := overrideMap["properties"].(map[string]any); ok </span><span class="cov8" title="1">{
                if base.Properties == nil </span><span class="cov8" title="1">{
                        base.Properties = make(map[string]agents.PropertyDef)
                }</span>
                <span class="cov8" title="1">for propName, propRaw := range props </span><span class="cov8" title="1">{
                        propMap, ok := propRaw.(map[string]any)
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">propDef := base.Properties[propName]
                        if t, ok := propMap["type"].(string); ok </span><span class="cov8" title="1">{
                                propDef.Type = t
                        }</span>
                        <span class="cov8" title="1">if d, ok := propMap["description"].(string); ok </span><span class="cov8" title="1">{
                                propDef.Description = d
                        }</span>
                        <span class="cov8" title="1">base.Properties[propName] = propDef</span>
                }
        }

        // Override required
        <span class="cov8" title="1">if req, ok := overrideMap["required"].([]any); ok </span><span class="cov8" title="1">{
                base.Required = nil
                for _, r := range req </span><span class="cov8" title="1">{
                        if s, ok := r.(string); ok </span><span class="cov8" title="1">{
                                base.Required = append(base.Required, s)
                        }</span>
                }
        }

        // Override extraction guidelines
        <span class="cov8" title="1">if guidelines, ok := overrideMap["extraction_guidelines"].(string); ok </span><span class="cov8" title="1">{
                base.ExtractionGuidelines = guidelines
        }</span>

        <span class="cov8" title="1">return base</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package graph

import (
        "time"

        "github.com/google/uuid"
)

// CreateGraphObjectRequest is the request body for creating a graph object.
type CreateGraphObjectRequest struct {
        Type       string         `json:"type" validate:"required,max=64"`
        Key        *string        `json:"key,omitempty" validate:"omitempty,max=128"`
        Status     *string        `json:"status,omitempty" validate:"omitempty,max=64"`
        Properties map[string]any `json:"properties,omitempty"`
        Labels     []string       `json:"labels,omitempty" validate:"omitempty,max=32,dive,max=64"`
        BranchID   *uuid.UUID     `json:"branch_id,omitempty"`
}

// PatchGraphObjectRequest is the request body for patching a graph object.
// Patching creates a new version.
type PatchGraphObjectRequest struct {
        Properties    map[string]any `json:"properties,omitempty"`
        Labels        []string       `json:"labels,omitempty"`
        ReplaceLabels bool           `json:"replaceLabels,omitempty"`
        Status        *string        `json:"status,omitempty"`
}

// GraphObjectResponse is the API response for a graph object.
type GraphObjectResponse struct {
        ID                uuid.UUID      `json:"id"`
        ProjectID         uuid.UUID      `json:"project_id"`
        BranchID          *uuid.UUID     `json:"branch_id,omitempty"`
        CanonicalID       uuid.UUID      `json:"canonical_id"`
        SupersedesID      *uuid.UUID     `json:"supersedes_id,omitempty"`
        Version           int            `json:"version"`
        Type              string         `json:"type"`
        Key               *string        `json:"key,omitempty"`
        Status            *string        `json:"status,omitempty"`
        Properties        map[string]any `json:"properties"`
        Labels            []string       `json:"labels"`
        DeletedAt         *time.Time     `json:"deleted_at,omitempty"`
        ChangeSummary     map[string]any `json:"change_summary,omitempty"`
        CreatedAt         time.Time      `json:"created_at"`
        RevisionCount     *int           `json:"revision_count,omitempty"`
        RelationshipCount *int           `json:"relationship_count,omitempty"`
}

// ToResponse converts a GraphObject entity to API response.
func (o *GraphObject) ToResponse() *GraphObjectResponse <span class="cov8" title="1">{
        return &amp;GraphObjectResponse{
                ID:                o.ID,
                ProjectID:         o.ProjectID,
                BranchID:          o.BranchID,
                CanonicalID:       o.CanonicalID,
                SupersedesID:      o.SupersedesID,
                Version:           o.Version,
                Type:              o.Type,
                Key:               o.Key,
                Status:            o.Status,
                Properties:        o.Properties,
                Labels:            o.Labels,
                DeletedAt:         o.DeletedAt,
                ChangeSummary:     o.ChangeSummary,
                CreatedAt:         o.CreatedAt,
                RevisionCount:     o.RevisionCount,
                RelationshipCount: o.RelationshipCount,
        }
}</span>

// SearchGraphObjectsRequest contains search/filter parameters.
type SearchGraphObjectsRequest struct {
        Types       []string   `query:"types"`
        Labels      []string   `query:"labels"`
        Status      *string    `query:"status"`
        Key         *string    `query:"key"`
        BranchID    *uuid.UUID `query:"branch_id"`
        IncludeDeleted bool    `query:"include_deleted"`
        Limit       int        `query:"limit"`
        Cursor      *string    `query:"cursor"`
}

// SearchGraphObjectsResponse is the paginated search response.
type SearchGraphObjectsResponse struct {
        Data       []*GraphObjectResponse `json:"data"`
        NextCursor *string                `json:"nextCursor,omitempty"`
        HasMore    bool                   `json:"hasMore"`
        Total      *int                   `json:"total,omitempty"`
}

// CreateGraphRelationshipRequest is the request body for creating a relationship.
type CreateGraphRelationshipRequest struct {
        Type       string         `json:"type" validate:"required,max=64"`
        SrcID      uuid.UUID      `json:"src_id" validate:"required"`
        DstID      uuid.UUID      `json:"dst_id" validate:"required"`
        Properties map[string]any `json:"properties,omitempty"`
        Weight     *float32       `json:"weight,omitempty"`
        BranchID   *uuid.UUID     `json:"branch_id,omitempty"`
}

// PatchGraphRelationshipRequest is the request body for patching a relationship.
type PatchGraphRelationshipRequest struct {
        Properties map[string]any `json:"properties,omitempty"`
        Weight     *float32       `json:"weight,omitempty"`
}

// GraphRelationshipResponse is the API response for a relationship.
type GraphRelationshipResponse struct {
        ID            uuid.UUID      `json:"id"`
        ProjectID     uuid.UUID      `json:"project_id"`
        BranchID      *uuid.UUID     `json:"branch_id,omitempty"`
        CanonicalID   uuid.UUID      `json:"canonical_id"`
        SupersedesID  *uuid.UUID     `json:"supersedes_id,omitempty"`
        Version       int            `json:"version"`
        Type          string         `json:"type"`
        SrcID         uuid.UUID      `json:"src_id"`
        DstID         uuid.UUID      `json:"dst_id"`
        Properties    map[string]any `json:"properties"`
        Weight        *float32       `json:"weight,omitempty"`
        DeletedAt     *time.Time     `json:"deleted_at,omitempty"`
        ChangeSummary map[string]any `json:"change_summary,omitempty"`
        CreatedAt     time.Time      `json:"created_at"`
}

// ToResponse converts a GraphRelationship entity to API response.
func (r *GraphRelationship) ToResponse() *GraphRelationshipResponse <span class="cov8" title="1">{
        return &amp;GraphRelationshipResponse{
                ID:            r.ID,
                ProjectID:     r.ProjectID,
                BranchID:      r.BranchID,
                CanonicalID:   r.CanonicalID,
                SupersedesID:  r.SupersedesID,
                Version:       r.Version,
                Type:          r.Type,
                SrcID:         r.SrcID,
                DstID:         r.DstID,
                Properties:    r.Properties,
                Weight:        r.Weight,
                DeletedAt:     r.DeletedAt,
                ChangeSummary: r.ChangeSummary,
                CreatedAt:     r.CreatedAt,
        }
}</span>

// GetObjectEdgesResponse is the response for listing edges of an object.
type GetObjectEdgesResponse struct {
        Incoming []*GraphRelationshipResponse `json:"incoming"`
        Outgoing []*GraphRelationshipResponse `json:"outgoing"`
}

// ObjectHistoryResponse is the response for version history.
type ObjectHistoryResponse struct {
        Versions []*GraphObjectResponse `json:"versions"`
}

// BulkUpdateStatusRequest is the request for bulk status updates.
type BulkUpdateStatusRequest struct {
        IDs    []uuid.UUID `json:"ids" validate:"required,min=1,max=100"`
        Status string      `json:"status" validate:"required,max=64"`
}

// BulkUpdateStatusResponse is the response for bulk status updates.
type BulkUpdateStatusResponse struct {
        Updated int `json:"updated"`
}

// =============================================================================
// Search DTOs
// =============================================================================

// FTSSearchRequest is the request for full-text search.
type FTSSearchRequest struct {
        Query          string     `query:"q"`
        Types          []string   `query:"types"`
        Labels         []string   `query:"labels"`
        Status         *string    `query:"status"`
        BranchID       *uuid.UUID `query:"branch_id"`
        IncludeDeleted bool       `query:"include_deleted"`
        Limit          int        `query:"limit"`
}

// VectorSearchRequest is the request for vector similarity search.
type VectorSearchRequest struct {
        Vector         []float32  `json:"vector" validate:"required"`
        Types          []string   `json:"types,omitempty"`
        Labels         []string   `json:"labels,omitempty"`
        Status         *string    `json:"status,omitempty"`
        BranchID       *uuid.UUID `json:"branchId,omitempty"`
        IncludeDeleted bool       `json:"includeDeleted,omitempty"`
        MaxDistance    *float32   `json:"maxDistance,omitempty"`
        Limit          int        `json:"limit,omitempty"`
}

// HybridSearchRequest is the request for hybrid (FTS + vector) search.
type HybridSearchRequest struct {
        Query          string     `json:"query" validate:"required"`
        Vector         []float32  `json:"vector,omitempty"`
        Types          []string   `json:"types,omitempty"`
        Labels         []string   `json:"labels,omitempty"`
        Status         *string    `json:"status,omitempty"`
        BranchID       *uuid.UUID `json:"branchId,omitempty"`
        IncludeDeleted bool       `json:"includeDeleted,omitempty"`
        LexicalWeight  *float32   `json:"lexicalWeight,omitempty"`
        VectorWeight   *float32   `json:"vectorWeight,omitempty"`
        Limit          int        `json:"limit,omitempty"`
}

// SearchResultItem represents a single search result with scores.
type SearchResultItem struct {
        Object        *GraphObjectResponse `json:"object"`
        Score         float32              `json:"score"`
        LexicalScore  *float32             `json:"lexicalScore,omitempty"`
        VectorScore   *float32             `json:"vectorScore,omitempty"`
        VectorDist    *float32             `json:"vectorDist,omitempty"`
}

// SearchResponse is the response for all search types.
type SearchResponse struct {
        Data    []*SearchResultItem `json:"data"`
        Total   int                 `json:"total"`
        HasMore bool                `json:"hasMore"`
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package graph

import (
        "encoding/json"
        "net/http"
        "strconv"

        "github.com/google/uuid"
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

// Handler handles HTTP requests for graph operations.
type Handler struct {
        svc *Service
}

// NewHandler creates a new graph handler.
func NewHandler(svc *Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{svc: svc}
}</span>

// getProjectID extracts and parses the project ID from the auth user context.
func getProjectID(c echo.Context) (uuid.UUID, error) <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return uuid.Nil, apperror.ErrUnauthorized
        }</span>

        // First check API token project ID (automatically set for API token auth)
        <span class="cov8" title="1">if user.APITokenProjectID != "" </span><span class="cov0" title="0">{
                return uuid.Parse(user.APITokenProjectID)
        }</span>

        // Then check X-Project-ID header
        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov8" title="1">{
                return uuid.Nil, apperror.ErrBadRequest.WithMessage("project_id is required")
        }</span>

        <span class="cov8" title="1">return uuid.Parse(user.ProjectID)</span>
}

// getUserID extracts and parses the user ID from the auth user context.
func getUserID(c echo.Context) (*uuid.UUID, error) <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil || user.ID == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;id, nil</span>
}

// ListObjects returns graph objects matching query parameters.
// GET /api/v2/graph/objects/search
func (h *Handler) ListObjects(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        // Parse query parameters
        <span class="cov8" title="1">params := ListParams{
                ProjectID:      projectID,
                IncludeDeleted: c.QueryParam("include_deleted") == "true",
                Limit:          50,
        }

        if limitStr := c.QueryParam("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if limit, err := strconv.Atoi(limitStr); err == nil </span><span class="cov8" title="1">{
                        params.Limit = limit
                }</span>
        }

        <span class="cov8" title="1">if cursor := c.QueryParam("cursor"); cursor != "" </span><span class="cov8" title="1">{
                params.Cursor = &amp;cursor
        }</span>

        <span class="cov8" title="1">if types := c.QueryParams()["types"]; len(types) &gt; 0 </span><span class="cov8" title="1">{
                params.Types = types
        }</span>

        <span class="cov8" title="1">if labels := c.QueryParams()["labels"]; len(labels) &gt; 0 </span><span class="cov0" title="0">{
                params.Labels = labels
        }</span>

        <span class="cov8" title="1">if status := c.QueryParam("status"); status != "" </span><span class="cov0" title="0">{
                params.Status = &amp;status
        }</span>

        <span class="cov8" title="1">if key := c.QueryParam("key"); key != "" </span><span class="cov0" title="0">{
                params.Key = &amp;key
        }</span>

        <span class="cov8" title="1">if branchIDStr := c.QueryParam("branch_id"); branchIDStr != "" </span><span class="cov0" title="0">{
                branchID, err := uuid.Parse(branchIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return apperror.ErrBadRequest.WithMessage("invalid branch_id")
                }</span>
                <span class="cov0" title="0">params.BranchID = &amp;branchID</span>
        }

        <span class="cov8" title="1">result, err := h.svc.List(c.Request().Context(), params)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// GetObject returns a single graph object by ID.
// GET /api/v2/graph/objects/:id
func (h *Handler) GetObject(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid object id")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.GetByID(c.Request().Context(), projectID, id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// CreateObject creates a new graph object.
// POST /api/v2/graph/objects
func (h *Handler) CreateObject(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">var req CreateGraphObjectRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        <span class="cov8" title="1">if req.Type == "" </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("type is required")
        }</span>

        <span class="cov8" title="1">actorID, _ := getUserID(c)
        result, err := h.svc.Create(c.Request().Context(), projectID, &amp;req, actorID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, result)</span>
}

// PatchObject updates a graph object by creating a new version.
// PATCH /api/v2/graph/objects/:id
func (h *Handler) PatchObject(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid object id")
        }</span>

        <span class="cov8" title="1">var req PatchGraphObjectRequest
        if err := json.NewDecoder(c.Request().Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        <span class="cov8" title="1">actorID, _ := getUserID(c)
        result, err := h.svc.Patch(c.Request().Context(), projectID, id, &amp;req, actorID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// DeleteObject soft-deletes a graph object.
// DELETE /api/v2/graph/objects/:id
func (h *Handler) DeleteObject(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid object id")
        }</span>

        <span class="cov8" title="1">actorID, _ := getUserID(c)
        if err := h.svc.Delete(c.Request().Context(), projectID, id, actorID); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, map[string]string{"status": "deleted"})</span>
}

// RestoreObject restores a soft-deleted graph object.
// POST /api/v2/graph/objects/:id/restore
func (h *Handler) RestoreObject(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid object id")
        }</span>

        <span class="cov8" title="1">actorID, _ := getUserID(c)
        result, err := h.svc.Restore(c.Request().Context(), projectID, id, actorID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// GetObjectHistory returns version history for a graph object.
// GET /api/v2/graph/objects/:id/history
func (h *Handler) GetObjectHistory(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid object id")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.GetHistory(c.Request().Context(), projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// GetObjectEdges returns incoming and outgoing relationships for an object.
// GET /api/v2/graph/objects/:id/edges
func (h *Handler) GetObjectEdges(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid object id")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.GetEdges(c.Request().Context(), projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// =============================================================================
// Relationship Handlers
// =============================================================================

// ListRelationships returns relationships matching query parameters.
// GET /api/v2/graph/relationships/search
func (h *Handler) ListRelationships(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        // Parse query parameters
        <span class="cov8" title="1">params := RelationshipListParams{
                ProjectID:      projectID,
                IncludeDeleted: c.QueryParam("include_deleted") == "true",
                Limit:          20,
        }

        if limitStr := c.QueryParam("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil </span><span class="cov0" title="0">{
                        params.Limit = limit
                }</span>
        }

        <span class="cov8" title="1">if cursor := c.QueryParam("cursor"); cursor != "" </span><span class="cov0" title="0">{
                params.Cursor = &amp;cursor
        }</span>

        <span class="cov8" title="1">if relType := c.QueryParam("type"); relType != "" </span><span class="cov8" title="1">{
                params.Type = &amp;relType
        }</span>

        <span class="cov8" title="1">if srcID := c.QueryParam("src_id"); srcID != "" </span><span class="cov8" title="1">{
                id, err := uuid.Parse(srcID)
                if err != nil </span><span class="cov0" title="0">{
                        return apperror.ErrBadRequest.WithMessage("invalid src_id")
                }</span>
                <span class="cov8" title="1">params.SrcID = &amp;id</span>
        }

        <span class="cov8" title="1">if dstID := c.QueryParam("dst_id"); dstID != "" </span><span class="cov0" title="0">{
                id, err := uuid.Parse(dstID)
                if err != nil </span><span class="cov0" title="0">{
                        return apperror.ErrBadRequest.WithMessage("invalid dst_id")
                }</span>
                <span class="cov0" title="0">params.DstID = &amp;id</span>
        }

        <span class="cov8" title="1">if order := c.QueryParam("order"); order != "" </span><span class="cov0" title="0">{
                params.Order = order
        }</span>

        <span class="cov8" title="1">if branchIDStr := c.QueryParam("branch_id"); branchIDStr != "" </span><span class="cov0" title="0">{
                branchID, err := uuid.Parse(branchIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return apperror.ErrBadRequest.WithMessage("invalid branch_id")
                }</span>
                <span class="cov0" title="0">params.BranchID = &amp;branchID</span>
        }

        <span class="cov8" title="1">result, err := h.svc.ListRelationships(c.Request().Context(), params)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// GetRelationship returns a single relationship by ID.
// GET /api/v2/graph/relationships/:id
func (h *Handler) GetRelationship(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid relationship id")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.GetRelationship(c.Request().Context(), projectID, id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// CreateRelationship creates a new relationship.
// POST /api/v2/graph/relationships
func (h *Handler) CreateRelationship(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">var req CreateGraphRelationshipRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        <span class="cov8" title="1">if req.Type == "" </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("type is required")
        }</span>
        <span class="cov8" title="1">if req.SrcID == uuid.Nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("src_id is required")
        }</span>
        <span class="cov8" title="1">if req.DstID == uuid.Nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("dst_id is required")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.CreateRelationship(c.Request().Context(), projectID, &amp;req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, result)</span>
}

// PatchRelationship updates a relationship by creating a new version.
// PATCH /api/v2/graph/relationships/:id
func (h *Handler) PatchRelationship(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid relationship id")
        }</span>

        <span class="cov8" title="1">var req PatchGraphRelationshipRequest
        if err := json.NewDecoder(c.Request().Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.PatchRelationship(c.Request().Context(), projectID, id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// DeleteRelationship soft-deletes a relationship.
// DELETE /api/v2/graph/relationships/:id
func (h *Handler) DeleteRelationship(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid relationship id")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.DeleteRelationship(c.Request().Context(), projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// RestoreRelationship restores a soft-deleted relationship.
// POST /api/v2/graph/relationships/:id/restore
func (h *Handler) RestoreRelationship(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid relationship id")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.RestoreRelationship(c.Request().Context(), projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, result)</span>
}

// GetRelationshipHistory returns version history for a relationship.
// GET /api/v2/graph/relationships/:id/history
func (h *Handler) GetRelationshipHistory(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">id, err := uuid.Parse(c.Param("id"))
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid relationship id")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.GetRelationshipHistory(c.Request().Context(), projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// =============================================================================
// Search Handlers
// =============================================================================

// FTSSearch performs full-text search on graph objects.
// GET /api/v2/graph/objects/fts
func (h *Handler) FTSSearch(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        // Parse query parameters
        <span class="cov8" title="1">req := &amp;FTSSearchRequest{
                Query:          c.QueryParam("q"),
                IncludeDeleted: c.QueryParam("include_deleted") == "true",
                Limit:          20,
        }

        if req.Query == "" </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("query parameter 'q' is required")
        }</span>

        <span class="cov8" title="1">if limitStr := c.QueryParam("limit"); limitStr != "" </span><span class="cov0" title="0">{
                if limit, err := strconv.Atoi(limitStr); err == nil </span><span class="cov0" title="0">{
                        req.Limit = limit
                }</span>
        }

        <span class="cov8" title="1">if types := c.QueryParams()["types"]; len(types) &gt; 0 </span><span class="cov8" title="1">{
                req.Types = types
        }</span>

        <span class="cov8" title="1">if labels := c.QueryParams()["labels"]; len(labels) &gt; 0 </span><span class="cov0" title="0">{
                req.Labels = labels
        }</span>

        <span class="cov8" title="1">if status := c.QueryParam("status"); status != "" </span><span class="cov0" title="0">{
                req.Status = &amp;status
        }</span>

        <span class="cov8" title="1">if branchIDStr := c.QueryParam("branch_id"); branchIDStr != "" </span><span class="cov0" title="0">{
                branchID, err := uuid.Parse(branchIDStr)
                if err != nil </span><span class="cov0" title="0">{
                        return apperror.ErrBadRequest.WithMessage("invalid branch_id")
                }</span>
                <span class="cov0" title="0">req.BranchID = &amp;branchID</span>
        }

        <span class="cov8" title="1">result, err := h.svc.FTSSearch(c.Request().Context(), projectID, req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// VectorSearch performs vector similarity search on graph objects.
// POST /api/v2/graph/objects/vector-search
func (h *Handler) VectorSearch(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">var req VectorSearchRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        <span class="cov8" title="1">if len(req.Vector) == 0 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("vector is required")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.VectorSearch(c.Request().Context(), projectID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}

// HybridSearch performs combined lexical and vector search.
// POST /api/v2/graph/search
func (h *Handler) HybridSearch(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID, err := getProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project_id")
        }</span>

        <span class="cov8" title="1">var req HybridSearchRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        // At least query or vector must be provided
        <span class="cov8" title="1">if req.Query == "" &amp;&amp; len(req.Vector) == 0 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("either query or vector is required")
        }</span>

        <span class="cov8" title="1">result, err := h.svc.HybridSearch(c.Request().Context(), projectID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package graph

import (
        "context"
        "crypto/sha256"
        "database/sql"
        "encoding/json"
        "log/slog"
        "sort"
        "strings"
        "time"

        "github.com/google/uuid"
        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/internal/database"
        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
        "github.com/emergent/emergent-core/pkg/pgutils"
)

// Repository handles database operations for graph objects and relationships.
type Repository struct {
        db  bun.IDB
        log *slog.Logger
}

// NewRepository creates a new graph repository.
func NewRepository(db bun.IDB, log *slog.Logger) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                db:  db,
                log: log.With(logger.Scope("graph.repo")),
        }
}</span>

// ListParams contains parameters for listing graph objects.
type ListParams struct {
        ProjectID      uuid.UUID
        BranchID       *uuid.UUID
        Types          []string
        Labels         []string
        Status         *string
        Key            *string
        IncludeDeleted bool
        Limit          int
        Cursor         *string
}

// List returns graph objects matching the given parameters.
// Returns only HEAD versions (latest version per canonical_id).
func (r *Repository) List(ctx context.Context, params ListParams) ([]*GraphObject, error) <span class="cov8" title="1">{
        if params.Limit &lt;= 0 </span><span class="cov0" title="0">{
                params.Limit = 50
        }</span>
        <span class="cov8" title="1">if params.Limit &gt; 200 </span><span class="cov0" title="0">{
                params.Limit = 200
        }</span>

        // Build subquery to get HEAD versions
        <span class="cov8" title="1">subq := r.db.NewSelect().
                Model((*GraphObject)(nil)).
                Column("id", "project_id", "branch_id", "canonical_id", "supersedes_id", "version",
                        "type", "key", "status", "properties", "labels", "change_summary",
                        "created_at", "updated_at", "deleted_at", "actor_type", "actor_id", "schema_version",
                        "extraction_job_id", "extraction_confidence", "needs_review", "reviewed_by", "reviewed_at").
                Where("project_id = ?", params.ProjectID).
                Where("supersedes_id IS NULL") // HEAD versions have no successor

        if params.BranchID != nil </span><span class="cov0" title="0">{
                subq = subq.Where("branch_id = ?", *params.BranchID)
        }</span> else<span class="cov8" title="1"> {
                subq = subq.Where("branch_id IS NULL")
        }</span>

        <span class="cov8" title="1">if len(params.Types) &gt; 0 </span><span class="cov8" title="1">{
                subq = subq.Where("type IN (?)", bun.In(params.Types))
        }</span>

        <span class="cov8" title="1">if len(params.Labels) &gt; 0 </span><span class="cov0" title="0">{
                subq = subq.Where("labels &amp;&amp; ?::text[]", bun.In(params.Labels))
        }</span>

        <span class="cov8" title="1">if params.Status != nil </span><span class="cov0" title="0">{
                subq = subq.Where("status = ?", *params.Status)
        }</span>

        <span class="cov8" title="1">if params.Key != nil </span><span class="cov0" title="0">{
                subq = subq.Where("key = ?", *params.Key)
        }</span>

        <span class="cov8" title="1">if !params.IncludeDeleted </span><span class="cov8" title="1">{
                subq = subq.Where("deleted_at IS NULL")
        }</span>

        // Pagination via cursor (created_at, id)
        <span class="cov8" title="1">if params.Cursor != nil </span><span class="cov8" title="1">{
                // Decode cursor: base64(json({"created_at": "...", "id": "..."}))
                cursorData, err := decodeCursor(*params.Cursor)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, apperror.ErrBadRequest.WithMessage("invalid cursor")
                }</span>
                <span class="cov8" title="1">subq = subq.Where("(created_at, id) &lt; (?, ?)", cursorData.CreatedAt, cursorData.ID)</span>
        }

        <span class="cov8" title="1">subq = subq.Order("created_at DESC", "id DESC").Limit(params.Limit + 1)

        var objects []*GraphObject
        err := subq.Scan(ctx, &amp;objects)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to list graph objects", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return objects, nil</span>
}

// GetByID returns a graph object by its physical ID.
func (r *Repository) GetByID(ctx context.Context, projectID, id uuid.UUID) (*GraphObject, error) <span class="cov8" title="1">{
        var obj GraphObject
        err := r.db.NewSelect().
                Model(&amp;obj).
                Where("id = ?", id).
                Where("project_id = ?", projectID).
                Scan(ctx)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, apperror.ErrNotFound
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to get graph object", logger.Error(err), slog.String("id", id.String()))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return &amp;obj, nil</span>
}

// GetHeadByCanonicalID returns the HEAD version of a graph object by canonical ID.
func (r *Repository) GetHeadByCanonicalID(ctx context.Context, projectID, canonicalID uuid.UUID, branchID *uuid.UUID) (*GraphObject, error) <span class="cov8" title="1">{
        var obj GraphObject
        q := r.db.NewSelect().
                Model(&amp;obj).
                Where("canonical_id = ?", canonicalID).
                Where("project_id = ?", projectID).
                Where("supersedes_id IS NULL") // HEAD version

        if branchID != nil </span><span class="cov0" title="0">{
                q = q.Where("branch_id = ?", *branchID)
        }</span> else<span class="cov8" title="1"> {
                q = q.Where("branch_id IS NULL")
        }</span>

        <span class="cov8" title="1">err := q.Scan(ctx)
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, apperror.ErrNotFound
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to get graph object by canonical ID", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return &amp;obj, nil</span>
}

// Create inserts a new graph object (version 1).
func (r *Repository) Create(ctx context.Context, obj *GraphObject) error <span class="cov8" title="1">{
        // Set defaults
        if obj.ID == uuid.Nil </span><span class="cov8" title="1">{
                obj.ID = uuid.New()
        }</span>
        <span class="cov8" title="1">if obj.CanonicalID == uuid.Nil </span><span class="cov8" title="1">{
                obj.CanonicalID = obj.ID // First version: canonical_id == id
        }</span>
        <span class="cov8" title="1">obj.Version = 1
        obj.ContentHash = computeContentHash(obj.Properties)
        now := time.Now()
        obj.CreatedAt = now
        obj.UpdatedAt = now

        if obj.Properties == nil </span><span class="cov8" title="1">{
                obj.Properties = make(map[string]any)
        }</span>
        <span class="cov8" title="1">if obj.Labels == nil </span><span class="cov8" title="1">{
                obj.Labels = []string{}
        }</span>

        <span class="cov8" title="1">_, err := r.db.NewInsert().
                Model(obj).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to create graph object", logger.Error(err))
                return apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CreateVersion creates a new version of an existing graph object.
// The previous HEAD's supersedes_id is set to the new version's ID.
func (r *Repository) CreateVersion(ctx context.Context, tx bun.Tx, prevHead *GraphObject, newVersion *GraphObject) error <span class="cov8" title="1">{
        // New version setup
        newVersion.ID = uuid.New()
        newVersion.CanonicalID = prevHead.CanonicalID
        newVersion.SupersedesID = nil // New version is HEAD
        newVersion.Version = prevHead.Version + 1
        newVersion.ProjectID = prevHead.ProjectID
        newVersion.BranchID = prevHead.BranchID
        newVersion.ContentHash = computeContentHash(newVersion.Properties)
        now := time.Now()
        newVersion.CreatedAt = now
        newVersion.UpdatedAt = now

        // Insert new version
        _, err := tx.NewInsert().
                Model(newVersion).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrDatabase.WithInternal(err)
        }</span>

        // Update previous HEAD to point to new version
        <span class="cov8" title="1">_, err = tx.NewUpdate().
                Model((*GraphObject)(nil)).
                Set("supersedes_id = ?", newVersion.ID).
                Set("updated_at = ?", now).
                Where("id = ?", prevHead.ID).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SoftDelete marks a graph object as deleted by creating a tombstone version.
func (r *Repository) SoftDelete(ctx context.Context, tx bun.Tx, obj *GraphObject, actorID *uuid.UUID) error <span class="cov8" title="1">{
        now := time.Now()
        tombstone := &amp;GraphObject{
                Type:       obj.Type,
                Key:        obj.Key,
                Status:     obj.Status,
                Properties: obj.Properties,
                Labels:     obj.Labels,
                DeletedAt:  &amp;now,
                ActorID:    actorID,
        }
        actorType := "user"
        tombstone.ActorType = &amp;actorType

        return r.CreateVersion(ctx, tx, obj, tombstone)
}</span>

// Restore removes the deleted_at flag by creating a new non-deleted version.
func (r *Repository) Restore(ctx context.Context, tx bun.Tx, obj *GraphObject, actorID *uuid.UUID) error <span class="cov8" title="1">{
        restored := &amp;GraphObject{
                Type:       obj.Type,
                Key:        obj.Key,
                Status:     obj.Status,
                Properties: obj.Properties,
                Labels:     obj.Labels,
                DeletedAt:  nil,
                ActorID:    actorID,
        }
        actorType := "user"
        restored.ActorType = &amp;actorType

        return r.CreateVersion(ctx, tx, obj, restored)
}</span>

// GetHistory returns all versions of a graph object by canonical ID.
func (r *Repository) GetHistory(ctx context.Context, projectID, canonicalID uuid.UUID) ([]*GraphObject, error) <span class="cov8" title="1">{
        var versions []*GraphObject
        err := r.db.NewSelect().
                Model(&amp;versions).
                Where("canonical_id = ?", canonicalID).
                Where("project_id = ?", projectID).
                Order("version DESC").
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to get object history", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return versions, nil</span>
}

// GetEdges returns incoming and outgoing relationships for an object.
func (r *Repository) GetEdges(ctx context.Context, projectID, objectID uuid.UUID) ([]*GraphRelationship, []*GraphRelationship, error) <span class="cov8" title="1">{
        var incoming []*GraphRelationship
        var outgoing []*GraphRelationship

        // Get incoming edges (object is destination)
        err := r.db.NewSelect().
                Model(&amp;incoming).
                Where("dst_id = ?", objectID).
                Where("project_id = ?", projectID).
                Where("supersedes_id IS NULL").
                Where("deleted_at IS NULL").
                Scan(ctx)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        // Get outgoing edges (object is source)
        <span class="cov8" title="1">err = r.db.NewSelect().
                Model(&amp;outgoing).
                Where("src_id = ?", objectID).
                Where("project_id = ?", projectID).
                Where("supersedes_id IS NULL").
                Where("deleted_at IS NULL").
                Scan(ctx)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return incoming, outgoing, nil</span>
}

// AcquireObjectLock acquires an advisory lock for a graph object.
// The lock is released when the transaction commits or rolls back.
func (r *Repository) AcquireObjectLock(ctx context.Context, tx bun.Tx, canonicalID uuid.UUID) error <span class="cov8" title="1">{
        lockKey := "obj|" + canonicalID.String()
        _, err := tx.ExecContext(ctx, "SELECT pg_advisory_xact_lock(hashtext(?)::bigint)", lockKey)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// BeginTx starts a new database transaction.
// Returns a SafeTx that's safe to call Rollback after Commit (important for savepoints).
func (r *Repository) BeginTx(ctx context.Context) (*database.SafeTx, error) <span class="cov8" title="1">{
        return database.BeginSafeTx(ctx, r.db)
}</span>

// Cursor represents pagination state.
type Cursor struct {
        CreatedAt time.Time `json:"created_at"`
        ID        uuid.UUID `json:"id"`
}

func decodeCursor(encoded string) (*Cursor, error) <span class="cov8" title="1">{
        // For now, simple JSON - could use base64 encoding
        var c Cursor
        if err := json.Unmarshal([]byte(encoded), &amp;c); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;c, nil</span>
}

func encodeCursor(createdAt time.Time, id uuid.UUID) string <span class="cov8" title="1">{
        c := Cursor{CreatedAt: createdAt, ID: id}
        data, _ := json.Marshal(c)
        return string(data)
}</span>

// computeContentHash creates a SHA-256 hash of the properties for deduplication.
func computeContentHash(properties map[string]any) []byte <span class="cov8" title="1">{
        if properties == nil </span><span class="cov8" title="1">{
                properties = make(map[string]any)
        }</span>

        // Sort keys for deterministic ordering
        <span class="cov8" title="1">keys := make([]string, 0, len(properties))
        for k := range properties </span><span class="cov8" title="1">{
                keys = append(keys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        sorted := make(map[string]any)
        for _, k := range keys </span><span class="cov8" title="1">{
                sorted[k] = properties[k]
        }</span>

        <span class="cov8" title="1">data, _ := json.Marshal(sorted)
        hash := sha256.Sum256(data)
        return hash[:]</span>
}

// =============================================================================
// Relationship Operations
// =============================================================================

// RelationshipListParams contains parameters for listing relationships.
type RelationshipListParams struct {
        ProjectID      uuid.UUID
        BranchID       *uuid.UUID
        Type           *string
        SrcID          *uuid.UUID
        DstID          *uuid.UUID
        IncludeDeleted bool
        Limit          int
        Cursor         *string
        Order          string // "asc" or "desc"
}

// ListRelationships returns relationships matching the given parameters.
// Returns only HEAD versions (supersedes_id IS NULL).
func (r *Repository) ListRelationships(ctx context.Context, params RelationshipListParams) ([]*GraphRelationship, error) <span class="cov8" title="1">{
        if params.Limit &lt;= 0 </span><span class="cov0" title="0">{
                params.Limit = 20
        }</span>
        <span class="cov8" title="1">if params.Limit &gt; 200 </span><span class="cov0" title="0">{
                params.Limit = 200
        }</span>
        <span class="cov8" title="1">if params.Order == "" </span><span class="cov8" title="1">{
                params.Order = "asc"
        }</span>

        <span class="cov8" title="1">q := r.db.NewSelect().
                Model((*GraphRelationship)(nil)).
                Where("project_id = ?", params.ProjectID).
                Where("supersedes_id IS NULL") // HEAD versions only

        if params.BranchID != nil </span><span class="cov0" title="0">{
                q = q.Where("branch_id = ?", *params.BranchID)
        }</span> else<span class="cov8" title="1"> {
                q = q.Where("branch_id IS NULL")
        }</span>

        <span class="cov8" title="1">if params.Type != nil </span><span class="cov8" title="1">{
                q = q.Where("type = ?", *params.Type)
        }</span>

        <span class="cov8" title="1">if params.SrcID != nil </span><span class="cov8" title="1">{
                q = q.Where("src_id = ?", *params.SrcID)
        }</span>

        <span class="cov8" title="1">if params.DstID != nil </span><span class="cov0" title="0">{
                q = q.Where("dst_id = ?", *params.DstID)
        }</span>

        <span class="cov8" title="1">if !params.IncludeDeleted </span><span class="cov8" title="1">{
                q = q.Where("deleted_at IS NULL")
        }</span>

        // Pagination via cursor (created_at)
        <span class="cov8" title="1">if params.Cursor != nil </span><span class="cov0" title="0">{
                cursorData, err := decodeCursor(*params.Cursor)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.ErrBadRequest.WithMessage("invalid cursor")
                }</span>
                <span class="cov0" title="0">if params.Order == "desc" </span><span class="cov0" title="0">{
                        q = q.Where("(created_at, id) &lt; (?, ?)", cursorData.CreatedAt, cursorData.ID)
                }</span> else<span class="cov0" title="0"> {
                        q = q.Where("(created_at, id) &gt; (?, ?)", cursorData.CreatedAt, cursorData.ID)
                }</span>
        }

        <span class="cov8" title="1">if params.Order == "desc" </span><span class="cov0" title="0">{
                q = q.Order("created_at DESC", "id DESC")
        }</span> else<span class="cov8" title="1"> {
                q = q.Order("created_at ASC", "id ASC")
        }</span>

        <span class="cov8" title="1">q = q.Limit(params.Limit + 1)

        var rels []*GraphRelationship
        err := q.Scan(ctx, &amp;rels)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to list relationships", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return rels, nil</span>
}

// GetRelationshipByID returns a relationship by its physical ID.
func (r *Repository) GetRelationshipByID(ctx context.Context, projectID, id uuid.UUID) (*GraphRelationship, error) <span class="cov8" title="1">{
        var rel GraphRelationship
        err := r.db.NewSelect().
                Model(&amp;rel).
                Where("id = ?", id).
                Where("project_id = ?", projectID).
                Scan(ctx)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, apperror.ErrNotFound
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to get relationship", logger.Error(err), slog.String("id", id.String()))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return &amp;rel, nil</span>
}

// GetRelationshipHead returns the HEAD version of a relationship by type, src, dst.
func (r *Repository) GetRelationshipHead(ctx context.Context, projectID uuid.UUID, branchID *uuid.UUID, relType string, srcID, dstID uuid.UUID) (*GraphRelationship, error) <span class="cov8" title="1">{
        var rel GraphRelationship
        q := r.db.NewSelect().
                Model(&amp;rel).
                Where("project_id = ?", projectID).
                Where("type = ?", relType).
                Where("src_id = ?", srcID).
                Where("dst_id = ?", dstID).
                Where("supersedes_id IS NULL")

        if branchID != nil </span><span class="cov0" title="0">{
                q = q.Where("branch_id = ?", *branchID)
        }</span> else<span class="cov8" title="1"> {
                q = q.Where("branch_id IS NULL")
        }</span>

        <span class="cov8" title="1">err := q.Scan(ctx)
        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil // Not found is not an error for this method
                }</span>
                <span class="cov0" title="0">return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return &amp;rel, nil</span>
}

// CreateRelationship inserts a new relationship (version 1).
func (r *Repository) CreateRelationship(ctx context.Context, tx bun.Tx, rel *GraphRelationship) error <span class="cov8" title="1">{
        // Set defaults
        if rel.ID == uuid.Nil </span><span class="cov8" title="1">{
                rel.ID = uuid.New()
        }</span>
        <span class="cov8" title="1">if rel.CanonicalID == uuid.Nil </span><span class="cov8" title="1">{
                rel.CanonicalID = rel.ID // First version: canonical_id == id
        }</span>
        <span class="cov8" title="1">rel.Version = 1
        rel.ContentHash = computeContentHash(rel.Properties)
        rel.CreatedAt = time.Now()

        if rel.Properties == nil </span><span class="cov8" title="1">{
                rel.Properties = make(map[string]any)
        }</span>

        <span class="cov8" title="1">_, err := tx.NewInsert().Model(rel).Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to create relationship", logger.Error(err))
                return apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CreateRelationshipVersion creates a new version of an existing relationship.
func (r *Repository) CreateRelationshipVersion(ctx context.Context, tx bun.Tx, prevHead *GraphRelationship, newVersion *GraphRelationship) error <span class="cov8" title="1">{
        // New version setup
        newVersion.ID = uuid.New()
        newVersion.CanonicalID = prevHead.CanonicalID
        newVersion.SupersedesID = nil // New version is HEAD
        newVersion.Version = prevHead.Version + 1
        newVersion.ProjectID = prevHead.ProjectID
        newVersion.BranchID = prevHead.BranchID
        newVersion.Type = prevHead.Type
        newVersion.SrcID = prevHead.SrcID
        newVersion.DstID = prevHead.DstID
        newVersion.ContentHash = computeContentHash(newVersion.Properties)
        newVersion.CreatedAt = time.Now()

        // Insert new version
        _, err := tx.NewInsert().
                Model(newVersion).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrDatabase.WithInternal(err)
        }</span>

        // Update previous HEAD to point to new version
        <span class="cov8" title="1">_, err = tx.NewUpdate().
                Model((*GraphRelationship)(nil)).
                Set("supersedes_id = ?", newVersion.ID).
                Where("id = ?", prevHead.ID).
                Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SoftDeleteRelationship marks a relationship as deleted by creating a tombstone version.
func (r *Repository) SoftDeleteRelationship(ctx context.Context, tx bun.Tx, rel *GraphRelationship) error <span class="cov8" title="1">{
        now := time.Now()
        tombstone := &amp;GraphRelationship{
                Properties: rel.Properties,
                Weight:     rel.Weight,
                DeletedAt:  &amp;now,
        }

        return r.CreateRelationshipVersion(ctx, tx, rel, tombstone)
}</span>

// RestoreRelationship removes the deleted_at flag by creating a new non-deleted version.
func (r *Repository) RestoreRelationship(ctx context.Context, tx bun.Tx, rel *GraphRelationship) error <span class="cov8" title="1">{
        restored := &amp;GraphRelationship{
                Properties: rel.Properties,
                Weight:     rel.Weight,
                DeletedAt:  nil,
        }

        return r.CreateRelationshipVersion(ctx, tx, rel, restored)
}</span>

// GetRelationshipHistory returns all versions of a relationship by canonical ID.
func (r *Repository) GetRelationshipHistory(ctx context.Context, projectID, canonicalID uuid.UUID) ([]*GraphRelationship, error) <span class="cov8" title="1">{
        var versions []*GraphRelationship
        err := r.db.NewSelect().
                Model(&amp;versions).
                Where("canonical_id = ?", canonicalID).
                Where("project_id = ?", projectID).
                Order("version DESC").
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to get relationship history", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return versions, nil</span>
}

// GetRelationshipHeadByCanonicalID returns the HEAD version by canonical ID.
func (r *Repository) GetRelationshipHeadByCanonicalID(ctx context.Context, projectID, canonicalID uuid.UUID) (*GraphRelationship, error) <span class="cov8" title="1">{
        var rel GraphRelationship
        err := r.db.NewSelect().
                Model(&amp;rel).
                Where("canonical_id = ?", canonicalID).
                Where("project_id = ?", projectID).
                Where("supersedes_id IS NULL").
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, apperror.ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return &amp;rel, nil</span>
}

// AcquireRelationshipLock acquires an advisory lock for a relationship.
func (r *Repository) AcquireRelationshipLock(ctx context.Context, tx bun.Tx, projectID uuid.UUID, relType string, srcID, dstID uuid.UUID) error <span class="cov8" title="1">{
        lockKey := "rel|" + projectID.String() + "|" + relType + "|" + srcID.String() + "|" + dstID.String()
        _, err := tx.ExecContext(ctx, "SELECT pg_advisory_xact_lock(hashtext(?)::bigint)", lockKey)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateEndpoints checks that src and dst objects exist and are not deleted.
func (r *Repository) ValidateEndpoints(ctx context.Context, tx bun.Tx, projectID, srcID, dstID uuid.UUID) (*GraphObject, *GraphObject, error) <span class="cov8" title="1">{
        var objects []*GraphObject

        // Use the transaction for consistent reads
        err := tx.NewSelect().
                Model(&amp;objects).
                Where("id IN (?)", bun.In([]uuid.UUID{srcID, dstID})).
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">var srcObj, dstObj *GraphObject
        for _, obj := range objects </span><span class="cov8" title="1">{
                if obj.ID == srcID </span><span class="cov8" title="1">{
                        srcObj = obj
                }</span>
                <span class="cov8" title="1">if obj.ID == dstID </span><span class="cov8" title="1">{
                        dstObj = obj
                }</span>
        }

        <span class="cov8" title="1">if srcObj == nil </span><span class="cov0" title="0">{
                return nil, nil, apperror.ErrNotFound.WithMessage("src_object_not_found")
        }</span>
        <span class="cov8" title="1">if dstObj == nil </span><span class="cov8" title="1">{
                return nil, nil, apperror.ErrNotFound.WithMessage("dst_object_not_found")
        }</span>

        <span class="cov8" title="1">if srcObj.DeletedAt != nil </span><span class="cov0" title="0">{
                return nil, nil, apperror.ErrBadRequest.WithMessage("src_object_deleted")
        }</span>
        <span class="cov8" title="1">if dstObj.DeletedAt != nil </span><span class="cov0" title="0">{
                return nil, nil, apperror.ErrBadRequest.WithMessage("dst_object_deleted")
        }</span>

        // Verify same project
        <span class="cov8" title="1">if srcObj.ProjectID != projectID || dstObj.ProjectID != projectID </span><span class="cov0" title="0">{
                return nil, nil, apperror.ErrBadRequest.WithMessage("relationship_project_mismatch")
        }</span>

        <span class="cov8" title="1">return srcObj, dstObj, nil</span>
}

// =============================================================================
// Search Operations
// =============================================================================

// searchFilters contains common filter parameters for search queries.
type searchFilters struct {
        ProjectID      uuid.UUID
        BranchID       *uuid.UUID
        Types          []string
        Labels         []string
        Status         *string
        IncludeDeleted bool
}

// buildSearchFilters builds WHERE conditions and args for common search filters.
// Returns conditions and args to be appended to existing slices.
func buildSearchFilters(filters searchFilters) (conditions []string, args []any) <span class="cov8" title="1">{
        if filters.BranchID != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "branch_id = ?")
                args = append(args, *filters.BranchID)
        }</span> else<span class="cov8" title="1"> {
                conditions = append(conditions, "branch_id IS NULL")
        }</span>

        <span class="cov8" title="1">if len(filters.Types) &gt; 0 </span><span class="cov8" title="1">{
                conditions = append(conditions, "type = ANY(?::text[])")
                args = append(args, formatTextArray(filters.Types))
        }</span>

        <span class="cov8" title="1">if len(filters.Labels) &gt; 0 </span><span class="cov8" title="1">{
                conditions = append(conditions, "labels &amp;&amp; ?::text[]")
                args = append(args, formatTextArray(filters.Labels))
        }</span>

        <span class="cov8" title="1">if filters.Status != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "status = ?")
                args = append(args, *filters.Status)
        }</span>

        <span class="cov8" title="1">if !filters.IncludeDeleted </span><span class="cov8" title="1">{
                conditions = append(conditions, "deleted_at IS NULL")
        }</span>

        <span class="cov8" title="1">return conditions, args</span>
}

// buildWhereClause joins conditions into a WHERE clause.
func buildWhereClause(conditions []string) string <span class="cov8" title="1">{
        if len(conditions) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return "WHERE " + strings.Join(conditions, " AND ")</span>
}

// graphObjectColumns is the list of columns to select for GraphObject.
const graphObjectColumns = `id, project_id, branch_id, canonical_id, supersedes_id, version,
        type, key, status, properties, labels, change_summary, content_hash,
        created_at, updated_at, deleted_at, fts, embedding_updated_at,
        extraction_job_id, extraction_confidence, needs_review, reviewed_by, reviewed_at,
        actor_type, actor_id, schema_version`

// scanGraphObject scans a row into a GraphObject.
func scanGraphObject(rows *sql.Rows, obj *GraphObject) error <span class="cov0" title="0">{
        return rows.Scan(
                &amp;obj.ID, &amp;obj.ProjectID, &amp;obj.BranchID, &amp;obj.CanonicalID, &amp;obj.SupersedesID, &amp;obj.Version,
                &amp;obj.Type, &amp;obj.Key, &amp;obj.Status, &amp;obj.Properties, &amp;obj.Labels, &amp;obj.ChangeSummary, &amp;obj.ContentHash,
                &amp;obj.CreatedAt, &amp;obj.UpdatedAt, &amp;obj.DeletedAt, &amp;obj.FTS, &amp;obj.EmbeddingUpdatedAt,
                &amp;obj.ExtractionJobID, &amp;obj.ExtractionConfidence, &amp;obj.NeedsReview, &amp;obj.ReviewedBy, &amp;obj.ReviewedAt,
                &amp;obj.ActorType, &amp;obj.ActorID, &amp;obj.SchemaVersion,
        )
}</span>

// FTSSearchParams contains parameters for full-text search.
type FTSSearchParams struct {
        ProjectID      uuid.UUID
        Query          string
        BranchID       *uuid.UUID
        Types          []string
        Labels         []string
        Status         *string
        IncludeDeleted bool
        Limit          int
}

// FTSSearchResult represents a single FTS search result with score.
type FTSSearchResult struct {
        Object *GraphObject
        Rank   float32
}

// FTSSearch performs full-text search using PostgreSQL's websearch_to_tsquery.
// Returns objects sorted by relevance (ts_rank).
func (r *Repository) FTSSearch(ctx context.Context, params FTSSearchParams) ([]*FTSSearchResult, error) <span class="cov8" title="1">{
        if params.Limit &lt;= 0 </span><span class="cov0" title="0">{
                params.Limit = 20
        }</span>
        <span class="cov8" title="1">if params.Limit &gt; 200 </span><span class="cov0" title="0">{
                params.Limit = 200
        }</span>

        // Build WHERE conditions
        <span class="cov8" title="1">conditions := []string{
                "project_id = ?",
                "supersedes_id IS NULL", // HEAD versions only
                "fts @@ websearch_to_tsquery('simple', ?)",
        }
        args := []any{params.ProjectID, params.Query}

        // Add common filters
        filterConds, filterArgs := buildSearchFilters(searchFilters{
                ProjectID:      params.ProjectID,
                BranchID:       params.BranchID,
                Types:          params.Types,
                Labels:         params.Labels,
                Status:         params.Status,
                IncludeDeleted: params.IncludeDeleted,
        })
        conditions = append(conditions, filterConds...)
        args = append(args, filterArgs...)

        whereClause := buildWhereClause(conditions)

        // Build the query with ts_rank
        query := `
                SELECT ` + graphObjectColumns + `,
                        ts_rank(fts, websearch_to_tsquery('simple', ?)) AS rank
                FROM kb.graph_objects
                ` + whereClause + `
                ORDER BY rank DESC
                LIMIT ?
        `

        // Prepend query param for ts_rank, append limit
        finalArgs := append([]any{params.Query}, args...)
        finalArgs = append(finalArgs, params.Limit)

        rows, err := r.db.QueryContext(ctx, query, finalArgs...)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("FTS search failed", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var results []*FTSSearchResult
        for rows.Next() </span><span class="cov0" title="0">{
                obj := &amp;GraphObject{}
                var rank float32
                err := rows.Scan(
                        &amp;obj.ID, &amp;obj.ProjectID, &amp;obj.BranchID, &amp;obj.CanonicalID, &amp;obj.SupersedesID, &amp;obj.Version,
                        &amp;obj.Type, &amp;obj.Key, &amp;obj.Status, &amp;obj.Properties, &amp;obj.Labels, &amp;obj.ChangeSummary, &amp;obj.ContentHash,
                        &amp;obj.CreatedAt, &amp;obj.UpdatedAt, &amp;obj.DeletedAt, &amp;obj.FTS, &amp;obj.EmbeddingUpdatedAt,
                        &amp;obj.ExtractionJobID, &amp;obj.ExtractionConfidence, &amp;obj.NeedsReview, &amp;obj.ReviewedBy, &amp;obj.ReviewedAt,
                        &amp;obj.ActorType, &amp;obj.ActorID, &amp;obj.SchemaVersion,
                        &amp;rank,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.log.Error("FTS search row scan failed", logger.Error(err))
                        return nil, apperror.ErrDatabase.WithInternal(err)
                }</span>
                <span class="cov0" title="0">results = append(results, &amp;FTSSearchResult{Object: obj, Rank: rank})</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// VectorSearchParams contains parameters for vector similarity search.
type VectorSearchParams struct {
        ProjectID      uuid.UUID
        Vector         []float32
        BranchID       *uuid.UUID
        Types          []string
        Labels         []string
        Status         *string
        IncludeDeleted bool
        MaxDistance    *float32
        Limit          int
}

// VectorSearchResult represents a single vector search result with distance.
type VectorSearchResult struct {
        Object   *GraphObject
        Distance float32
}

// VectorSearch performs vector similarity search using pgvector's cosine distance.
// Returns objects sorted by similarity (ascending distance).
func (r *Repository) VectorSearch(ctx context.Context, params VectorSearchParams) ([]*VectorSearchResult, error) <span class="cov8" title="1">{
        if params.Limit &lt;= 0 </span><span class="cov0" title="0">{
                params.Limit = 20
        }</span>
        <span class="cov8" title="1">if params.Limit &gt; 200 </span><span class="cov0" title="0">{
                params.Limit = 200
        }</span>

        // Format vector as PostgreSQL array string: '[0.1,0.2,...]'
        <span class="cov8" title="1">vectorStr := pgutils.FormatVector(params.Vector)

        // Build WHERE conditions
        conditions := []string{
                "project_id = ?",
                "supersedes_id IS NULL",    // HEAD versions only
                "embedding_v2 IS NOT NULL", // Must have embedding
        }
        args := []any{params.ProjectID}

        // Add common filters
        filterConds, filterArgs := buildSearchFilters(searchFilters{
                ProjectID:      params.ProjectID,
                BranchID:       params.BranchID,
                Types:          params.Types,
                Labels:         params.Labels,
                Status:         params.Status,
                IncludeDeleted: params.IncludeDeleted,
        })
        conditions = append(conditions, filterConds...)
        args = append(args, filterArgs...)

        // Max distance filter (specific to vector search)
        if params.MaxDistance != nil </span><span class="cov8" title="1">{
                conditions = append(conditions, "(embedding_v2 &lt;=&gt; ?::vector) &lt;= ?")
                args = append(args, vectorStr, *params.MaxDistance)
        }</span>

        <span class="cov8" title="1">whereClause := buildWhereClause(conditions)

        // Build the query with cosine distance
        query := `
                SELECT ` + graphObjectColumns + `,
                        (embedding_v2 &lt;=&gt; ?::vector) AS distance
                FROM kb.graph_objects
                ` + whereClause + `
                ORDER BY distance ASC
                LIMIT ?
        `

        // Prepend vector param for distance calculation, append limit
        finalArgs := append([]any{vectorStr}, args...)
        finalArgs = append(finalArgs, params.Limit)

        rows, err := r.db.QueryContext(ctx, query, finalArgs...)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("Vector search failed", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var results []*VectorSearchResult
        for rows.Next() </span><span class="cov0" title="0">{
                obj := &amp;GraphObject{}
                var distance float32
                err := rows.Scan(
                        &amp;obj.ID, &amp;obj.ProjectID, &amp;obj.BranchID, &amp;obj.CanonicalID, &amp;obj.SupersedesID, &amp;obj.Version,
                        &amp;obj.Type, &amp;obj.Key, &amp;obj.Status, &amp;obj.Properties, &amp;obj.Labels, &amp;obj.ChangeSummary, &amp;obj.ContentHash,
                        &amp;obj.CreatedAt, &amp;obj.UpdatedAt, &amp;obj.DeletedAt, &amp;obj.FTS, &amp;obj.EmbeddingUpdatedAt,
                        &amp;obj.ExtractionJobID, &amp;obj.ExtractionConfidence, &amp;obj.NeedsReview, &amp;obj.ReviewedBy, &amp;obj.ReviewedAt,
                        &amp;obj.ActorType, &amp;obj.ActorID, &amp;obj.SchemaVersion,
                        &amp;distance,
                )
                if err != nil </span><span class="cov0" title="0">{
                        r.log.Error("Vector search row scan failed", logger.Error(err))
                        return nil, apperror.ErrDatabase.WithInternal(err)
                }</span>
                <span class="cov0" title="0">results = append(results, &amp;VectorSearchResult{Object: obj, Distance: distance})</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return results, nil</span>
}

// formatTextArray converts a string slice to PostgreSQL text array literal format.
// Example: ["foo", "bar baz"] -&gt; {foo,"bar baz"}
func formatTextArray(arr []string) string <span class="cov8" title="1">{
        if len(arr) == 0 </span><span class="cov8" title="1">{
                return "{}"
        }</span>

        <span class="cov8" title="1">var buf strings.Builder
        buf.WriteByte('{')

        for i, s := range arr </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        buf.WriteByte(',')
                }</span>
                // Quote strings that contain special characters
                <span class="cov8" title="1">needsQuote := strings.ContainsAny(s, `{},"\`)
                if needsQuote </span><span class="cov8" title="1">{
                        buf.WriteByte('"')
                        // Escape backslashes and quotes
                        for _, c := range s </span><span class="cov8" title="1">{
                                if c == '\\' || c == '"' </span><span class="cov8" title="1">{
                                        buf.WriteByte('\\')
                                }</span>
                                <span class="cov8" title="1">buf.WriteRune(c)</span>
                        }
                        <span class="cov8" title="1">buf.WriteByte('"')</span>
                } else<span class="cov8" title="1"> {
                        buf.WriteString(s)
                }</span>
        }

        <span class="cov8" title="1">buf.WriteByte('}')
        return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package graph

import (
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/auth"
)

// RegisterRoutes registers all graph routes.
func RegisterRoutes(e *echo.Echo, h *Handler, authMiddleware *auth.Middleware) <span class="cov8" title="1">{
        // All graph routes require authentication and project context
        g := e.Group("/api/v2/graph")
        g.Use(authMiddleware.RequireAuth())

        // Object routes
        objects := g.Group("/objects")
        objects.GET("/search", h.ListObjects)
        objects.GET("/fts", h.FTSSearch)
        objects.POST("/vector-search", h.VectorSearch)
        objects.GET("/:id", h.GetObject)
        objects.POST("", h.CreateObject)
        objects.PATCH("/:id", h.PatchObject)
        objects.DELETE("/:id", h.DeleteObject)
        objects.POST("/:id/restore", h.RestoreObject)
        objects.GET("/:id/history", h.GetObjectHistory)
        objects.GET("/:id/edges", h.GetObjectEdges)

        // Hybrid search route (top level under /graph)
        g.POST("/search", h.HybridSearch)

        // Relationship routes
        relationships := g.Group("/relationships")
        relationships.GET("/search", h.ListRelationships)
        relationships.GET("/:id", h.GetRelationship)
        relationships.POST("", h.CreateRelationship)
        relationships.PATCH("/:id", h.PatchRelationship)
        relationships.DELETE("/:id", h.DeleteRelationship)
        relationships.POST("/:id/restore", h.RestoreRelationship)
        relationships.GET("/:id/history", h.GetRelationshipHistory)
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package graph

import (
        "context"
        "encoding/json"
        "log/slog"
        "sort"

        "github.com/google/uuid"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
        "github.com/emergent/emergent-core/pkg/mathutil"
)

// Service handles business logic for graph operations.
type Service struct {
        repo *Repository
        log  *slog.Logger
}

// NewService creates a new graph service.
func NewService(repo *Repository, log *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: repo,
                log:  log.With(logger.Scope("graph.svc")),
        }
}</span>

// List returns graph objects matching the given parameters.
func (s *Service) List(ctx context.Context, params ListParams) (*SearchGraphObjectsResponse, error) <span class="cov8" title="1">{
        objects, err := s.repo.List(ctx, params)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Check if there are more results
        <span class="cov8" title="1">hasMore := len(objects) &gt; params.Limit
        if hasMore </span><span class="cov8" title="1">{
                objects = objects[:params.Limit]
        }</span>

        // Build response
        <span class="cov8" title="1">data := make([]*GraphObjectResponse, len(objects))
        for i, obj := range objects </span><span class="cov8" title="1">{
                data[i] = obj.ToResponse()
        }</span>

        <span class="cov8" title="1">var nextCursor *string
        if hasMore &amp;&amp; len(objects) &gt; 0 </span><span class="cov8" title="1">{
                last := objects[len(objects)-1]
                cursor := encodeCursor(last.CreatedAt, last.ID)
                nextCursor = &amp;cursor
        }</span>

        <span class="cov8" title="1">return &amp;SearchGraphObjectsResponse{
                Data:       data,
                NextCursor: nextCursor,
                HasMore:    hasMore,
        }, nil</span>
}

// GetByID returns a graph object by its physical ID.
func (s *Service) GetByID(ctx context.Context, projectID, id uuid.UUID) (*GraphObjectResponse, error) <span class="cov8" title="1">{
        obj, err := s.repo.GetByID(ctx, projectID, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return obj.ToResponse(), nil</span>
}

// Create creates a new graph object.
func (s *Service) Create(ctx context.Context, projectID uuid.UUID, req *CreateGraphObjectRequest, actorID *uuid.UUID) (*GraphObjectResponse, error) <span class="cov8" title="1">{
        actorType := "user"

        obj := &amp;GraphObject{
                ProjectID:  projectID,
                BranchID:   req.BranchID,
                Type:       req.Type,
                Key:        req.Key,
                Status:     req.Status,
                Properties: req.Properties,
                Labels:     req.Labels,
                ActorType:  &amp;actorType,
                ActorID:    actorID,
        }

        if err := s.repo.Create(ctx, obj); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return obj.ToResponse(), nil</span>
}

// Patch updates a graph object by creating a new version.
func (s *Service) Patch(ctx context.Context, projectID, id uuid.UUID, req *PatchGraphObjectRequest, actorID *uuid.UUID) (*GraphObjectResponse, error) <span class="cov8" title="1">{
        // Get current HEAD
        current, err := s.repo.GetByID(ctx, projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if already deleted
        <span class="cov8" title="1">if current.DeletedAt != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrBadRequest.WithMessage("cannot patch deleted object")
        }</span>

        // Start transaction
        <span class="cov8" title="1">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Acquire advisory lock
        if err := s.repo.AcquireObjectLock(ctx, tx.Tx, current.CanonicalID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Re-fetch to ensure we have the latest after acquiring lock
        <span class="cov8" title="1">current, err = s.repo.GetHeadByCanonicalID(ctx, projectID, current.CanonicalID, current.BranchID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Merge properties
        <span class="cov8" title="1">newProps := make(map[string]any)
        for k, v := range current.Properties </span><span class="cov8" title="1">{
                newProps[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range req.Properties </span><span class="cov8" title="1">{
                if v == nil </span><span class="cov0" title="0">{
                        delete(newProps, k) // null removes property
                }</span> else<span class="cov8" title="1"> {
                        newProps[k] = v
                }</span>
        }

        // Handle labels
        <span class="cov8" title="1">var newLabels []string
        if req.ReplaceLabels </span><span class="cov0" title="0">{
                newLabels = req.Labels
        }</span> else<span class="cov8" title="1"> if len(req.Labels) &gt; 0 </span><span class="cov0" title="0">{
                // Merge labels (add new, remove duplicates)
                labelSet := make(map[string]bool)
                for _, l := range current.Labels </span><span class="cov0" title="0">{
                        labelSet[l] = true
                }</span>
                <span class="cov0" title="0">for _, l := range req.Labels </span><span class="cov0" title="0">{
                        labelSet[l] = true
                }</span>
                <span class="cov0" title="0">newLabels = make([]string, 0, len(labelSet))
                for l := range labelSet </span><span class="cov0" title="0">{
                        newLabels = append(newLabels, l)
                }</span>
        } else<span class="cov8" title="1"> {
                newLabels = current.Labels
        }</span>

        // Handle status
        <span class="cov8" title="1">newStatus := current.Status
        if req.Status != nil </span><span class="cov8" title="1">{
                newStatus = req.Status
        }</span>

        <span class="cov8" title="1">actorType := "user"
        newVersion := &amp;GraphObject{
                Type:       current.Type,
                Key:        current.Key,
                Status:     newStatus,
                Properties: newProps,
                Labels:     newLabels,
                ActorType:  &amp;actorType,
                ActorID:    actorID,
        }

        // Compute change summary
        newVersion.ChangeSummary = computeChangeSummary(current.Properties, newProps)

        if err := s.repo.CreateVersion(ctx, tx.Tx, current, newVersion); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return newVersion.ToResponse(), nil</span>
}

// Delete soft-deletes a graph object by creating a tombstone version.
func (s *Service) Delete(ctx context.Context, projectID, id uuid.UUID, actorID *uuid.UUID) error <span class="cov8" title="1">{
        current, err := s.repo.GetByID(ctx, projectID, id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if current.DeletedAt != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("object already deleted")
        }</span>

        <span class="cov8" title="1">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        if err := s.repo.AcquireObjectLock(ctx, tx.Tx, current.CanonicalID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Re-fetch HEAD after lock
        <span class="cov8" title="1">current, err = s.repo.GetHeadByCanonicalID(ctx, projectID, current.CanonicalID, current.BranchID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := s.repo.SoftDelete(ctx, tx.Tx, current, actorID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return tx.Commit()</span>
}

// Restore restores a soft-deleted graph object.
func (s *Service) Restore(ctx context.Context, projectID, id uuid.UUID, actorID *uuid.UUID) (*GraphObjectResponse, error) <span class="cov8" title="1">{
        current, err := s.repo.GetByID(ctx, projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if current.DeletedAt == nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrBadRequest.WithMessage("object is not deleted")
        }</span>

        <span class="cov8" title="1">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        if err := s.repo.AcquireObjectLock(ctx, tx.Tx, current.CanonicalID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Re-fetch HEAD after lock
        <span class="cov8" title="1">current, err = s.repo.GetHeadByCanonicalID(ctx, projectID, current.CanonicalID, current.BranchID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := s.repo.Restore(ctx, tx.Tx, current, actorID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        // Re-fetch the new HEAD to return
        <span class="cov8" title="1">restored, err := s.repo.GetHeadByCanonicalID(ctx, projectID, current.CanonicalID, current.BranchID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return restored.ToResponse(), nil</span>
}

// GetHistory returns version history for a graph object.
func (s *Service) GetHistory(ctx context.Context, projectID, id uuid.UUID) (*ObjectHistoryResponse, error) <span class="cov8" title="1">{
        // First get the object to find its canonical ID
        obj, err := s.repo.GetByID(ctx, projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">versions, err := s.repo.GetHistory(ctx, projectID, obj.CanonicalID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">data := make([]*GraphObjectResponse, len(versions))
        for i, v := range versions </span><span class="cov8" title="1">{
                data[i] = v.ToResponse()
        }</span>

        <span class="cov8" title="1">return &amp;ObjectHistoryResponse{Versions: data}, nil</span>
}

// GetEdges returns incoming and outgoing relationships for an object.
func (s *Service) GetEdges(ctx context.Context, projectID, objectID uuid.UUID) (*GetObjectEdgesResponse, error) <span class="cov8" title="1">{
        incoming, outgoing, err := s.repo.GetEdges(ctx, projectID, objectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">incomingResp := make([]*GraphRelationshipResponse, len(incoming))
        for i, r := range incoming </span><span class="cov8" title="1">{
                incomingResp[i] = r.ToResponse()
        }</span>

        <span class="cov8" title="1">outgoingResp := make([]*GraphRelationshipResponse, len(outgoing))
        for i, r := range outgoing </span><span class="cov8" title="1">{
                outgoingResp[i] = r.ToResponse()
        }</span>

        <span class="cov8" title="1">return &amp;GetObjectEdgesResponse{
                Incoming: incomingResp,
                Outgoing: outgoingResp,
        }, nil</span>
}

// computeChangeSummary creates an RFC 6901 JSON Pointer diff.
func computeChangeSummary(oldProps, newProps map[string]any) map[string]any <span class="cov8" title="1">{
        added := make(map[string]any)
        removed := make([]string, 0)
        updated := make(map[string]any)
        paths := make([]string, 0)

        // Find added and updated
        for k, newVal := range newProps </span><span class="cov8" title="1">{
                path := "/" + k
                if oldVal, exists := oldProps[k]; !exists </span><span class="cov8" title="1">{
                        added[path] = newVal
                        paths = append(paths, path)
                }</span> else<span class="cov8" title="1"> if !jsonEqual(oldVal, newVal) </span><span class="cov8" title="1">{
                        updated[path] = map[string]any{
                                "from": oldVal,
                                "to":   newVal,
                        }
                        paths = append(paths, path)
                }</span>
        }

        // Find removed
        <span class="cov8" title="1">for k := range oldProps </span><span class="cov8" title="1">{
                if _, exists := newProps[k]; !exists </span><span class="cov8" title="1">{
                        path := "/" + k
                        removed = append(removed, path)
                        paths = append(paths, path)
                }</span>
        }

        <span class="cov8" title="1">if len(added) == 0 &amp;&amp; len(removed) == 0 &amp;&amp; len(updated) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return map[string]any{
                "added":   added,
                "removed": removed,
                "updated": updated,
                "paths":   paths,
                "meta": map[string]any{
                        "added":   len(added),
                        "removed": len(removed),
                        "updated": len(updated),
                },
        }</span>
}

// jsonEqual compares two values for JSON equality.
func jsonEqual(a, b any) bool <span class="cov8" title="1">{
        aJSON, _ := json.Marshal(a)
        bJSON, _ := json.Marshal(b)
        return string(aJSON) == string(bJSON)
}</span>

// =============================================================================
// Relationship Operations
// =============================================================================

// SearchRelationshipsResponse is the paginated response for relationship searches.
type SearchRelationshipsResponse struct {
        Data       []*GraphRelationshipResponse `json:"data"`
        NextCursor *string                      `json:"nextCursor,omitempty"`
        HasMore    bool                         `json:"hasMore"`
}

// ListRelationships returns relationships matching the given parameters.
func (s *Service) ListRelationships(ctx context.Context, params RelationshipListParams) (*SearchRelationshipsResponse, error) <span class="cov8" title="1">{
        rels, err := s.repo.ListRelationships(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hasMore := len(rels) &gt; params.Limit
        if hasMore </span><span class="cov0" title="0">{
                rels = rels[:params.Limit]
        }</span>

        <span class="cov8" title="1">data := make([]*GraphRelationshipResponse, len(rels))
        for i, rel := range rels </span><span class="cov8" title="1">{
                data[i] = rel.ToResponse()
        }</span>

        <span class="cov8" title="1">var nextCursor *string
        if hasMore &amp;&amp; len(rels) &gt; 0 </span><span class="cov0" title="0">{
                last := rels[len(rels)-1]
                cursor := encodeCursor(last.CreatedAt, last.ID)
                nextCursor = &amp;cursor
        }</span>

        <span class="cov8" title="1">return &amp;SearchRelationshipsResponse{
                Data:       data,
                NextCursor: nextCursor,
                HasMore:    hasMore,
        }, nil</span>
}

// GetRelationship returns a relationship by its ID.
func (s *Service) GetRelationship(ctx context.Context, projectID, id uuid.UUID) (*GraphRelationshipResponse, error) <span class="cov8" title="1">{
        rel, err := s.repo.GetRelationshipByID(ctx, projectID, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Only return non-deleted relationships
        <span class="cov8" title="1">if rel.DeletedAt != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrNotFound
        }</span>

        <span class="cov8" title="1">return rel.ToResponse(), nil</span>
}

// CreateRelationship creates a new relationship or returns existing if properties match.
func (s *Service) CreateRelationship(ctx context.Context, projectID uuid.UUID, req *CreateGraphRelationshipRequest) (*GraphRelationshipResponse, error) <span class="cov8" title="1">{
        // Validate: no self-loops
        if req.SrcID == req.DstID </span><span class="cov8" title="1">{
                return nil, apperror.ErrBadRequest.WithMessage("self_loop_not_allowed")
        }</span>

        // Start transaction
        <span class="cov8" title="1">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Validate endpoints exist and are not deleted
        srcObj, dstObj, err := s.repo.ValidateEndpoints(ctx, tx.Tx, projectID, req.SrcID, req.DstID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Check branch consistency
        <span class="cov8" title="1">effectiveBranchID := req.BranchID
        if effectiveBranchID != nil </span><span class="cov0" title="0">{
                // Both endpoints must be on the same branch
                if (srcObj.BranchID == nil || *srcObj.BranchID != *effectiveBranchID) ||
                        (dstObj.BranchID == nil || *dstObj.BranchID != *effectiveBranchID) </span><span class="cov0" title="0">{
                        return nil, apperror.ErrBadRequest.WithMessage("relationship_branch_mismatch")
                }</span>
        } else<span class="cov8" title="1"> {
                // If no branch specified, endpoints must be on main branch (null) or same branch
                if !branchIDsEqual(srcObj.BranchID, dstObj.BranchID) </span><span class="cov0" title="0">{
                        return nil, apperror.ErrBadRequest.WithMessage("relationship_branch_mismatch")
                }</span>
                <span class="cov8" title="1">effectiveBranchID = srcObj.BranchID</span>
        }

        // Acquire lock for this relationship identity
        <span class="cov8" title="1">if err := s.repo.AcquireRelationshipLock(ctx, tx.Tx, projectID, req.Type, req.SrcID, req.DstID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if relationship already exists
        <span class="cov8" title="1">existing, err := s.repo.GetRelationshipHead(ctx, projectID, effectiveBranchID, req.Type, req.SrcID, req.DstID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if existing == nil </span><span class="cov8" title="1">{
                // Create new relationship
                rel := &amp;GraphRelationship{
                        ProjectID:  projectID,
                        BranchID:   effectiveBranchID,
                        Type:       req.Type,
                        SrcID:      req.SrcID,
                        DstID:      req.DstID,
                        Properties: req.Properties,
                        Weight:     req.Weight,
                }

                // Compute change summary
                rel.ChangeSummary = computeChangeSummary(nil, req.Properties)

                if err := s.repo.CreateRelationship(ctx, tx.Tx, rel); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.ErrDatabase.WithInternal(err)
                }</span>

                <span class="cov8" title="1">return rel.ToResponse(), nil</span>
        }

        // Relationship exists - check if properties differ
        <span class="cov8" title="1">if existing.DeletedAt != nil </span><span class="cov0" title="0">{
                // Was deleted, create new version to "restore" with new properties
                newVersion := &amp;GraphRelationship{
                        Properties: req.Properties,
                        Weight:     req.Weight,
                        DeletedAt:  nil,
                }
                newVersion.ChangeSummary = computeChangeSummary(existing.Properties, req.Properties)

                if err := s.repo.CreateRelationshipVersion(ctx, tx.Tx, existing, newVersion); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return nil, apperror.ErrDatabase.WithInternal(err)
                }</span>

                // Return the new version
                <span class="cov0" title="0">newHead, _ := s.repo.GetRelationshipHead(ctx, projectID, effectiveBranchID, req.Type, req.SrcID, req.DstID)
                return newHead.ToResponse(), nil</span>
        }

        // Check if properties changed
        <span class="cov8" title="1">diff := computeChangeSummary(existing.Properties, req.Properties)
        if diff == nil </span><span class="cov8" title="1">{
                // No change - return existing
                return existing.ToResponse(), nil
        }</span>

        // Properties differ - create new version
        <span class="cov0" title="0">newVersion := &amp;GraphRelationship{
                Properties:    req.Properties,
                Weight:        req.Weight,
                ChangeSummary: diff,
        }

        if err := s.repo.CreateRelationshipVersion(ctx, tx.Tx, existing, newVersion); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        // Return the new version
        <span class="cov0" title="0">newHead, _ := s.repo.GetRelationshipHead(ctx, projectID, effectiveBranchID, req.Type, req.SrcID, req.DstID)
        return newHead.ToResponse(), nil</span>
}

// PatchRelationship updates a relationship by creating a new version.
func (s *Service) PatchRelationship(ctx context.Context, projectID, id uuid.UUID, req *PatchGraphRelationshipRequest) (*GraphRelationshipResponse, error) <span class="cov8" title="1">{
        current, err := s.repo.GetRelationshipByID(ctx, projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if current.DeletedAt != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrBadRequest.WithMessage("cannot patch deleted relationship")
        }</span>

        <span class="cov8" title="1">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Acquire lock
        if err := s.repo.AcquireRelationshipLock(ctx, tx.Tx, current.ProjectID, current.Type, current.SrcID, current.DstID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Re-fetch HEAD after lock
        <span class="cov8" title="1">head, err := s.repo.GetRelationshipHeadByCanonicalID(ctx, projectID, current.CanonicalID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Ensure we're patching the HEAD version
        <span class="cov8" title="1">if head.ID != current.ID </span><span class="cov0" title="0">{
                return nil, apperror.ErrBadRequest.WithMessage("cannot_patch_non_head_version")
        }</span>

        // Merge properties
        <span class="cov8" title="1">newProps := make(map[string]any)
        for k, v := range current.Properties </span><span class="cov8" title="1">{
                newProps[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range req.Properties </span><span class="cov8" title="1">{
                if v == nil </span><span class="cov0" title="0">{
                        delete(newProps, k)
                }</span> else<span class="cov8" title="1"> {
                        newProps[k] = v
                }</span>
        }

        // Check for actual changes
        <span class="cov8" title="1">diff := computeChangeSummary(current.Properties, newProps)
        if diff == nil &amp;&amp; (req.Weight == nil || (current.Weight != nil &amp;&amp; *req.Weight == *current.Weight)) </span><span class="cov0" title="0">{
                return nil, apperror.ErrBadRequest.WithMessage("no_effective_change")
        }</span>

        <span class="cov8" title="1">newVersion := &amp;GraphRelationship{
                Properties:    newProps,
                Weight:        req.Weight,
                ChangeSummary: diff,
        }
        if newVersion.Weight == nil </span><span class="cov8" title="1">{
                newVersion.Weight = current.Weight
        }</span>

        <span class="cov8" title="1">if err := s.repo.CreateRelationshipVersion(ctx, tx.Tx, current, newVersion); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        // Return the new version
        <span class="cov8" title="1">newHead, _ := s.repo.GetRelationshipHeadByCanonicalID(ctx, projectID, current.CanonicalID)
        return newHead.ToResponse(), nil</span>
}

// DeleteRelationship soft-deletes a relationship.
func (s *Service) DeleteRelationship(ctx context.Context, projectID, id uuid.UUID) (*GraphRelationshipResponse, error) <span class="cov8" title="1">{
        current, err := s.repo.GetRelationshipByID(ctx, projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Acquire lock
        if err := s.repo.AcquireRelationshipLock(ctx, tx.Tx, current.ProjectID, current.Type, current.SrcID, current.DstID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get HEAD version
        <span class="cov8" title="1">head, err := s.repo.GetRelationshipHeadByCanonicalID(ctx, projectID, current.CanonicalID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if head.DeletedAt != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrBadRequest.WithMessage("already_deleted")
        }</span>

        <span class="cov8" title="1">if err := s.repo.SoftDeleteRelationship(ctx, tx.Tx, head); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        // Return the tombstone
        <span class="cov8" title="1">tombstone, _ := s.repo.GetRelationshipHeadByCanonicalID(ctx, projectID, current.CanonicalID)
        return tombstone.ToResponse(), nil</span>
}

// RestoreRelationship restores a soft-deleted relationship.
func (s *Service) RestoreRelationship(ctx context.Context, projectID, id uuid.UUID) (*GraphRelationshipResponse, error) <span class="cov8" title="1">{
        current, err := s.repo.GetRelationshipByID(ctx, projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Acquire lock
        if err := s.repo.AcquireRelationshipLock(ctx, tx.Tx, current.ProjectID, current.Type, current.SrcID, current.DstID); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Get HEAD version
        <span class="cov8" title="1">head, err := s.repo.GetRelationshipHeadByCanonicalID(ctx, projectID, current.CanonicalID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if head.DeletedAt == nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrBadRequest.WithMessage("relationship_not_deleted")
        }</span>

        <span class="cov8" title="1">if err := s.repo.RestoreRelationship(ctx, tx.Tx, head); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        // Return the restored version
        <span class="cov8" title="1">restored, _ := s.repo.GetRelationshipHeadByCanonicalID(ctx, projectID, current.CanonicalID)
        return restored.ToResponse(), nil</span>
}

// GetRelationshipHistory returns version history for a relationship.
func (s *Service) GetRelationshipHistory(ctx context.Context, projectID, id uuid.UUID) ([]*GraphRelationshipResponse, error) <span class="cov8" title="1">{
        // First get the relationship to find its canonical ID
        rel, err := s.repo.GetRelationshipByID(ctx, projectID, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">versions, err := s.repo.GetRelationshipHistory(ctx, projectID, rel.CanonicalID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">data := make([]*GraphRelationshipResponse, len(versions))
        for i, v := range versions </span><span class="cov8" title="1">{
                data[i] = v.ToResponse()
        }</span>

        <span class="cov8" title="1">return data, nil</span>
}

// branchIDsEqual compares two optional branch IDs.
func branchIDsEqual(a, b *uuid.UUID) bool <span class="cov8" title="1">{
        if a == nil &amp;&amp; b == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if a == nil || b == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return *a == *b</span>
}

// =============================================================================
// Search Operations
// =============================================================================

// FTSSearch performs full-text search on graph objects.
func (s *Service) FTSSearch(ctx context.Context, projectID uuid.UUID, req *FTSSearchRequest) (*SearchResponse, error) <span class="cov8" title="1">{
        limit := req.Limit
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 20
        }</span>
        <span class="cov8" title="1">if limit &gt; 200 </span><span class="cov0" title="0">{
                limit = 200
        }</span>

        <span class="cov8" title="1">params := FTSSearchParams{
                ProjectID:      projectID,
                Query:          req.Query,
                BranchID:       req.BranchID,
                Types:          req.Types,
                Labels:         req.Labels,
                Status:         req.Status,
                IncludeDeleted: req.IncludeDeleted,
                Limit:          limit + 1, // Fetch one extra to determine hasMore
        }

        results, err := s.repo.FTSSearch(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hasMore := len(results) &gt; limit
        if hasMore </span><span class="cov0" title="0">{
                results = results[:limit]
        }</span>

        <span class="cov8" title="1">data := make([]*SearchResultItem, len(results))
        for i, r := range results </span><span class="cov0" title="0">{
                data[i] = &amp;SearchResultItem{
                        Object:       r.Object.ToResponse(),
                        Score:        r.Rank,
                        LexicalScore: &amp;r.Rank,
                }
        }</span>

        <span class="cov8" title="1">return &amp;SearchResponse{
                Data:    data,
                Total:   len(data),
                HasMore: hasMore,
        }, nil</span>
}

// VectorSearch performs vector similarity search on graph objects.
func (s *Service) VectorSearch(ctx context.Context, projectID uuid.UUID, req *VectorSearchRequest) (*SearchResponse, error) <span class="cov8" title="1">{
        limit := req.Limit
        if limit &lt;= 0 </span><span class="cov8" title="1">{
                limit = 20
        }</span>
        <span class="cov8" title="1">if limit &gt; 200 </span><span class="cov0" title="0">{
                limit = 200
        }</span>

        <span class="cov8" title="1">params := VectorSearchParams{
                ProjectID:      projectID,
                Vector:         req.Vector,
                BranchID:       req.BranchID,
                Types:          req.Types,
                Labels:         req.Labels,
                Status:         req.Status,
                IncludeDeleted: req.IncludeDeleted,
                MaxDistance:    req.MaxDistance,
                Limit:          limit + 1, // Fetch one extra to determine hasMore
        }

        results, err := s.repo.VectorSearch(ctx, params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hasMore := len(results) &gt; limit
        if hasMore </span><span class="cov0" title="0">{
                results = results[:limit]
        }</span>

        <span class="cov8" title="1">data := make([]*SearchResultItem, len(results))
        for i, r := range results </span><span class="cov0" title="0">{
                // Convert distance to similarity score (1 - distance for cosine)
                // Cosine distance is in [0, 2], so similarity is in [-1, 1]
                similarity := 1.0 - r.Distance
                data[i] = &amp;SearchResultItem{
                        Object:      r.Object.ToResponse(),
                        Score:       similarity,
                        VectorScore: &amp;similarity,
                        VectorDist:  &amp;r.Distance,
                }
        }</span>

        <span class="cov8" title="1">return &amp;SearchResponse{
                Data:    data,
                Total:   len(data),
                HasMore: hasMore,
        }, nil</span>
}

// HybridSearch performs combined lexical and vector search with score fusion.
func (s *Service) HybridSearch(ctx context.Context, projectID uuid.UUID, req *HybridSearchRequest) (*SearchResponse, error) <span class="cov8" title="1">{
        limit := req.Limit
        if limit &lt;= 0 </span><span class="cov8" title="1">{
                limit = 20
        }</span>
        <span class="cov8" title="1">if limit &gt; 200 </span><span class="cov0" title="0">{
                limit = 200
        }</span>

        // Default weights
        <span class="cov8" title="1">lexicalWeight := float32(0.5)
        vectorWeight := float32(0.5)
        if req.LexicalWeight != nil </span><span class="cov8" title="1">{
                lexicalWeight = *req.LexicalWeight
        }</span>
        <span class="cov8" title="1">if req.VectorWeight != nil </span><span class="cov8" title="1">{
                vectorWeight = *req.VectorWeight
        }</span>

        // Normalize weights
        <span class="cov8" title="1">totalWeight := lexicalWeight + vectorWeight
        if totalWeight &gt; 0 </span><span class="cov8" title="1">{
                lexicalWeight /= totalWeight
                vectorWeight /= totalWeight
        }</span>

        // Determine search strategies based on available inputs
        <span class="cov8" title="1">hasQuery := req.Query != ""
        hasVector := len(req.Vector) &gt; 0

        if !hasQuery &amp;&amp; !hasVector </span><span class="cov0" title="0">{
                return &amp;SearchResponse{
                        Data:    []*SearchResultItem{},
                        Total:   0,
                        HasMore: false,
                }, nil
        }</span>

        // Maps to collect results from both searches
        <span class="cov8" title="1">lexicalResults := make(map[uuid.UUID]*FTSSearchResult)
        vectorResults := make(map[uuid.UUID]*VectorSearchResult)

        // Run searches based on available inputs
        fetchLimit := limit * 3 // Fetch more for fusion

        if hasQuery </span><span class="cov8" title="1">{
                ftsParams := FTSSearchParams{
                        ProjectID:      projectID,
                        Query:          req.Query,
                        BranchID:       req.BranchID,
                        Types:          req.Types,
                        Labels:         req.Labels,
                        Status:         req.Status,
                        IncludeDeleted: req.IncludeDeleted,
                        Limit:          fetchLimit,
                }
                ftsResults, err := s.repo.FTSSearch(ctx, ftsParams)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, r := range ftsResults </span><span class="cov0" title="0">{
                        lexicalResults[r.Object.ID] = r
                }</span>
        }

        <span class="cov8" title="1">if hasVector </span><span class="cov8" title="1">{
                vecParams := VectorSearchParams{
                        ProjectID:      projectID,
                        Vector:         req.Vector,
                        BranchID:       req.BranchID,
                        Types:          req.Types,
                        Labels:         req.Labels,
                        Status:         req.Status,
                        IncludeDeleted: req.IncludeDeleted,
                        Limit:          fetchLimit,
                }
                vecResults, err := s.repo.VectorSearch(ctx, vecParams)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, r := range vecResults </span><span class="cov0" title="0">{
                        vectorResults[r.Object.ID] = r
                }</span>
        }

        // Collect all unique IDs
        <span class="cov8" title="1">allIDs := make(map[uuid.UUID]bool)
        for id := range lexicalResults </span><span class="cov0" title="0">{
                allIDs[id] = true
        }</span>
        <span class="cov8" title="1">for id := range vectorResults </span><span class="cov0" title="0">{
                allIDs[id] = true
        }</span>

        <span class="cov8" title="1">if len(allIDs) == 0 </span><span class="cov8" title="1">{
                return &amp;SearchResponse{
                        Data:    []*SearchResultItem{},
                        Total:   0,
                        HasMore: false,
                }, nil
        }</span>

        // Calculate score statistics for normalization
        <span class="cov0" title="0">var lexicalScores, vectorScores []float32
        for id := range allIDs </span><span class="cov0" title="0">{
                if lr, ok := lexicalResults[id]; ok </span><span class="cov0" title="0">{
                        lexicalScores = append(lexicalScores, lr.Rank)
                }</span>
                <span class="cov0" title="0">if vr, ok := vectorResults[id]; ok </span><span class="cov0" title="0">{
                        // Convert distance to similarity for scoring
                        similarity := 1.0 - vr.Distance
                        vectorScores = append(vectorScores, similarity)
                }</span>
        }

        <span class="cov0" title="0">lexicalMean, lexicalStd := mathutil.CalcMeanStd(lexicalScores)
        vectorMean, vectorStd := mathutil.CalcMeanStd(vectorScores)

        // Fuse scores
        type fusedResult struct {
                id           uuid.UUID
                object       *GraphObject
                fusedScore   float32
                lexicalScore *float32
                vectorScore  *float32
                vectorDist   *float32
        }

        var fusedResults []fusedResult
        for id := range allIDs </span><span class="cov0" title="0">{
                var normLexical, normVector float32
                var lexScore, vecScore *float32
                var vecDist *float32
                var obj *GraphObject

                if lr, ok := lexicalResults[id]; ok </span><span class="cov0" title="0">{
                        normalized := zScoreNormalize(lr.Rank, lexicalMean, lexicalStd)
                        normLexical = mathutil.Sigmoid(normalized)
                        score := lr.Rank
                        lexScore = &amp;score
                        obj = lr.Object
                }</span>

                <span class="cov0" title="0">if vr, ok := vectorResults[id]; ok </span><span class="cov0" title="0">{
                        similarity := float32(1.0) - vr.Distance
                        normalized := zScoreNormalize(similarity, vectorMean, vectorStd)
                        normVector = mathutil.Sigmoid(normalized)
                        vecScore = &amp;similarity
                        dist := vr.Distance
                        vecDist = &amp;dist
                        if obj == nil </span><span class="cov0" title="0">{
                                obj = vr.Object
                        }</span>
                }

                // Weighted combination
                <span class="cov0" title="0">fusedScore := lexicalWeight*normLexical + vectorWeight*normVector

                fusedResults = append(fusedResults, fusedResult{
                        id:           id,
                        object:       obj,
                        fusedScore:   fusedScore,
                        lexicalScore: lexScore,
                        vectorScore:  vecScore,
                        vectorDist:   vecDist,
                })</span>
        }

        // Sort by fused score descending
        <span class="cov0" title="0">sort.Slice(fusedResults, func(i, j int) bool </span><span class="cov0" title="0">{
                return fusedResults[i].fusedScore &gt; fusedResults[j].fusedScore
        }</span>)

        // Apply limit
        <span class="cov0" title="0">hasMore := len(fusedResults) &gt; limit
        if hasMore </span><span class="cov0" title="0">{
                fusedResults = fusedResults[:limit]
        }</span>

        // Build response
        <span class="cov0" title="0">data := make([]*SearchResultItem, len(fusedResults))
        for i, fr := range fusedResults </span><span class="cov0" title="0">{
                data[i] = &amp;SearchResultItem{
                        Object:       fr.object.ToResponse(),
                        Score:        fr.fusedScore,
                        LexicalScore: fr.lexicalScore,
                        VectorScore:  fr.vectorScore,
                        VectorDist:   fr.vectorDist,
                }
        }</span>

        <span class="cov0" title="0">return &amp;SearchResponse{
                Data:    data,
                Total:   len(data),
                HasMore: hasMore,
        }, nil</span>
}

// zScoreNormalize applies z-score normalization.
func zScoreNormalize(score, mean, std float32) float32 <span class="cov8" title="1">{
        return (score - mean) / std
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package health

import (
        "context"
        "net/http"
        "runtime"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/internal/version"
)

// Handler handles health check requests
type Handler struct {
        pool    *pgxpool.Pool
        cfg     *config.Config
        startAt time.Time
}

// NewHandler creates a new health handler
func NewHandler(pool *pgxpool.Pool, cfg *config.Config) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                pool:    pool,
                cfg:     cfg,
                startAt: time.Now(),
        }
}</span>

// HealthResponse represents the health check response
type HealthResponse struct {
        Status    string           `json:"status"`
        Timestamp string           `json:"timestamp"`
        Uptime    string           `json:"uptime"`
        Version   string           `json:"version"`
        Checks    map[string]Check `json:"checks"`
}

// Check represents an individual health check result
type Check struct {
        Status  string `json:"status"`
        Message string `json:"message,omitempty"`
}

// Health returns the overall service health
func (h *Handler) Health(c echo.Context) error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c.Request().Context(), 5*time.Second)
        defer cancel()

        // Check database connectivity
        dbStatus := "healthy"
        dbMessage := ""
        if err := h.pool.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                dbStatus = "unhealthy"
                dbMessage = err.Error()
        }</span>

        // Determine overall status
        <span class="cov8" title="1">overallStatus := "healthy"
        if dbStatus == "unhealthy" </span><span class="cov0" title="0">{
                overallStatus = "unhealthy"
        }</span>

        <span class="cov8" title="1">response := HealthResponse{
                Status:    overallStatus,
                Timestamp: time.Now().UTC().Format(time.RFC3339),
                Uptime:    time.Since(h.startAt).String(),
                Version:   version.Version,
                Checks: map[string]Check{
                        "database": {
                                Status:  dbStatus,
                                Message: dbMessage,
                        },
                },
        }

        statusCode := http.StatusOK
        if overallStatus == "unhealthy" </span><span class="cov0" title="0">{
                statusCode = http.StatusServiceUnavailable
        }</span>

        <span class="cov8" title="1">return c.JSON(statusCode, response)</span>
}

// Healthz returns a simple health check (for k8s liveness probe)
func (h *Handler) Healthz(c echo.Context) error <span class="cov8" title="1">{
        return c.String(http.StatusOK, "OK")
}</span>

// Ready returns readiness status (for k8s readiness probe)
func (h *Handler) Ready(c echo.Context) error <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(c.Request().Context(), 5*time.Second)
        defer cancel()

        // Check database connectivity
        if err := h.pool.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusServiceUnavailable, map[string]any{
                        "status":  "not_ready",
                        "message": "Database connection failed",
                })
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, map[string]any{
                "status": "ready",
        })</span>
}

// Debug returns debug information (only in development)
func (h *Handler) Debug(c echo.Context) error <span class="cov8" title="1">{
        if h.cfg.Environment == "production" </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusNotFound, "Not found")
        }</span>

        <span class="cov8" title="1">var mem runtime.MemStats
        runtime.ReadMemStats(&amp;mem)

        return c.JSON(http.StatusOK, map[string]any{
                "environment": h.cfg.Environment,
                "debug":       h.cfg.Debug,
                "go_version":  runtime.Version(),
                "goroutines":  runtime.NumGoroutine(),
                "memory": map[string]any{
                        "alloc_mb":       mem.Alloc / 1024 / 1024,
                        "total_alloc_mb": mem.TotalAlloc / 1024 / 1024,
                        "sys_mb":         mem.Sys / 1024 / 1024,
                        "num_gc":         mem.NumGC,
                },
                "database": map[string]any{
                        "host":        h.cfg.Database.Host,
                        "port":        h.cfg.Database.Port,
                        "database":    h.cfg.Database.Database,
                        "pool_total":  h.pool.Stat().TotalConns(),
                        "pool_idle":   h.pool.Stat().IdleConns(),
                        "pool_in_use": h.pool.Stat().AcquiredConns(),
                },
        })</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package health

import (
        "context"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/uptrace/bun"
)

// MetricsHandler handles job metrics requests
type MetricsHandler struct {
        db *bun.DB
}

// NewMetricsHandler creates a new metrics handler
func NewMetricsHandler(db *bun.DB) *MetricsHandler <span class="cov0" title="0">{
        return &amp;MetricsHandler{
                db: db,
        }
}</span>

// JobQueueMetrics represents metrics for a single job queue
type JobQueueMetrics struct {
        Queue       string `json:"queue"`
        Pending     int64  `json:"pending"`
        Processing  int64  `json:"processing"`
        Completed   int64  `json:"completed"`
        Failed      int64  `json:"failed"`
        Total       int64  `json:"total"`
        LastHour    int64  `json:"last_hour"`
        Last24Hours int64  `json:"last_24_hours"`
}

// AllJobMetrics contains metrics for all job queues
type AllJobMetrics struct {
        Queues    []JobQueueMetrics `json:"queues"`
        Timestamp string            `json:"timestamp"`
}

// JobMetrics returns metrics for all job queues
func (h *MetricsHandler) JobMetrics(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        // Define job queue tables
        queues := []struct {
                name  string
                table string
        }{
                {"document_parsing", "kb.document_parsing_jobs"},
                {"chunk_embedding", "kb.chunk_embedding_jobs"},
                {"graph_embedding", "kb.graph_embedding_jobs"},
                {"object_extraction", "kb.object_extraction_jobs"},
                {"data_source_sync", "kb.data_source_sync_jobs"},
                {"email", "kb.email_jobs"},
        }

        var allMetrics []JobQueueMetrics

        for _, q := range queues </span><span class="cov0" title="0">{
                metrics, err := h.getQueueMetrics(ctx, q.name, q.table)
                if err != nil </span><span class="cov0" title="0">{
                        // Log error but continue with other queues
                        continue</span>
                }
                <span class="cov0" title="0">allMetrics = append(allMetrics, *metrics)</span>
        }

        <span class="cov0" title="0">return c.JSON(http.StatusOK, AllJobMetrics{
                Queues:    allMetrics,
                Timestamp: c.Request().Header.Get("Date"),
        })</span>
}

// getQueueMetrics retrieves metrics for a specific job queue
func (h *MetricsHandler) getQueueMetrics(ctx context.Context, name, table string) (*JobQueueMetrics, error) <span class="cov0" title="0">{
        // Use raw SQL since we need to query multiple tables with different schemas
        query := `
                SELECT 
                        COUNT(*) FILTER (WHERE status = 'pending') as pending,
                        COUNT(*) FILTER (WHERE status IN ('processing', 'running')) as processing,
                        COUNT(*) FILTER (WHERE status = 'completed') as completed,
                        COUNT(*) FILTER (WHERE status = 'failed') as failed,
                        COUNT(*) as total,
                        COUNT(*) FILTER (WHERE created_at &gt; NOW() - INTERVAL '1 hour') as last_hour,
                        COUNT(*) FILTER (WHERE created_at &gt; NOW() - INTERVAL '24 hours') as last_24_hours
                FROM ` + table

        var metrics struct {
                Pending     int64 `bun:"pending"`
                Processing  int64 `bun:"processing"`
                Completed   int64 `bun:"completed"`
                Failed      int64 `bun:"failed"`
                Total       int64 `bun:"total"`
                LastHour    int64 `bun:"last_hour"`
                Last24Hours int64 `bun:"last_24_hours"`
        }

        err := h.db.NewRaw(query).Scan(ctx, &amp;metrics)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;JobQueueMetrics{
                Queue:       name,
                Pending:     metrics.Pending,
                Processing:  metrics.Processing,
                Completed:   metrics.Completed,
                Failed:      metrics.Failed,
                Total:       metrics.Total,
                LastHour:    metrics.LastHour,
                Last24Hours: metrics.Last24Hours,
        }, nil</span>
}

// SchedulerMetrics returns metrics for scheduled tasks
func (h *MetricsHandler) SchedulerMetrics(c echo.Context) error <span class="cov0" title="0">{
        // This would need to be wired up to the scheduler service
        // For now, return a placeholder
        return c.JSON(http.StatusOK, map[string]interface{}{
                "message": "Scheduler metrics endpoint - wire up to scheduler service for task info",
        })
}</span>
</pre>
		
		<pre class="file" id="file63" style="display: none">package health

import (
        "github.com/labstack/echo/v4"
)

// RegisterRoutes registers health check routes
func RegisterRoutes(e *echo.Echo, h *Handler, m *MetricsHandler) <span class="cov0" title="0">{
        // Basic health checks (no auth required)
        e.GET("/health", h.Health)
        e.GET("/healthz", h.Healthz)
        e.GET("/ready", h.Ready)

        // Debug endpoint (development only)
        e.GET("/debug", h.Debug)

        // Job metrics endpoint (for monitoring)
        e.GET("/api/metrics/jobs", m.JobMetrics)
        e.GET("/api/metrics/scheduler", m.SchedulerMetrics)
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package invites

import (
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

// Handler handles HTTP requests for invitations
type Handler struct {
        svc *Service
}

// NewHandler creates a new invites handler
func NewHandler(svc *Service) *Handler <span class="cov0" title="0">{
        return &amp;Handler{svc: svc}
}</span>

// ListPending returns pending invitations for the current user
// GET /invites/pending
func (h *Handler) ListPending(c echo.Context) error <span class="cov0" title="0">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">invites, err := h.svc.ListPendingForUser(c.Request().Context(), user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, invites)</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package invites

import (
        "github.com/labstack/echo/v4"
        "go.uber.org/fx"

        "github.com/emergent/emergent-core/pkg/auth"
)

// Module provides the invites domain
var Module = fx.Module("invites",
        fx.Provide(NewService),
        fx.Provide(NewHandler),
        fx.Invoke(RegisterRoutes),
)

// RegisterRoutes registers the invites routes
func RegisterRoutes(e *echo.Echo, h *Handler, authMiddleware *auth.Middleware) <span class="cov0" title="0">{
        g := e.Group("/api/invites", authMiddleware.RequireAuth())

        // GET /api/invites/pending - list pending invitations for current user
        g.GET("/pending", h.ListPending)
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">// Package invites handles invitation management
package invites

import (
        "context"
        "strings"
        "time"

        "github.com/uptrace/bun"
)

// PendingInvite represents a pending invitation for a user
type PendingInvite struct {
        ID               string     `json:"id"`
        ProjectID        *string    `json:"projectId,omitempty"`
        ProjectName      *string    `json:"projectName,omitempty"`
        OrganizationID   string     `json:"organizationId"`
        OrganizationName *string    `json:"organizationName,omitempty"`
        Role             string     `json:"role"`
        Token            string     `json:"token"`
        CreatedAt        time.Time  `json:"createdAt"`
        ExpiresAt        *time.Time `json:"expiresAt,omitempty"`
}

// Service handles invitation operations
type Service struct {
        db bun.IDB
}

// NewService creates a new invites service
func NewService(db bun.IDB) *Service <span class="cov0" title="0">{
        return &amp;Service{db: db}
}</span>

type inviteRow struct {
        ID             string     `bun:"id"`
        Email          string     `bun:"email"`
        OrganizationID string     `bun:"organization_id"`
        ProjectID      *string    `bun:"project_id"`
        ProjectName    *string    `bun:"project_name"`
        Role           string     `bun:"role"`
        Token          string     `bun:"token"`
        Status         string     `bun:"status"`
        ExpiresAt      *time.Time `bun:"expires_at"`
        CreatedAt      time.Time  `bun:"created_at"`
}

// ListPendingForUser returns pending invitations for a user
func (s *Service) ListPendingForUser(ctx context.Context, userID string) ([]PendingInvite, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return []PendingInvite{}, nil
        }</span>

        // Get user's emails
        <span class="cov0" title="0">var emails []string
        err := s.db.NewRaw(`
                SELECT email FROM core.user_emails WHERE user_id = ?
        `, userID).Scan(ctx, &amp;emails)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(emails) == 0 </span><span class="cov0" title="0">{
                return []PendingInvite{}, nil
        }</span>

        // Lowercase all emails for case-insensitive matching
        <span class="cov0" title="0">for i, email := range emails </span><span class="cov0" title="0">{
                emails[i] = strings.ToLower(email)
        }</span>

        // Find pending invitations for these emails
        <span class="cov0" title="0">var inviteRows []inviteRow
        err = s.db.NewRaw(`
                SELECT 
                        i.id, i.email, i.organization_id, i.project_id, 
                        p.name as project_name, i.role, i.token, i.status, 
                        i.expires_at, i.created_at
                FROM kb.invites i
                LEFT JOIN kb.projects p ON p.id = i.project_id
                WHERE LOWER(i.email) IN (?)
                  AND i.status = 'pending'
                  AND (i.expires_at IS NULL OR i.expires_at &gt; NOW())
                ORDER BY i.created_at DESC
        `, bun.In(emails)).Scan(ctx, &amp;inviteRows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(inviteRows) == 0 </span><span class="cov0" title="0">{
                return []PendingInvite{}, nil
        }</span>

        // Get organization names
        <span class="cov0" title="0">orgIDs := make([]string, 0)
        seen := make(map[string]bool)
        for _, inv := range inviteRows </span><span class="cov0" title="0">{
                if !seen[inv.OrganizationID] </span><span class="cov0" title="0">{
                        seen[inv.OrganizationID] = true
                        orgIDs = append(orgIDs, inv.OrganizationID)
                }</span>
        }

        <span class="cov0" title="0">type orgName struct {
                ID   string `bun:"id"`
                Name string `bun:"name"`
        }
        var orgs []orgName
        err = s.db.NewRaw(`
                SELECT id, name FROM kb.orgs WHERE id IN (?)
        `, bun.In(orgIDs)).Scan(ctx, &amp;orgs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">orgMap := make(map[string]string)
        for _, org := range orgs </span><span class="cov0" title="0">{
                orgMap[org.ID] = org.Name
        }</span>

        // Build response
        <span class="cov0" title="0">result := make([]PendingInvite, len(inviteRows))
        for i, inv := range inviteRows </span><span class="cov0" title="0">{
                invite := PendingInvite{
                        ID:             inv.ID,
                        OrganizationID: inv.OrganizationID,
                        Role:           inv.Role,
                        Token:          inv.Token,
                        CreatedAt:      inv.CreatedAt,
                }
                if inv.ProjectID != nil </span><span class="cov0" title="0">{
                        invite.ProjectID = inv.ProjectID
                }</span>
                <span class="cov0" title="0">if inv.ProjectName != nil </span><span class="cov0" title="0">{
                        invite.ProjectName = inv.ProjectName
                }</span>
                <span class="cov0" title="0">if name, ok := orgMap[inv.OrganizationID]; ok </span><span class="cov0" title="0">{
                        invite.OrganizationName = &amp;name
                }</span>
                <span class="cov0" title="0">if inv.ExpiresAt != nil </span><span class="cov0" title="0">{
                        invite.ExpiresAt = inv.ExpiresAt
                }</span>
                <span class="cov0" title="0">result[i] = invite</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package mcp

import (
        "encoding/json"
        "log/slog"
        "net/http"
        "slices"
        "sync"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Handler handles MCP HTTP requests
type Handler struct {
        svc *Service
        log *slog.Logger

        // Session management (token -&gt; session)
        sessions   map[string]*Session
        sessionsMu sync.RWMutex
}

// Session stores MCP session state
type Session struct {
        Initialized bool
        ProjectID   string
}

// NewHandler creates a new MCP handler
func NewHandler(svc *Service, log *slog.Logger) *Handler <span class="cov8" title="1">{
        return &amp;Handler{
                svc:      svc,
                log:      log.With(logger.Scope("mcp.handler")),
                sessions: make(map[string]*Session),
        }
}</span>

// HandleRPC handles POST /mcp/rpc - JSON-RPC 2.0 endpoint
func (h *Handler) HandleRPC(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        // Parse JSON-RPC request
        <span class="cov8" title="1">var req Request
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusOK, NewErrorResponse(
                        nil,
                        ErrCodeParseError,
                        "Failed to parse JSON-RPC request",
                        map[string]string{"error": err.Error()},
                ))
        }</span>

        // Validate JSON-RPC version
        <span class="cov8" title="1">if req.JSONRPC != "2.0" </span><span class="cov8" title="1">{
                return c.JSON(http.StatusOK, NewErrorResponse(
                        req.ID,
                        ErrCodeInvalidRequest,
                        "Invalid JSON-RPC version. Must be \"2.0\"",
                        nil,
                ))
        }</span>

        // Handle notification (no ID = no response)
        <span class="cov8" title="1">if req.IsNotification() </span><span class="cov0" title="0">{
                h.handleNotification(c, &amp;req)
                return c.NoContent(http.StatusAccepted)
        }</span>

        // Route to method handler
        <span class="cov8" title="1">response := h.routeMethod(c, &amp;req, user)
        return c.JSON(http.StatusOK, response)</span>
}

// handleNotification processes JSON-RPC notifications
func (h *Handler) handleNotification(c echo.Context, req *Request) <span class="cov0" title="0">{
        switch req.Method </span>{
        case "notifications/initialized":<span class="cov0" title="0">
                // Mark session as fully initialized
                token := extractToken(c)
                if token != "" </span><span class="cov0" title="0">{
                        h.sessionsMu.Lock()
                        if session, ok := h.sessions[token]; ok </span><span class="cov0" title="0">{
                                session.Initialized = true
                        }</span>
                        <span class="cov0" title="0">h.sessionsMu.Unlock()</span>
                }
        default:<span class="cov0" title="0">
                // Unknown notification - ignore per JSON-RPC 2.0 spec
                h.log.Debug("unknown notification", slog.String("method", req.Method))</span>
        }
}

// routeMethod routes JSON-RPC requests to the appropriate handler
func (h *Handler) routeMethod(c echo.Context, req *Request, user *auth.AuthUser) *Response <span class="cov8" title="1">{
        switch req.Method </span>{
        case "initialize":<span class="cov8" title="1">
                return h.handleInitialize(c, req, user)</span>
        case "tools/list":<span class="cov8" title="1">
                return h.handleToolsList(c, req, user)</span>
        case "tools/call":<span class="cov8" title="1">
                return h.handleToolsCall(c, req, user)</span>
        default:<span class="cov8" title="1">
                return NewErrorResponse(
                        req.ID,
                        ErrCodeMethodNotFound,
                        "Method not found: "+req.Method,
                        map[string]any{
                                "method":            req.Method,
                                "supported_methods": []string{"initialize", "tools/list", "tools/call"},
                        },
                )</span>
        }
}

// handleInitialize handles the initialize method
func (h *Handler) handleInitialize(c echo.Context, req *Request, user *auth.AuthUser) *Response <span class="cov8" title="1">{
        // Parse params
        var params InitializeParams
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                        return NewErrorResponse(req.ID, ErrCodeInvalidParams,
                                "Invalid initialize params", map[string]string{"error": err.Error()})
                }</span>
        }

        // Validate required fields
        <span class="cov8" title="1">if params.ProtocolVersion == "" || params.ClientInfo.Name == "" </span><span class="cov8" title="1">{
                return NewErrorResponse(req.ID, ErrCodeInvalidParams,
                        "Missing required parameters: protocolVersion, clientInfo",
                        map[string]any{
                                "required": []string{"protocolVersion", "clientInfo"},
                        },
                )
        }</span>

        // Validate protocol version
        <span class="cov8" title="1">if !slices.Contains(SupportedProtocolVersions, params.ProtocolVersion) </span><span class="cov0" title="0">{
                return NewErrorResponse(req.ID, ErrCodeInvalidParams,
                        "Unsupported protocol version: "+params.ProtocolVersion,
                        map[string]any{
                                "requested": params.ProtocolVersion,
                                "supported": SupportedProtocolVersions,
                        },
                )
        }</span>

        // Create/update session
        <span class="cov8" title="1">token := extractToken(c)
        projectID := params.ProjectID
        if projectID == "" </span><span class="cov8" title="1">{
                projectID = user.ProjectID // Fall back to header
        }</span>

        <span class="cov8" title="1">if token != "" </span><span class="cov8" title="1">{
                h.sessionsMu.Lock()
                h.sessions[token] = &amp;Session{
                        Initialized: true,
                        ProjectID:   projectID,
                }
                h.sessionsMu.Unlock()
        }</span>

        // Build response
        <span class="cov8" title="1">result := InitializeResult{
                ProtocolVersion: params.ProtocolVersion,
                Capabilities: ServerCapabilities{
                        Tools: ToolsCapability{ListChanged: false},
                },
                ServerInfo: ServerInfo,
        }

        if projectID != "" </span><span class="cov8" title="1">{
                result.ProjectContext = map[string]string{"projectId": projectID}
        }</span>

        <span class="cov8" title="1">h.log.Info("MCP session initialized",
                slog.String("client", params.ClientInfo.Name),
                slog.String("version", params.ClientInfo.Version),
                slog.String("project_id", projectID),
        )

        return NewSuccessResponse(req.ID, result)</span>
}

// handleToolsList handles the tools/list method
func (h *Handler) handleToolsList(c echo.Context, req *Request, user *auth.AuthUser) *Response <span class="cov8" title="1">{
        // Check session initialization
        token := extractToken(c)
        session := h.getSession(token)
        if session == nil || !session.Initialized </span><span class="cov8" title="1">{
                return NewErrorResponse(req.ID, ErrCodeInvalidRequest,
                        "Client must call initialize before tools/list",
                        map[string]string{"hint": "Call initialize method first to establish session"},
                )
        }</span>

        <span class="cov8" title="1">tools := h.svc.GetToolDefinitions()
        return NewSuccessResponse(req.ID, ToolsListResult{Tools: tools})</span>
}

// handleToolsCall handles the tools/call method
func (h *Handler) handleToolsCall(c echo.Context, req *Request, user *auth.AuthUser) *Response <span class="cov8" title="1">{
        // Check session initialization
        token := extractToken(c)
        session := h.getSession(token)
        if session == nil || !session.Initialized </span><span class="cov0" title="0">{
                return NewErrorResponse(req.ID, ErrCodeInvalidRequest,
                        "Client must call initialize before tools/call",
                        map[string]string{"hint": "Call initialize method first to establish session"},
                )
        }</span>

        // Parse params
        <span class="cov8" title="1">var params ToolsCallParams
        if len(req.Params) &gt; 0 </span><span class="cov8" title="1">{
                if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                        return NewErrorResponse(req.ID, ErrCodeInvalidParams,
                                "Invalid tools/call params", map[string]string{"error": err.Error()})
                }</span>
        }

        <span class="cov8" title="1">if params.Name == "" </span><span class="cov0" title="0">{
                return NewErrorResponse(req.ID, ErrCodeInvalidParams,
                        "Missing required parameter: name",
                        map[string]any{"required": []string{"name"}},
                )
        }</span>

        // Get project ID from session or user context
        <span class="cov8" title="1">projectID := session.ProjectID
        if projectID == "" </span><span class="cov8" title="1">{
                projectID = user.ProjectID
        }</span>

        <span class="cov8" title="1">if projectID == "" </span><span class="cov8" title="1">{
                // Some tools require project ID
                if requiresProject(params.Name) </span><span class="cov0" title="0">{
                        return NewErrorResponse(req.ID, ErrCodeInvalidParams,
                                "Project ID is required. Provide project_id in initialize params or X-Project-Id header.",
                                map[string]string{"hint": "Call initialize with project_id parameter or set X-Project-Id header"},
                        )
                }</span>
        }

        // Execute tool
        <span class="cov8" title="1">result, err := h.svc.ExecuteTool(c.Request().Context(), projectID, params.Name, params.Arguments)
        if err != nil </span><span class="cov8" title="1">{
                h.log.Error("tool execution failed",
                        slog.String("tool", params.Name),
                        logger.Error(err),
                )
                return NewErrorResponse(req.ID, ErrCodeInternalError,
                        "Tool execution failed: "+err.Error(),
                        nil,
                )
        }</span>

        <span class="cov8" title="1">return NewSuccessResponse(req.ID, result)</span>
}

// getSession returns the session for a token
func (h *Handler) getSession(token string) *Session <span class="cov8" title="1">{
        if token == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">h.sessionsMu.RLock()
        defer h.sessionsMu.RUnlock()
        return h.sessions[token]</span>
}

// extractToken extracts bearer token from request
func extractToken(c echo.Context) string <span class="cov8" title="1">{
        authHeader := c.Request().Header.Get("Authorization")
        if len(authHeader) &gt; 7 &amp;&amp; authHeader[:7] == "Bearer " </span><span class="cov8" title="1">{
                return authHeader[7:]
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// requiresProject returns true if the tool requires a project context
func requiresProject(toolName string) bool <span class="cov8" title="1">{
        switch toolName </span>{
        case "list_entity_types", "query_entities", "search_entities":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package mcp

import "encoding/json"

// JSON-RPC 2.0 types for MCP protocol

// Request represents a JSON-RPC 2.0 request
type Request struct {
        JSONRPC string          `json:"jsonrpc"`
        ID      json.RawMessage `json:"id,omitempty"` // Can be string, number, or null
        Method  string          `json:"method"`
        Params  json.RawMessage `json:"params,omitempty"`
}

// Response represents a JSON-RPC 2.0 response
type Response struct {
        JSONRPC string          `json:"jsonrpc"`
        ID      json.RawMessage `json:"id"`
        Result  any             `json:"result,omitempty"`
        Error   *ErrorObject    `json:"error,omitempty"`
}

// ErrorObject represents a JSON-RPC 2.0 error
type ErrorObject struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
        Data    any    `json:"data,omitempty"`
}

// JSON-RPC 2.0 error codes
const (
        ErrCodeParseError     = -32700
        ErrCodeInvalidRequest = -32600
        ErrCodeMethodNotFound = -32601
        ErrCodeInvalidParams  = -32602
        ErrCodeInternalError  = -32603

        // Custom MCP error codes
        ErrCodeUnauthorized = -32001
        ErrCodeForbidden    = -32002
        ErrCodeNotFound     = -32003
)

// MCP Protocol constants
var SupportedProtocolVersions = []string{"2025-06-18", "2025-11-25"}

const LatestProtocolVersion = "2025-11-25"

var ServerInfo = map[string]string{
        "name":    "emergent-mcp-server-go",
        "version": "1.0.0",
}

// NewErrorResponse creates a JSON-RPC error response
func NewErrorResponse(id json.RawMessage, code int, message string, data any) *Response <span class="cov8" title="1">{
        return &amp;Response{
                JSONRPC: "2.0",
                ID:      id,
                Error: &amp;ErrorObject{
                        Code:    code,
                        Message: message,
                        Data:    data,
                },
        }
}</span>

// NewSuccessResponse creates a JSON-RPC success response
func NewSuccessResponse(id json.RawMessage, result any) *Response <span class="cov8" title="1">{
        return &amp;Response{
                JSONRPC: "2.0",
                ID:      id,
                Result:  result,
        }
}</span>

// IsNotification checks if request is a notification (no ID)
func (r *Request) IsNotification() bool <span class="cov8" title="1">{
        return r.ID == nil || len(r.ID) == 0
}</span>

// GetIDString returns the ID as a string (for logging)
func (r *Request) GetIDString() string <span class="cov8" title="1">{
        if r.ID == nil || len(r.ID) == 0 </span><span class="cov8" title="1">{
                return "&lt;notification&gt;"
        }</span>
        <span class="cov8" title="1">return string(r.ID)</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">package mcp

import (
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/auth"
)

// RegisterRoutes registers all MCP routes
func RegisterRoutes(e *echo.Echo, h *Handler, sseHandler *SSEHandler, authMiddleware *auth.Middleware) <span class="cov8" title="1">{
        // MCP group requires authentication
        g := e.Group("/mcp")
        g.Use(authMiddleware.RequireAuth())

        // HTTP JSON-RPC endpoint (main MCP interface)
        g.POST("/rpc", h.HandleRPC)

        // SSE transport endpoints
        g.GET("/sse/:projectId", sseHandler.HandleSSEConnect)
        g.POST("/sse/:projectId/message", sseHandler.HandleSSEMessage)
}</span>
</pre>
		
		<pre class="file" id="file70" style="display: none">package mcp

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "log/slog"
        "sync"
        "time"

        "github.com/google/uuid"
        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/internal/database"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Service handles MCP business logic and tool execution
type Service struct {
        db  bun.IDB
        log *slog.Logger

        // Schema version caching
        cacheMu       sync.RWMutex
        cachedVersion string
        cacheExpiry   time.Time
}

// NewService creates a new MCP service
func NewService(db bun.IDB, log *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                db:  db,
                log: log.With(logger.Scope("mcp.svc")),
        }
}</span>

// GetToolDefinitions returns all available MCP tools
func (s *Service) GetToolDefinitions() []ToolDefinition <span class="cov8" title="1">{
        return []ToolDefinition{
                {
                        Name:        "schema_version",
                        Description: "Get the current schema version and metadata. Returns version hash, timestamp, total types, and relationships.",
                        InputSchema: InputSchema{
                                Type:       "object",
                                Properties: map[string]PropertySchema{},
                                Required:   []string{},
                        },
                },
                {
                        Name:        "list_entity_types",
                        Description: "List all available entity types in the knowledge graph with instance counts. Helps discover what entities can be queried.",
                        InputSchema: InputSchema{
                                Type:       "object",
                                Properties: map[string]PropertySchema{},
                                Required:   []string{},
                        },
                },
                {
                        Name:        "query_entities",
                        Description: "Query entity instances by type with pagination and filtering. Returns actual entity data from the knowledge graph.",
                        InputSchema: InputSchema{
                                Type: "object",
                                Properties: map[string]PropertySchema{
                                        "type_name": {
                                                Type:        "string",
                                                Description: "Entity type to query (e.g., \"Decision\", \"Project\", \"Document\")",
                                        },
                                        "limit": {
                                                Type:        "number",
                                                Description: "Maximum number of results (default: 10, max: 50)",
                                                Minimum:     intPtr(1),
                                                Maximum:     intPtr(50),
                                                Default:     10,
                                        },
                                        "offset": {
                                                Type:        "number",
                                                Description: "Pagination offset for results (default: 0)",
                                                Minimum:     intPtr(0),
                                                Default:     0,
                                        },
                                        "sort_by": {
                                                Type:        "string",
                                                Description: "Field to sort by (default: \"created_at\")",
                                                Enum:        []string{"created_at", "updated_at", "name"},
                                                Default:     "created_at",
                                        },
                                        "sort_order": {
                                                Type:        "string",
                                                Description: "Sort direction (default: \"desc\")",
                                                Enum:        []string{"asc", "desc"},
                                                Default:     "desc",
                                        },
                                },
                                Required: []string{"type_name"},
                        },
                },
                {
                        Name:        "search_entities",
                        Description: "Search entities by text query across name, key, and description fields.",
                        InputSchema: InputSchema{
                                Type: "object",
                                Properties: map[string]PropertySchema{
                                        "query": {
                                                Type:        "string",
                                                Description: "Search query text",
                                        },
                                        "type_name": {
                                                Type:        "string",
                                                Description: "Optional entity type filter",
                                        },
                                        "limit": {
                                                Type:        "number",
                                                Description: "Maximum number of results (default: 10, max: 50)",
                                                Minimum:     intPtr(1),
                                                Maximum:     intPtr(50),
                                                Default:     10,
                                        },
                                },
                                Required: []string{"query"},
                        },
                },
        }
}</span>

// ExecuteTool executes an MCP tool and returns the result
func (s *Service) ExecuteTool(ctx context.Context, projectID string, toolName string, args map[string]any) (*ToolResult, error) <span class="cov8" title="1">{
        switch toolName </span>{
        case "schema_version":<span class="cov8" title="1">
                return s.executeSchemaVersion(ctx)</span>
        case "list_entity_types":<span class="cov8" title="1">
                return s.executeListEntityTypes(ctx, projectID)</span>
        case "query_entities":<span class="cov8" title="1">
                return s.executeQueryEntities(ctx, projectID, args)</span>
        case "search_entities":<span class="cov8" title="1">
                return s.executeSearchEntities(ctx, projectID, args)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("tool not found: %s", toolName)</span>
        }
}

// executeSchemaVersion returns schema version metadata
func (s *Service) executeSchemaVersion(ctx context.Context) (*ToolResult, error) <span class="cov8" title="1">{
        version, err := s.getSchemaVersion(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Count template packs
        <span class="cov8" title="1">var packCount int
        err = s.db.NewSelect().
                TableExpr("kb.graph_template_packs").
                ColumnExpr("COUNT(*)").
                Scan(ctx, &amp;packCount)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Warn("failed to count template packs", logger.Error(err))
                packCount = 0
        }</span>

        <span class="cov8" title="1">result := SchemaVersionResult{
                Version:      version,
                Timestamp:    time.Now().UTC().Format(time.RFC3339),
                PackCount:    packCount,
                CacheHintTTL: 300, // 5 minutes
        }

        return s.wrapResult(result)</span>
}

// executeListEntityTypes returns all entity types with counts
func (s *Service) executeListEntityTypes(ctx context.Context, projectID string) (*ToolResult, error) <span class="cov8" title="1">{
        projectUUID, err := uuid.Parse(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid project_id: %w", err)
        }</span>

        // Query type registry with counts
        <span class="cov8" title="1">type typeRow struct {
                Name          string `bun:"name"`
                Description   string `bun:"description"`
                InstanceCount int    `bun:"instance_count"`
        }

        var types []typeRow

        err = s.db.RunInTx(ctx, nil, func(ctx context.Context, tx bun.Tx) error </span><span class="cov8" title="1">{
                // Set RLS context
                if err := database.SetRLSContext(ctx, tx, projectID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">err := tx.NewRaw(`
                        SELECT 
                                tr.type_name as name,
                                COALESCE(tr.description, '') as description,
                                COUNT(go.id)::int as instance_count
                        FROM kb.project_object_type_registry tr
                        LEFT JOIN kb.graph_objects go 
                                ON go.type = tr.type_name 
                                AND go.deleted_at IS NULL 
                                AND go.project_id = ?
                        WHERE tr.enabled = true 
                                AND tr.project_id = ?
                        GROUP BY tr.type_name, tr.description
                        ORDER BY tr.type_name
                `, projectUUID, projectUUID).Scan(ctx, &amp;types)
                return err</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query entity types: %w", err)
        }</span>

        <span class="cov8" title="1">entityTypes := make([]EntityType, len(types))
        for i, t := range types </span><span class="cov0" title="0">{
                desc := t.Description
                if desc == "" </span><span class="cov0" title="0">{
                        desc = "No description"
                }</span>
                <span class="cov0" title="0">entityTypes[i] = EntityType{
                        Name:        t.Name,
                        Description: desc,
                        Count:       t.InstanceCount,
                }</span>
        }

        <span class="cov8" title="1">result := EntityTypesResult{
                ProjectID: projectID,
                Types:     entityTypes,
                Total:     len(entityTypes),
        }

        return s.wrapResult(result)</span>
}

// executeQueryEntities queries entities by type with pagination
func (s *Service) executeQueryEntities(ctx context.Context, projectID string, args map[string]any) (*ToolResult, error) <span class="cov8" title="1">{
        projectUUID, err := uuid.Parse(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid project_id: %w", err)
        }</span>

        // Parse arguments
        <span class="cov8" title="1">typeName, _ := args["type_name"].(string)
        if typeName == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing required parameter: type_name")
        }</span>

        <span class="cov8" title="1">limit := 10
        if l, ok := args["limit"].(float64); ok </span><span class="cov0" title="0">{
                limit = int(l)
        }</span>
        <span class="cov8" title="1">if limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 1
        }</span>
        <span class="cov8" title="1">if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov8" title="1">offset := 0
        if o, ok := args["offset"].(float64); ok </span><span class="cov0" title="0">{
                offset = int(o)
        }</span>
        <span class="cov8" title="1">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        <span class="cov8" title="1">sortBy := "created_at"
        if sb, ok := args["sort_by"].(string); ok &amp;&amp; sb != "" </span><span class="cov0" title="0">{
                // Validate sort field
                switch sb </span>{
                case "created_at", "updated_at", "name":<span class="cov0" title="0">
                        sortBy = sb</span>
                }
        }

        <span class="cov8" title="1">sortOrder := "DESC"
        if so, ok := args["sort_order"].(string); ok </span><span class="cov0" title="0">{
                if so == "asc" </span><span class="cov0" title="0">{
                        sortOrder = "ASC"
                }</span>
        }

        // Build sort expression based on field
        <span class="cov8" title="1">orderExpr := fmt.Sprintf("go.%s %s", sortBy, sortOrder)
        if sortBy == "name" </span><span class="cov0" title="0">{
                orderExpr = fmt.Sprintf("go.properties-&gt;&gt;'name' %s NULLS LAST", sortOrder)
        }</span>

        <span class="cov8" title="1">type entityRow struct {
                ID              uuid.UUID      `bun:"id"`
                Key             string         `bun:"key"`
                Name            string         `bun:"name"`
                TypeName        string         `bun:"type_name"`
                Properties      map[string]any `bun:"properties,type:jsonb"`
                CreatedAt       time.Time      `bun:"created_at"`
                UpdatedAt       time.Time      `bun:"updated_at"`
                TypeDescription string         `bun:"type_description"`
        }

        var entities []entityRow
        var total int

        err = s.db.RunInTx(ctx, nil, func(ctx context.Context, tx bun.Tx) error </span><span class="cov8" title="1">{
                if err := database.SetRLSContext(ctx, tx, projectID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Query entities
                <span class="cov8" title="1">err := tx.NewRaw(`
                        SELECT 
                                go.id,
                                go.key,
                                COALESCE(go.properties-&gt;&gt;'name', '') as name,
                                go.properties,
                                go.created_at,
                                COALESCE(go.updated_at, go.created_at) as updated_at,
                                go.type as type_name,
                                COALESCE(tr.description, '') as type_description
                        FROM kb.graph_objects go
                        LEFT JOIN kb.project_object_type_registry tr ON tr.type_name = go.type AND tr.project_id = go.project_id
                        WHERE go.type = ?
                                AND go.deleted_at IS NULL
                                AND go.project_id = ?
                        ORDER BY `+orderExpr+`
                        LIMIT ? OFFSET ?
                `, typeName, projectUUID, limit, offset).Scan(ctx, &amp;entities)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Get total count
                <span class="cov8" title="1">err = tx.NewRaw(`
                        SELECT COUNT(*)
                        FROM kb.graph_objects go
                        WHERE go.type = ?
                                AND go.deleted_at IS NULL
                                AND go.project_id = ?
                `, typeName, projectUUID).Scan(ctx, &amp;total)
                return err</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query entities: %w", err)
        }</span>

        // Transform to response format
        <span class="cov8" title="1">resultEntities := make([]Entity, len(entities))
        for i, e := range entities </span><span class="cov0" title="0">{
                resultEntities[i] = Entity{
                        ID:         e.ID.String(),
                        Key:        e.Key,
                        Name:       e.Name,
                        Type:       e.TypeName,
                        Properties: e.Properties,
                        CreatedAt:  e.CreatedAt,
                        UpdatedAt:  e.UpdatedAt,
                }
        }</span>

        <span class="cov8" title="1">result := QueryEntitiesResult{
                ProjectID: projectID,
                Entities:  resultEntities,
                Pagination: &amp;PaginationInfo{
                        Total:   total,
                        Limit:   limit,
                        Offset:  offset,
                        HasMore: offset+limit &lt; total,
                },
        }

        return s.wrapResult(result)</span>
}

// executeSearchEntities searches entities by text
func (s *Service) executeSearchEntities(ctx context.Context, projectID string, args map[string]any) (*ToolResult, error) <span class="cov8" title="1">{
        projectUUID, err := uuid.Parse(projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid project_id: %w", err)
        }</span>

        // Parse arguments
        <span class="cov8" title="1">query, _ := args["query"].(string)
        if query == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("missing required parameter: query")
        }</span>

        <span class="cov8" title="1">typeName, _ := args["type_name"].(string)

        limit := 10
        if l, ok := args["limit"].(float64); ok </span><span class="cov0" title="0">{
                limit = int(l)
        }</span>
        <span class="cov8" title="1">if limit &lt; 1 </span><span class="cov0" title="0">{
                limit = 1
        }</span>
        <span class="cov8" title="1">if limit &gt; 50 </span><span class="cov0" title="0">{
                limit = 50
        }</span>

        <span class="cov8" title="1">type entityRow struct {
                ID         uuid.UUID      `bun:"id"`
                Key        string         `bun:"key"`
                Name       string         `bun:"name"`
                TypeName   string         `bun:"type_name"`
                Properties map[string]any `bun:"properties,type:jsonb"`
                CreatedAt  time.Time      `bun:"created_at"`
        }

        var entities []entityRow
        searchPattern := "%" + query + "%"

        err = s.db.RunInTx(ctx, nil, func(ctx context.Context, tx bun.Tx) error </span><span class="cov8" title="1">{
                if err := database.SetRLSContext(ctx, tx, projectID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">baseQuery := `
                        SELECT 
                                go.id,
                                go.key,
                                COALESCE(go.properties-&gt;&gt;'name', '') as name,
                                go.properties,
                                go.type as type_name,
                                go.created_at
                        FROM kb.graph_objects go
                        WHERE go.deleted_at IS NULL
                                AND go.project_id = ?
                                AND (
                                        go.key ILIKE ?
                                        OR go.properties-&gt;&gt;'name' ILIKE ?
                                        OR go.properties-&gt;&gt;'description' ILIKE ?
                                )
                `
                queryArgs := []any{projectUUID, searchPattern, searchPattern, searchPattern}

                if typeName != "" </span><span class="cov0" title="0">{
                        baseQuery += " AND go.type = ?"
                        queryArgs = append(queryArgs, typeName)
                }</span>

                <span class="cov8" title="1">baseQuery += " ORDER BY go.created_at DESC LIMIT ?"
                queryArgs = append(queryArgs, limit)

                return tx.NewRaw(baseQuery, queryArgs...).Scan(ctx, &amp;entities)</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("search entities: %w", err)
        }</span>

        // Transform to response format
        <span class="cov8" title="1">resultEntities := make([]Entity, len(entities))
        for i, e := range entities </span><span class="cov0" title="0">{
                resultEntities[i] = Entity{
                        ID:         e.ID.String(),
                        Key:        e.Key,
                        Name:       e.Name,
                        Type:       e.TypeName,
                        Properties: e.Properties,
                        CreatedAt:  e.CreatedAt,
                }
        }</span>

        <span class="cov8" title="1">result := SearchEntitiesResult{
                ProjectID: projectID,
                Query:     query,
                Entities:  resultEntities,
                Count:     len(resultEntities),
        }

        return s.wrapResult(result)</span>
}

// getSchemaVersion computes or returns cached schema version
func (s *Service) getSchemaVersion(ctx context.Context) (string, error) <span class="cov8" title="1">{
        s.cacheMu.RLock()
        if s.cachedVersion != "" &amp;&amp; time.Now().Before(s.cacheExpiry) </span><span class="cov0" title="0">{
                version := s.cachedVersion
                s.cacheMu.RUnlock()
                return version, nil
        }</span>
        <span class="cov8" title="1">s.cacheMu.RUnlock()

        // Compute new version
        s.cacheMu.Lock()
        defer s.cacheMu.Unlock()

        // Double-check after acquiring write lock
        if s.cachedVersion != "" &amp;&amp; time.Now().Before(s.cacheExpiry) </span><span class="cov0" title="0">{
                return s.cachedVersion, nil
        }</span>

        // Fetch template packs
        <span class="cov8" title="1">type packInfo struct {
                ID        string    `bun:"id"`
                UpdatedAt time.Time `bun:"updated_at"`
        }

        var packs []packInfo
        err := s.db.NewSelect().
                TableExpr("kb.graph_template_packs").
                Column("id", "updated_at").
                OrderExpr("id ASC").
                Scan(ctx, &amp;packs)

        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("query template packs: %w", err)
        }</span>

        // Build composite string
        <span class="cov8" title="1">composite := ""
        for _, p := range packs </span><span class="cov0" title="0">{
                composite += fmt.Sprintf("%s:%d|", p.ID, p.UpdatedAt.Unix())
        }</span>

        // Compute MD5 hash
        <span class="cov8" title="1">hash := md5.Sum([]byte(composite))
        version := hex.EncodeToString(hash[:])[:16]

        // Cache result
        s.cachedVersion = version
        s.cacheExpiry = time.Now().Add(60 * time.Second)

        return version, nil</span>
}

// wrapResult wraps a result in MCP ToolResult format
func (s *Service) wrapResult(data any) (*ToolResult, error) <span class="cov8" title="1">{
        jsonBytes, err := json.MarshalIndent(data, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("marshal result: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;ToolResult{
                Content: []ContentBlock{
                        {
                                Type: "text",
                                Text: string(jsonBytes),
                        },
                },
        }, nil</span>
}

// Helper function for pointer to int
func intPtr(i int) *int <span class="cov8" title="1">{
        return &amp;i
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package mcp

import (
        "crypto/rand"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "log/slog"
        "net/http"
        "sync"
        "time"

        "github.com/google/uuid"
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
        "github.com/emergent/emergent-core/pkg/logger"
)

// SSEHandler handles MCP SSE transport
type SSEHandler struct {
        svc *Service
        log *slog.Logger

        // SSE sessions
        sseSessions   map[string]*SSESession
        sseSessionsMu sync.RWMutex
}

// SSESession represents an SSE connection session
type SSESession struct {
        ID          string
        ProjectID   string
        UserID      string
        Initialized bool
        Done        chan struct{}
        Writer      http.ResponseWriter
        Flusher     http.Flusher
}

// NewSSEHandler creates a new SSE handler
func NewSSEHandler(svc *Service, log *slog.Logger) *SSEHandler <span class="cov8" title="1">{
        return &amp;SSEHandler{
                svc:         svc,
                log:         log.With(logger.Scope("mcp.sse")),
                sseSessions: make(map[string]*SSESession),
        }
}</span>

// HandleSSEConnect handles GET /mcp/sse/:projectId - SSE connection endpoint
func (h *SSEHandler) HandleSSEConnect(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID := c.Param("projectId")
        if _, err := uuid.Parse(projectID); err != nil </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("invalid project ID")
        }</span>

        // Generate session ID
        <span class="cov0" title="0">sessionID := h.generateSessionID()

        // Set up SSE headers
        w := c.Response().Writer
        w.Header().Set("Content-Type", "text/event-stream")
        w.Header().Set("Cache-Control", "no-cache")
        w.Header().Set("Connection", "keep-alive")
        w.Header().Set("X-Accel-Buffering", "no")

        flusher, ok := w.(http.Flusher)
        if !ok </span><span class="cov0" title="0">{
                return apperror.ErrInternal.WithMessage("streaming not supported")
        }</span>

        // Create session
        <span class="cov0" title="0">session := &amp;SSESession{
                ID:          sessionID,
                ProjectID:   projectID,
                UserID:      user.ID,
                Initialized: false,
                Done:        make(chan struct{}),
                Writer:      w,
                Flusher:     flusher,
        }

        h.sseSessionsMu.Lock()
        h.sseSessions[sessionID] = session
        h.sseSessionsMu.Unlock()

        defer func() </span><span class="cov0" title="0">{
                h.sseSessionsMu.Lock()
                delete(h.sseSessions, sessionID)
                h.sseSessionsMu.Unlock()
                close(session.Done)
        }</span>()

        <span class="cov0" title="0">h.log.Info("SSE session started",
                slog.String("session_id", sessionID),
                slog.String("project_id", projectID),
                slog.String("user_id", user.ID),
        )

        // Send endpoint event (tells client where to POST messages)
        messageEndpoint := fmt.Sprintf("/mcp/sse/%s/message?sessionId=%s", projectID, sessionID)
        h.sendSSEEvent(session, "endpoint", messageEndpoint)

        // Keep connection alive with periodic pings
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        // Wait for disconnect
        ctx := c.Request().Context()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        h.log.Info("SSE session ended (client disconnected)",
                                slog.String("session_id", sessionID))
                        return nil</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        h.sendSSEEvent(session, "ping", time.Now().UTC().Format(time.RFC3339))</span>
                }
        }
}

// HandleSSEMessage handles POST /mcp/sse/:projectId/message - Send messages to MCP server
func (h *SSEHandler) HandleSSEMessage(c echo.Context) error <span class="cov0" title="0">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">projectID := c.Param("projectId")
        if _, err := uuid.Parse(projectID); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project ID")
        }</span>

        <span class="cov0" title="0">sessionID := c.QueryParam("sessionId")

        // Parse JSON-RPC request
        var req Request
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return c.JSON(http.StatusBadRequest, map[string]any{
                        "error": map[string]string{
                                "code":    "parse_error",
                                "message": "Failed to parse JSON-RPC request",
                        },
                })
        }</span>

        // Validate JSON-RPC version
        <span class="cov0" title="0">if req.JSONRPC != "2.0" </span><span class="cov0" title="0">{
                resp := NewErrorResponse(req.ID, ErrCodeInvalidRequest, "Invalid JSON-RPC version", nil)
                return h.sendResponseToSession(c, sessionID, resp)
        }</span>

        // Process request
        <span class="cov0" title="0">response := h.processRequest(c, &amp;req, projectID, user)

        // Send response via SSE if session exists
        if sessionID != "" </span><span class="cov0" title="0">{
                h.sseSessionsMu.RLock()
                session, ok := h.sseSessions[sessionID]
                h.sseSessionsMu.RUnlock()

                if ok &amp;&amp; session != nil </span><span class="cov0" title="0">{
                        jsonBytes, _ := json.Marshal(response)
                        h.sendSSEEvent(session, "message", string(jsonBytes))
                }</span>
        }

        // Also return response directly (for clients that prefer HTTP response)
        <span class="cov0" title="0">return c.JSON(http.StatusAccepted, map[string]any{
                "status":  "accepted",
                "jsonrpc": response.JSONRPC,
                "id":      response.ID,
                "result":  response.Result,
                "error":   response.Error,
        })</span>
}

// processRequest processes a JSON-RPC request for SSE transport
func (h *SSEHandler) processRequest(c echo.Context, req *Request, projectID string, user *auth.AuthUser) *Response <span class="cov0" title="0">{
        switch req.Method </span>{
        case "initialize":<span class="cov0" title="0">
                return h.handleInitialize(req, projectID)</span>
        case "tools/list":<span class="cov0" title="0">
                return h.handleToolsList(req)</span>
        case "tools/call":<span class="cov0" title="0">
                return h.handleToolsCall(c, req, projectID, user)</span>
        case "notifications/initialized":<span class="cov0" title="0">
                return NewSuccessResponse(req.ID, map[string]bool{"acknowledged": true})</span>
        default:<span class="cov0" title="0">
                return NewErrorResponse(req.ID, ErrCodeMethodNotFound, "Method not found: "+req.Method, nil)</span>
        }
}

// handleInitialize handles initialize for SSE transport
func (h *SSEHandler) handleInitialize(req *Request, projectID string) *Response <span class="cov0" title="0">{
        var params InitializeParams
        if len(req.Params) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                        return NewErrorResponse(req.ID, ErrCodeInvalidParams, "Invalid params", nil)
                }</span>
        }

        <span class="cov0" title="0">if params.ProtocolVersion == "" || params.ClientInfo.Name == "" </span><span class="cov0" title="0">{
                return NewErrorResponse(req.ID, ErrCodeInvalidParams,
                        "Missing required parameters: protocolVersion, clientInfo", nil)
        }</span>

        // Validate protocol version
        <span class="cov0" title="0">valid := false
        for _, v := range SupportedProtocolVersions </span><span class="cov0" title="0">{
                if v == params.ProtocolVersion </span><span class="cov0" title="0">{
                        valid = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                return NewErrorResponse(req.ID, ErrCodeInvalidParams,
                        "Unsupported protocol version: "+params.ProtocolVersion,
                        map[string]any{"supported": SupportedProtocolVersions})
        }</span>

        <span class="cov0" title="0">result := InitializeResult{
                ProtocolVersion: params.ProtocolVersion,
                Capabilities: ServerCapabilities{
                        Tools: ToolsCapability{ListChanged: false},
                },
                ServerInfo:     ServerInfo,
                ProjectContext: map[string]string{"projectId": projectID},
        }

        return NewSuccessResponse(req.ID, result)</span>
}

// handleToolsList handles tools/list for SSE transport
func (h *SSEHandler) handleToolsList(req *Request) *Response <span class="cov0" title="0">{
        tools := h.svc.GetToolDefinitions()
        return NewSuccessResponse(req.ID, ToolsListResult{Tools: tools})
}</span>

// handleToolsCall handles tools/call for SSE transport
func (h *SSEHandler) handleToolsCall(c echo.Context, req *Request, projectID string, user *auth.AuthUser) *Response <span class="cov0" title="0">{
        var params ToolsCallParams
        if len(req.Params) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(req.Params, &amp;params); err != nil </span><span class="cov0" title="0">{
                        return NewErrorResponse(req.ID, ErrCodeInvalidParams, "Invalid params", nil)
                }</span>
        }

        <span class="cov0" title="0">if params.Name == "" </span><span class="cov0" title="0">{
                return NewErrorResponse(req.ID, ErrCodeInvalidParams, "Missing required parameter: name", nil)
        }</span>

        <span class="cov0" title="0">result, err := h.svc.ExecuteTool(c.Request().Context(), projectID, params.Name, params.Arguments)
        if err != nil </span><span class="cov0" title="0">{
                h.log.Error("tool execution failed",
                        slog.String("tool", params.Name),
                        logger.Error(err),
                )
                return NewErrorResponse(req.ID, ErrCodeInternalError, "Tool execution failed: "+err.Error(), nil)
        }</span>

        <span class="cov0" title="0">return NewSuccessResponse(req.ID, result)</span>
}

// sendSSEEvent sends an SSE event to a session
func (h *SSEHandler) sendSSEEvent(session *SSESession, event, data string) <span class="cov0" title="0">{
        select </span>{
        case &lt;-session.Done:<span class="cov0" title="0">
                return</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">fmt.Fprintf(session.Writer, "event: %s\n", event)
        fmt.Fprintf(session.Writer, "data: %s\n\n", data)
        session.Flusher.Flush()</span>
}

// sendResponseToSession sends a response via SSE or HTTP
func (h *SSEHandler) sendResponseToSession(c echo.Context, sessionID string, resp *Response) error <span class="cov0" title="0">{
        if sessionID != "" </span><span class="cov0" title="0">{
                h.sseSessionsMu.RLock()
                session, ok := h.sseSessions[sessionID]
                h.sseSessionsMu.RUnlock()

                if ok &amp;&amp; session != nil </span><span class="cov0" title="0">{
                        jsonBytes, _ := json.Marshal(resp)
                        h.sendSSEEvent(session, "message", string(jsonBytes))
                }</span>
        }
        <span class="cov0" title="0">return c.JSON(http.StatusOK, resp)</span>
}

// generateSessionID creates a unique session ID
func (h *SSEHandler) generateSessionID() string <span class="cov0" title="0">{
        bytes := make([]byte, 16)
        rand.Read(bytes)
        return fmt.Sprintf("mcp_%d_%s", time.Now().UnixMilli(), hex.EncodeToString(bytes)[:12])
}</span>
</pre>
		
		<pre class="file" id="file72" style="display: none">package orgs

import (
        "time"

        "github.com/uptrace/bun"
)

// Org represents an organization in the kb.orgs table
type Org struct {
        bun.BaseModel `bun:"table:kb.orgs,alias:o"`

        ID        string     `bun:"id,pk,type:uuid,default:uuid_generate_v4()" json:"id"`
        Name      string     `bun:"name,notnull" json:"name"`
        CreatedAt time.Time  `bun:"created_at,notnull,default:now()" json:"createdAt"`
        UpdatedAt time.Time  `bun:"updated_at,notnull,default:now()" json:"updatedAt"`
        DeletedAt *time.Time `bun:"deleted_at" json:"deletedAt,omitempty"`
        DeletedBy *string    `bun:"deleted_by,type:uuid" json:"deletedBy,omitempty"`
}

// OrganizationMembership represents a user's membership in an organization
type OrganizationMembership struct {
        bun.BaseModel `bun:"table:kb.organization_memberships,alias:om"`

        ID             string    `bun:"id,pk,type:uuid,default:uuid_generate_v4()" json:"id"`
        OrganizationID string    `bun:"organization_id,notnull,type:uuid" json:"organizationId"`
        UserID         string    `bun:"user_id,notnull,type:uuid" json:"userId"`
        Role           string    `bun:"role,notnull" json:"role"`
        CreatedAt      time.Time `bun:"created_at,notnull,default:now()" json:"createdAt"`

        // Relations (for joining)
        Organization *Org `bun:"rel:belongs-to,join:organization_id=id" json:"organization,omitempty"`
}

// OrgDTO is the response DTO for organization endpoints
type OrgDTO struct {
        ID   string `json:"id"`
        Name string `json:"name"`
}

// CreateOrgRequest is the request body for creating an organization
type CreateOrgRequest struct {
        Name string `json:"name" validate:"required,min=1,max=120"`
}

// ToDTO converts an Org entity to OrgDTO
func (o *Org) ToDTO() OrgDTO <span class="cov8" title="1">{
        return OrgDTO{
                ID:   o.ID,
                Name: o.Name,
        }
}</span>
</pre>
		
		<pre class="file" id="file73" style="display: none">package orgs

import (
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

// Handler handles HTTP requests for organizations
type Handler struct {
        svc *Service
}

// NewHandler creates a new organization handler
func NewHandler(svc *Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{svc: svc}
}</span>

// List returns all organizations the authenticated user is a member of
// GET /api/v2/orgs
func (h *Handler) List(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">orgs, err := h.svc.List(c.Request().Context(), user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, orgs)</span>
}

// Get returns a single organization by ID
// GET /api/v2/orgs/:id
func (h *Handler) Get(c echo.Context) error <span class="cov8" title="1">{
        id := c.Param("id")

        org, err := h.svc.GetByID(c.Request().Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, org)</span>
}

// Create creates a new organization
// POST /api/v2/orgs
func (h *Handler) Create(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">var req CreateOrgRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        <span class="cov8" title="1">org, err := h.svc.Create(c.Request().Context(), req.Name, user.ID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, org)</span>
}

// Delete deletes an organization by ID
// DELETE /api/v2/orgs/:id
func (h *Handler) Delete(c echo.Context) error <span class="cov8" title="1">{
        id := c.Param("id")

        if err := h.svc.Delete(c.Request().Context(), id); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, map[string]string{"status": "deleted"})</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package orgs

import (
        "context"
        "database/sql"
        "log/slog"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/internal/database"
        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Repository handles database operations for organizations
type Repository struct {
        db  bun.IDB
        log *slog.Logger
}

// NewRepository creates a new organization repository
func NewRepository(db bun.IDB, log *slog.Logger) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                db:  db,
                log: log.With(logger.Scope("orgs.repo")),
        }
}</span>

// List returns all organizations the user is a member of
func (r *Repository) List(ctx context.Context, userID string) ([]OrgDTO, error) <span class="cov8" title="1">{
        var orgs []Org

        err := r.db.NewSelect().
                Model(&amp;orgs).
                Join("INNER JOIN kb.organization_memberships AS om ON om.organization_id = o.id").
                Where("om.user_id = ?", userID).
                Where("o.deleted_at IS NULL").
                Order("o.created_at DESC").
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to list organizations", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">result := make([]OrgDTO, len(orgs))
        for i, org := range orgs </span><span class="cov8" title="1">{
                result[i] = org.ToDTO()
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// GetByID returns an organization by ID
func (r *Repository) GetByID(ctx context.Context, id string) (*Org, error) <span class="cov8" title="1">{
        var org Org

        err := r.db.NewSelect().
                Model(&amp;org).
                Where("id = ?", id).
                Where("deleted_at IS NULL").
                Scan(ctx)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, apperror.ErrNotFound.WithMessage("Organization not found")
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to get organization", logger.Error(err), slog.String("id", id))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return &amp;org, nil</span>
}

// CountUserMemberships returns the number of organizations a user is a member of
func (r *Repository) CountUserMemberships(ctx context.Context, userID string) (int, error) <span class="cov8" title="1">{
        count, err := r.db.NewSelect().
                Model((*OrganizationMembership)(nil)).
                Where("user_id = ?", userID).
                Count(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to count user memberships", logger.Error(err), slog.String("userID", userID))
                return 0, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

// Create creates a new organization and adds the creator as org_admin
func (r *Repository) Create(ctx context.Context, name string, userID string) (*Org, error) <span class="cov8" title="1">{
        tx, err := database.BeginSafeTx(ctx, r.db)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to begin transaction", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Create the organization
        org := &amp;Org{Name: name}
        _, err = tx.NewInsert().
                Model(org).
                Returning("*").
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                // Check for unique constraint violation (duplicate name)
                if isUniqueViolation(err) </span><span class="cov0" title="0">{
                        return nil, apperror.New(409, "conflict", "Organization name already exists")
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to create organization", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        // Create membership for the creator as org_admin
        <span class="cov8" title="1">membership := &amp;OrganizationMembership{
                OrganizationID: org.ID,
                UserID:         userID,
                Role:           "org_admin",
        }
        _, err = tx.NewInsert().
                Model(membership).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                // Check for FK violation (user profile doesn't exist)
                if isForeignKeyViolation(err) </span><span class="cov0" title="0">{
                        return nil, apperror.ErrBadRequest.WithMessage("User profile not properly initialized. Please try logging out and back in.")
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to create membership", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to commit transaction", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return org, nil</span>
}

// Delete hard deletes an organization by ID
func (r *Repository) Delete(ctx context.Context, id string) (bool, error) <span class="cov8" title="1">{
        result, err := r.db.NewDelete().
                Model((*Org)(nil)).
                Where("id = ?", id).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to delete organization", logger.Error(err), slog.String("id", id))
                return false, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()
        return rowsAffected &gt; 0, nil</span>
}

// IsUserMember checks if a user is a member of an organization
func (r *Repository) IsUserMember(ctx context.Context, orgID, userID string) (bool, error) <span class="cov0" title="0">{
        exists, err := r.db.NewSelect().
                Model((*OrganizationMembership)(nil)).
                Where("organization_id = ?", orgID).
                Where("user_id = ?", userID).
                Exists(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to check membership", logger.Error(err),
                        slog.String("orgID", orgID),
                        slog.String("userID", userID))
                return false, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// Helper functions to check PostgreSQL error codes
func isUniqueViolation(err error) bool <span class="cov8" title="1">{
        return containsErrorCode(err, "23505")
}</span>

func isForeignKeyViolation(err error) bool <span class="cov8" title="1">{
        return containsErrorCode(err, "23503")
}</span>

func containsErrorCode(err error, code string) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        // pgx wraps errors, so we need to check the error message
        <span class="cov8" title="1">errStr := err.Error()
        return len(errStr) &gt; 0 &amp;&amp; (contains(errStr, code) || contains(errStr, "SQLSTATE "+code))</span>
}

func contains(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp; searchSubstring(s, substr)
}</span>

func searchSubstring(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">package orgs

import (
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/auth"
)

// RegisterRoutes registers organization routes
func RegisterRoutes(e *echo.Echo, h *Handler, authMiddleware *auth.Middleware) <span class="cov8" title="1">{
        // All org endpoints require authentication
        g := e.Group("/api/v2/orgs")
        g.Use(authMiddleware.RequireAuth())

        // List organizations (user must be authenticated)
        g.GET("", h.List)

        // Get organization by ID (authenticated, no specific scope required)
        g.GET("/:id", h.Get)

        // Create organization (authenticated)
        g.POST("", h.Create)

        // Delete organization (authenticated)
        g.DELETE("/:id", h.Delete)
}</span>
</pre>
		
		<pre class="file" id="file76" style="display: none">package orgs

import (
        "context"
        "log/slog"
        "strings"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

const (
        // MaxOrgsPerUser is the maximum number of organizations a user can create
        MaxOrgsPerUser = 100
        // MaxOrgNameLength is the maximum length of an organization name
        MaxOrgNameLength = 120
)

// Service handles business logic for organizations
type Service struct {
        repo *Repository
        log  *slog.Logger
}

// NewService creates a new organization service
func NewService(repo *Repository, log *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: repo,
                log:  log.With(logger.Scope("orgs.svc")),
        }
}</span>

// List returns all organizations the user is a member of
func (s *Service) List(ctx context.Context, userID string) ([]OrgDTO, error) <span class="cov8" title="1">{
        if userID == "" </span><span class="cov0" title="0">{
                return []OrgDTO{}, nil
        }</span>
        <span class="cov8" title="1">return s.repo.List(ctx, userID)</span>
}

// GetByID returns an organization by ID
func (s *Service) GetByID(ctx context.Context, id string) (*OrgDTO, error) <span class="cov8" title="1">{
        org, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">dto := org.ToDTO()
        return &amp;dto, nil</span>
}

// Create creates a new organization
func (s *Service) Create(ctx context.Context, name string, userID string) (*OrgDTO, error) <span class="cov8" title="1">{
        // Validate and sanitize name
        name = strings.TrimSpace(name)
        if name == "" </span><span class="cov8" title="1">{
                return nil, apperror.ErrBadRequest.WithMessage("Organization name is required")
        }</span>
        <span class="cov8" title="1">if len(name) &gt; MaxOrgNameLength </span><span class="cov8" title="1">{
                return nil, apperror.ErrBadRequest.WithMessage("Organization name must be at most 120 characters")
        }</span>

        // Check user's organization limit
        <span class="cov8" title="1">if userID != "" </span><span class="cov8" title="1">{
                count, err := s.repo.CountUserMemberships(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if count &gt;= MaxOrgsPerUser </span><span class="cov0" title="0">{
                        return nil, apperror.New(409, "conflict", "Organization limit reached (100). You can create up to 100 organizations.")
                }</span>
        }

        // Create the organization
        <span class="cov8" title="1">org, err := s.repo.Create(ctx, name, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s.log.Info("organization created",
                slog.String("orgID", org.ID),
                slog.String("name", org.Name),
                slog.String("userID", userID))

        dto := org.ToDTO()
        return &amp;dto, nil</span>
}

// Delete deletes an organization by ID
func (s *Service) Delete(ctx context.Context, id string) error <span class="cov8" title="1">{
        deleted, err := s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !deleted </span><span class="cov8" title="1">{
                return apperror.ErrNotFound.WithMessage("Organization not found")
        }</span>

        <span class="cov8" title="1">s.log.Info("organization deleted", slog.String("orgID", id))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package projects

import (
        "time"

        "github.com/uptrace/bun"
)

// Project represents a project in the kb.projects table
// Note: Only includes columns from the squashed initial migration.
// Additional columns (chunking_config, allow_parallel_extraction, extraction_config,
// deleted_at, deleted_by) are added in later migrations and should be added here
// when needed with appropriate migration checks.
type Project struct {
        bun.BaseModel `bun:"table:kb.projects,alias:p"`

        ID                 string         `bun:"id,pk,type:uuid,default:gen_random_uuid()" json:"id"`
        OrganizationID     string         `bun:"organization_id,notnull,type:uuid" json:"organizationId"`
        Name               string         `bun:"name,notnull" json:"name"`
        KBPurpose          *string        `bun:"kb_purpose" json:"kb_purpose,omitempty"`
        ChatPromptTemplate *string        `bun:"chat_prompt_template" json:"chat_prompt_template,omitempty"`
        AutoExtractObjects bool           `bun:"auto_extract_objects,notnull,default:false" json:"auto_extract_objects"`
        AutoExtractConfig  map[string]any `bun:"auto_extract_config,type:jsonb,default:'{}'" json:"auto_extract_config,omitempty"`
        CreatedAt          time.Time      `bun:"created_at,notnull,default:now()" json:"createdAt"`
        UpdatedAt          time.Time      `bun:"updated_at,notnull,default:now()" json:"updatedAt"`
}

// ChunkingConfig represents the chunking configuration for a project
// Note: This column is added in migration 1763120000000-AddProjectChunkingConfig
// Keeping for future use when we ensure all migrations run
type ChunkingConfig struct {
        Strategy     string `json:"strategy,omitempty"`     // "character" | "sentence" | "paragraph"
        MaxChunkSize *int   `json:"maxChunkSize,omitempty"` // 100-25000
        MinChunkSize *int   `json:"minChunkSize,omitempty"` // 10-10000
        Overlap      *int   `json:"overlap,omitempty"`      // 0-500
}

// ExtractionConfig represents the extraction configuration for a project
// Note: This column may be added in a later migration
// Keeping for future use when we ensure all migrations run
type ExtractionConfig struct {
        ChunkSize      *int    `json:"chunkSize,omitempty"`      // 5000-100000
        Method         *string `json:"method,omitempty"`         // "json_freeform" | "function_calling" | "responseSchema"
        TimeoutSeconds *int    `json:"timeoutSeconds,omitempty"` // 60-600
}

// ProjectMembership represents a user's membership in a project
type ProjectMembership struct {
        bun.BaseModel `bun:"table:kb.project_memberships,alias:pm"`

        ID        string    `bun:"id,pk,type:uuid,default:gen_random_uuid()" json:"id"`
        ProjectID string    `bun:"project_id,notnull,type:uuid" json:"projectId"`
        UserID    string    `bun:"user_id,notnull,type:uuid" json:"userId"`
        Role      string    `bun:"role,notnull" json:"role"` // "project_admin" | "project_user"
        CreatedAt time.Time `bun:"created_at,notnull,default:now()" json:"createdAt"`

        // Relations (for joining)
        Project *Project `bun:"rel:belongs-to,join:project_id=id" json:"project,omitempty"`
}

// Role constants
const (
        RoleProjectAdmin = "project_admin"
        RoleProjectUser  = "project_user"
)

// ProjectDTO is the response DTO for project endpoints
type ProjectDTO struct {
        ID                 string         `json:"id"`
        Name               string         `json:"name"`
        OrgID              string         `json:"orgId"`
        KBPurpose          *string        `json:"kb_purpose,omitempty"`
        ChatPromptTemplate *string        `json:"chat_prompt_template,omitempty"`
        AutoExtractObjects *bool          `json:"auto_extract_objects,omitempty"`
        AutoExtractConfig  map[string]any `json:"auto_extract_config,omitempty"`
}

// ProjectMemberDTO is the response DTO for project member endpoints
type ProjectMemberDTO struct {
        ID          string    `json:"id"`
        Email       string    `json:"email"`
        DisplayName *string   `json:"displayName,omitempty"`
        FirstName   *string   `json:"firstName,omitempty"`
        LastName    *string   `json:"lastName,omitempty"`
        AvatarURL   *string   `json:"avatarUrl,omitempty"`
        Role        string    `json:"role"`
        JoinedAt    time.Time `json:"joinedAt"`
}

// CreateProjectRequest is the request body for creating a project
type CreateProjectRequest struct {
        Name  string `json:"name" validate:"required,min=1"`
        OrgID string `json:"orgId" validate:"required,uuid"`
}

// UpdateProjectRequest is the request body for updating a project
type UpdateProjectRequest struct {
        Name               *string        `json:"name,omitempty" validate:"omitempty,min=1"`
        KBPurpose          *string        `json:"kb_purpose,omitempty"`
        ChatPromptTemplate *string        `json:"chat_prompt_template,omitempty"`
        AutoExtractObjects *bool          `json:"auto_extract_objects,omitempty"`
        AutoExtractConfig  map[string]any `json:"auto_extract_config,omitempty"`
}

// ToDTO converts a Project entity to ProjectDTO
func (p *Project) ToDTO() ProjectDTO <span class="cov8" title="1">{
        dto := ProjectDTO{
                ID:                 p.ID,
                Name:               p.Name,
                OrgID:              p.OrganizationID,
                KBPurpose:          p.KBPurpose,
                ChatPromptTemplate: p.ChatPromptTemplate,
        }

        // Only include boolean fields if they are true (to match NestJS behavior)
        if p.AutoExtractObjects </span><span class="cov8" title="1">{
                val := p.AutoExtractObjects
                dto.AutoExtractObjects = &amp;val
        }</span>

        // Include config fields if they exist
        <span class="cov8" title="1">if len(p.AutoExtractConfig) &gt; 0 </span><span class="cov8" title="1">{
                dto.AutoExtractConfig = p.AutoExtractConfig
        }</span>

        <span class="cov8" title="1">return dto</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package projects

import (
        "net/http"
        "strconv"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

// Handler handles HTTP requests for projects
type Handler struct {
        svc *Service
}

// NewHandler creates a new project handler
func NewHandler(svc *Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{svc: svc}
}</span>

// List returns all projects the authenticated user is a member of
// GET /api/v2/projects
// Query params: limit (1-500, default 100), orgId (optional UUID filter)
func (h *Handler) List(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        // Parse query parameters
        <span class="cov8" title="1">limit := DefaultLimit
        if limitStr := c.QueryParam("limit"); limitStr != "" </span><span class="cov8" title="1">{
                if parsed, err := strconv.Atoi(limitStr); err == nil </span><span class="cov8" title="1">{
                        limit = parsed
                }</span>
        }

        <span class="cov8" title="1">orgID := c.QueryParam("orgId")

        projects, err := h.svc.List(c.Request().Context(), ServiceListParams{
                UserID: user.ID,
                OrgID:  orgID,
                Limit:  limit,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, projects)</span>
}

// Get returns a single project by ID
// GET /api/v2/projects/:id
func (h *Handler) Get(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">id := c.Param("id")

        project, err := h.svc.GetByID(c.Request().Context(), id)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, project)</span>
}

// Create creates a new project
// POST /api/v2/projects
func (h *Handler) Create(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">var req CreateProjectRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        <span class="cov8" title="1">project, err := h.svc.Create(c.Request().Context(), req, user.ID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusCreated, project)</span>
}

// Update updates a project
// PATCH /api/v2/projects/:id
func (h *Handler) Update(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">id := c.Param("id")

        var req UpdateProjectRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        <span class="cov8" title="1">project, err := h.svc.Update(c.Request().Context(), id, req)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, project)</span>
}

// Delete deletes a project by ID
// DELETE /api/v2/projects/:id
func (h *Handler) Delete(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">id := c.Param("id")

        if err := h.svc.Delete(c.Request().Context(), id, user.ID); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, map[string]string{"status": "deleted"})</span>
}

// ListMembers returns all members of a project
// GET /api/v2/projects/:id/members
func (h *Handler) ListMembers(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID := c.Param("id")

        members, err := h.svc.ListMembers(c.Request().Context(), projectID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, members)</span>
}

// RemoveMember removes a member from a project
// DELETE /api/v2/projects/:id/members/:userId
func (h *Handler) RemoveMember(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">projectID := c.Param("id")
        userID := c.Param("userId")

        if err := h.svc.RemoveMember(c.Request().Context(), projectID, userID); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, map[string]string{"status": "removed"})</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">package projects

import (
        "context"
        "database/sql"
        "log/slog"
        "strings"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/internal/database"
        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Repository handles database operations for projects
type Repository struct {
        db  bun.IDB
        log *slog.Logger
}

// NewRepository creates a new project repository
func NewRepository(db bun.IDB, log *slog.Logger) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                db:  db,
                log: log.With(logger.Scope("projects.repo")),
        }
}</span>

// ListParams defines parameters for listing projects
type ListParams struct {
        UserID string
        OrgID  string // Optional filter by org
        Limit  int
}

// List returns all projects the user is a member of
func (r *Repository) List(ctx context.Context, params ListParams) ([]Project, error) <span class="cov8" title="1">{
        var projects []Project

        query := r.db.NewSelect().
                Model(&amp;projects).
                Join("INNER JOIN kb.project_memberships AS pm ON pm.project_id = p.id").
                Where("pm.user_id = ?", params.UserID).
                Order("p.created_at DESC")

        if params.OrgID != "" </span><span class="cov8" title="1">{
                query = query.Where("p.organization_id = ?", params.OrgID)
        }</span>

        <span class="cov8" title="1">if params.Limit &gt; 0 </span><span class="cov8" title="1">{
                query = query.Limit(params.Limit)
        }</span>

        <span class="cov8" title="1">err := query.Scan(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to list projects", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return projects, nil</span>
}

// GetByID returns a project by ID
func (r *Repository) GetByID(ctx context.Context, id string) (*Project, error) <span class="cov8" title="1">{
        var project Project

        err := r.db.NewSelect().
                Model(&amp;project).
                Where("id = ?", id).
                Scan(ctx)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil // Return nil, nil for not found (let service decide error)
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to get project", logger.Error(err), slog.String("id", id))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return &amp;project, nil</span>
}

// GetByIDWithLock returns a project by ID with a pessimistic lock (FOR UPDATE)
func (r *Repository) GetByIDWithLock(ctx context.Context, tx bun.Tx, id string) (*Project, error) <span class="cov0" title="0">{
        var project Project

        err := tx.NewSelect().
                Model(&amp;project).
                Where("id = ?", id).
                For("UPDATE").
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to get project with lock", logger.Error(err), slog.String("id", id))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov0" title="0">return &amp;project, nil</span>
}

// CheckOrgExistsWithLock checks if an org exists and locks the row
func (r *Repository) CheckOrgExistsWithLock(ctx context.Context, tx bun.Tx, orgID string) (bool, error) <span class="cov8" title="1">{
        exists, err := tx.NewSelect().
                TableExpr("kb.orgs").
                Where("id = ?", orgID).
                For("UPDATE").
                Exists(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to check org existence", logger.Error(err), slog.String("orgID", orgID))
                return false, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

// CheckDuplicateName checks if a project with the same name exists in the org
// If db is nil, uses the repository's default database connection
func (r *Repository) CheckDuplicateName(ctx context.Context, db bun.IDB, orgID, name string, excludeID string) (bool, error) <span class="cov8" title="1">{
        if db == nil </span><span class="cov8" title="1">{
                db = r.db
        }</span>
        <span class="cov8" title="1">query := db.NewSelect().
                Model((*Project)(nil)).
                Where("organization_id = ?", orgID).
                Where("LOWER(name) = LOWER(?)", strings.TrimSpace(name))

        if excludeID != "" </span><span class="cov8" title="1">{
                query = query.Where("id != ?", excludeID)
        }</span>

        <span class="cov8" title="1">exists, err := query.Exists(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to check duplicate name", logger.Error(err))
                return false, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return exists, nil</span>
}

// Create creates a new project in the database (within a transaction)
func (r *Repository) Create(ctx context.Context, tx bun.Tx, project *Project) error <span class="cov8" title="1">{
        _, err := tx.NewInsert().
                Model(project).
                Returning("id, organization_id, name, kb_purpose, chat_prompt_template, auto_extract_objects, auto_extract_config, created_at, updated_at").
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if isForeignKeyViolation(err) </span><span class="cov0" title="0">{
                        return apperror.New(400, "org-not-found", "Organization not found")
                }</span>
                <span class="cov0" title="0">if isUniqueViolation(err) </span><span class="cov0" title="0">{
                        return apperror.New(400, "duplicate", "Project with this name already exists in the organization")
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to create project", logger.Error(err))
                return apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CreateMembership creates a project membership
func (r *Repository) CreateMembership(ctx context.Context, tx bun.Tx, membership *ProjectMembership) error <span class="cov8" title="1">{
        _, err := tx.NewInsert().
                Model(membership).
                On("CONFLICT (project_id, user_id) DO NOTHING"). // Ignore duplicate memberships
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to create project membership", logger.Error(err))
                return apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Update updates a project in the database
func (r *Repository) Update(ctx context.Context, project *Project) error <span class="cov8" title="1">{
        _, err := r.db.NewUpdate().
                Model(project).
                WherePK().
                Returning("id, organization_id, name, kb_purpose, chat_prompt_template, auto_extract_objects, auto_extract_config, created_at, updated_at").
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if isUniqueViolation(err) </span><span class="cov0" title="0">{
                        return apperror.New(400, "duplicate", "Project with this name already exists in the organization")
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to update project", logger.Error(err), slog.String("id", project.ID))
                return apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Delete permanently deletes a project
// Note: Using hard delete since soft delete columns (deleted_at, deleted_by)
// are added in a later migration (1765826000000-AddSoftDeleteColumns)
func (r *Repository) Delete(ctx context.Context, id string) (bool, error) <span class="cov8" title="1">{
        result, err := r.db.NewDelete().
                Model((*Project)(nil)).
                Where("id = ?", id).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to delete project", logger.Error(err), slog.String("id", id))
                return false, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()
        return rowsAffected &gt; 0, nil</span>
}

// ListMembers returns all members of a project with their user profile info
func (r *Repository) ListMembers(ctx context.Context, projectID string) ([]ProjectMemberDTO, error) <span class="cov8" title="1">{
        var members []ProjectMemberDTO

        // Note: user_emails table doesn't have is_primary column in base schema
        // Using DISTINCT ON to get one email per user (prioritizing verified emails)
        err := r.db.NewSelect().
                TableExpr("kb.project_memberships AS pm").
                ColumnExpr("up.id").
                ColumnExpr("COALESCE(ue.email, '') AS email").
                ColumnExpr("up.display_name").
                ColumnExpr("up.first_name").
                ColumnExpr("up.last_name").
                ColumnExpr("up.avatar_object_key AS avatar_url").
                ColumnExpr("pm.role").
                ColumnExpr("pm.created_at AS joined_at").
                Join("INNER JOIN core.user_profiles AS up ON up.id = pm.user_id").
                Join(`LEFT JOIN LATERAL (
                        SELECT email FROM core.user_emails 
                        WHERE user_id = up.id 
                        ORDER BY verified DESC, created_at ASC 
                        LIMIT 1
                ) AS ue ON true`).
                Where("pm.project_id = ?", projectID).
                Order("pm.created_at ASC").
                Scan(ctx, &amp;members)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to list project members", logger.Error(err), slog.String("projectID", projectID))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return members, nil</span>
}

// CountAdmins counts the number of admins in a project
func (r *Repository) CountAdmins(ctx context.Context, projectID string) (int, error) <span class="cov8" title="1">{
        count, err := r.db.NewSelect().
                Model((*ProjectMembership)(nil)).
                Where("project_id = ?", projectID).
                Where("role = ?", RoleProjectAdmin).
                Count(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to count project admins", logger.Error(err), slog.String("projectID", projectID))
                return 0, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return count, nil</span>
}

// RemoveMember removes a member from a project
func (r *Repository) RemoveMember(ctx context.Context, projectID, userID string) (bool, error) <span class="cov8" title="1">{
        result, err := r.db.NewDelete().
                Model((*ProjectMembership)(nil)).
                Where("project_id = ?", projectID).
                Where("user_id = ?", userID).
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to remove project member", logger.Error(err),
                        slog.String("projectID", projectID),
                        slog.String("userID", userID))
                return false, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()
        return rowsAffected &gt; 0, nil</span>
}

// GetMembership returns a user's membership in a project
func (r *Repository) GetMembership(ctx context.Context, projectID, userID string) (*ProjectMembership, error) <span class="cov8" title="1">{
        var membership ProjectMembership

        err := r.db.NewSelect().
                Model(&amp;membership).
                Where("project_id = ?", projectID).
                Where("user_id = ?", userID).
                Scan(ctx)

        if err != nil </span><span class="cov8" title="1">{
                if err == sql.ErrNoRows </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to get project membership", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return &amp;membership, nil</span>
}

// IsUserMember checks if a user is a member of a project
func (r *Repository) IsUserMember(ctx context.Context, projectID, userID string) (bool, error) <span class="cov0" title="0">{
        exists, err := r.db.NewSelect().
                Model((*ProjectMembership)(nil)).
                Where("project_id = ?", projectID).
                Where("user_id = ?", userID).
                Exists(ctx)

        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to check project membership", logger.Error(err),
                        slog.String("projectID", projectID),
                        slog.String("userID", userID))
                return false, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov0" title="0">return exists, nil</span>
}

// BeginTx starts a new transaction.
// Returns a SafeTx that's safe to call Rollback after Commit (important for savepoints).
func (r *Repository) BeginTx(ctx context.Context) (*database.SafeTx, error) <span class="cov8" title="1">{
        tx, err := database.BeginSafeTx(ctx, r.db)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to begin transaction", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">return tx, nil</span>
}

// Helper functions to check PostgreSQL error codes
func isUniqueViolation(err error) bool <span class="cov8" title="1">{
        return containsErrorCode(err, "23505")
}</span>

func isForeignKeyViolation(err error) bool <span class="cov8" title="1">{
        return containsErrorCode(err, "23503")
}</span>

func containsErrorCode(err error, code string) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">errStr := err.Error()
        return len(errStr) &gt; 0 &amp;&amp; (strings.Contains(errStr, code) || strings.Contains(errStr, "SQLSTATE "+code))</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package projects

import (
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/auth"
)

// RegisterRoutes registers project routes
func RegisterRoutes(e *echo.Echo, h *Handler, authMiddleware *auth.Middleware) <span class="cov8" title="1">{
        // All project endpoints require authentication
        g := e.Group("/api/v2/projects")
        g.Use(authMiddleware.RequireAuth())

        // List projects (user must be authenticated)
        // Scope: project:read
        g.GET("", h.List)

        // Get project by ID
        // Scope: project:read
        g.GET("/:id", h.Get)

        // Create project
        // Scope: org:project:create
        g.POST("", h.Create)

        // Update project
        // Scope: project:write
        g.PATCH("/:id", h.Update)

        // Delete project
        // Scope: org:project:delete
        g.DELETE("/:id", h.Delete)

        // List project members
        // Scope: project:read
        g.GET("/:id/members", h.ListMembers)

        // Remove project member
        // Scope: project:admin
        g.DELETE("/:id/members/:userId", h.RemoveMember)
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package projects

import (
        "context"
        "log/slog"
        "regexp"
        "strings"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

const (
        // DefaultLimit is the default number of projects to return
        DefaultLimit = 100
        // MaxLimit is the maximum number of projects to return
        MaxLimit = 500
)

var (
        // uuidRegex validates UUID format (36 chars with hyphens)
        uuidRegex = regexp.MustCompile(`^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$`)
)

// Service handles business logic for projects
type Service struct {
        repo *Repository
        log  *slog.Logger
}

// NewService creates a new project service
func NewService(repo *Repository, log *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: repo,
                log:  log.With(logger.Scope("projects.svc")),
        }
}</span>

// ListParams defines parameters for listing projects
type ServiceListParams struct {
        UserID string
        OrgID  string
        Limit  int
}

// List returns all projects the user is a member of
func (s *Service) List(ctx context.Context, params ServiceListParams) ([]ProjectDTO, error) <span class="cov8" title="1">{
        if params.UserID == "" </span><span class="cov0" title="0">{
                return []ProjectDTO{}, nil
        }</span>

        // Validate and apply limits
        <span class="cov8" title="1">limit := params.Limit
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = DefaultLimit
        }</span>
        <span class="cov8" title="1">if limit &gt; MaxLimit </span><span class="cov0" title="0">{
                limit = MaxLimit
        }</span>

        // Validate orgID if provided - if invalid, return empty list (not an error)
        <span class="cov8" title="1">if params.OrgID != "" &amp;&amp; !isValidUUID(params.OrgID) </span><span class="cov8" title="1">{
                return []ProjectDTO{}, nil
        }</span>

        <span class="cov8" title="1">projects, err := s.repo.List(ctx, ListParams{
                UserID: params.UserID,
                OrgID:  params.OrgID,
                Limit:  limit,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result := make([]ProjectDTO, len(projects))
        for i, p := range projects </span><span class="cov8" title="1">{
                result[i] = p.ToDTO()
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}

// GetByID returns a project by ID
func (s *Service) GetByID(ctx context.Context, id string) (*ProjectDTO, error) <span class="cov8" title="1">{
        if !isValidUUID(id) </span><span class="cov8" title="1">{
                return nil, apperror.New(400, "invalid-uuid", "id must be a valid UUID")
        }</span>

        <span class="cov8" title="1">project, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if project == nil </span><span class="cov8" title="1">{
                return nil, apperror.ErrNotFound.WithMessage("Project not found")
        }</span>

        <span class="cov8" title="1">dto := project.ToDTO()
        return &amp;dto, nil</span>
}

// Create creates a new project
func (s *Service) Create(ctx context.Context, req CreateProjectRequest, userID string) (*ProjectDTO, error) <span class="cov8" title="1">{
        // Validate name
        name := strings.TrimSpace(req.Name)
        if name == "" </span><span class="cov8" title="1">{
                return nil, apperror.New(400, "validation-failed", "Name required").WithDetails(map[string]any{
                        "name": []string{"must not be blank"},
                })
        }</span>

        // Validate orgId is provided
        <span class="cov8" title="1">if req.OrgID == "" </span><span class="cov8" title="1">{
                return nil, apperror.New(400, "org-required", "Organization id (orgId) is required to create a project")
        }</span>

        // Validate orgId format
        <span class="cov8" title="1">if !isValidUUID(req.OrgID) </span><span class="cov0" title="0">{
                return nil, apperror.New(400, "invalid-uuid", "orgId must be a valid UUID")
        }</span>

        // Start transaction
        <span class="cov8" title="1">tx, err := s.repo.BeginTx(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer tx.Rollback()

        // Check org exists with pessimistic lock
        orgExists, err := s.repo.CheckOrgExistsWithLock(ctx, tx.Tx, req.OrgID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if !orgExists </span><span class="cov8" title="1">{
                return nil, apperror.New(400, "org-not-found", "Organization not found")
        }</span>

        // Check for duplicate name in org
        <span class="cov8" title="1">isDuplicate, err := s.repo.CheckDuplicateName(ctx, tx.Tx, req.OrgID, name, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if isDuplicate </span><span class="cov8" title="1">{
                return nil, apperror.New(400, "duplicate", "Project with this name exists in org")
        }</span>

        // Create the project
        <span class="cov8" title="1">project := &amp;Project{
                OrganizationID: req.OrgID,
                Name:           name,
        }
        if err := s.repo.Create(ctx, tx.Tx, project); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create membership for the creator as project_admin
        <span class="cov8" title="1">if userID != "" </span><span class="cov8" title="1">{
                membership := &amp;ProjectMembership{
                        ProjectID: project.ID,
                        UserID:    userID,
                        Role:      RoleProjectAdmin,
                }
                if err := s.repo.CreateMembership(ctx, tx.Tx, membership); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Commit transaction
        <span class="cov8" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to commit transaction", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">s.log.Info("project created",
                slog.String("projectID", project.ID),
                slog.String("name", project.Name),
                slog.String("orgID", project.OrganizationID),
                slog.String("userID", userID))

        dto := project.ToDTO()
        return &amp;dto, nil</span>
}

// Update updates a project
func (s *Service) Update(ctx context.Context, id string, req UpdateProjectRequest) (*ProjectDTO, error) <span class="cov8" title="1">{
        if !isValidUUID(id) </span><span class="cov8" title="1">{
                return nil, apperror.New(400, "invalid-uuid", "id must be a valid UUID")
        }</span>

        // Get existing project
        <span class="cov8" title="1">project, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if project == nil </span><span class="cov8" title="1">{
                return nil, apperror.ErrNotFound.WithMessage("Project not found")
        }</span>

        // Check if there are any updates to apply
        <span class="cov8" title="1">hasUpdates := false

        if req.Name != nil </span><span class="cov8" title="1">{
                name := strings.TrimSpace(*req.Name)
                if name == "" </span><span class="cov0" title="0">{
                        return nil, apperror.New(400, "validation-failed", "Name cannot be empty").WithDetails(map[string]any{
                                "name": []string{"must not be blank"},
                        })
                }</span>
                <span class="cov8" title="1">if name != project.Name </span><span class="cov8" title="1">{
                        // Check for duplicate name in org
                        isDuplicate, err := s.repo.CheckDuplicateName(ctx, nil, project.OrganizationID, name, id)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if isDuplicate </span><span class="cov0" title="0">{
                                return nil, apperror.New(400, "duplicate", "Project with this name already exists in the organization")
                        }</span>
                        <span class="cov8" title="1">project.Name = name
                        hasUpdates = true</span>
                }
        }

        <span class="cov8" title="1">if req.KBPurpose != nil </span><span class="cov8" title="1">{
                project.KBPurpose = req.KBPurpose
                hasUpdates = true
        }</span>

        <span class="cov8" title="1">if req.ChatPromptTemplate != nil </span><span class="cov0" title="0">{
                project.ChatPromptTemplate = req.ChatPromptTemplate
                hasUpdates = true
        }</span>

        <span class="cov8" title="1">if req.AutoExtractObjects != nil </span><span class="cov0" title="0">{
                project.AutoExtractObjects = *req.AutoExtractObjects
                hasUpdates = true
        }</span>

        <span class="cov8" title="1">if req.AutoExtractConfig != nil </span><span class="cov0" title="0">{
                project.AutoExtractConfig = req.AutoExtractConfig
                hasUpdates = true
        }</span>

        // If no updates, return current project
        <span class="cov8" title="1">if !hasUpdates </span><span class="cov8" title="1">{
                dto := project.ToDTO()
                return &amp;dto, nil
        }</span>

        // Update the project
        <span class="cov8" title="1">if err := s.repo.Update(ctx, project); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s.log.Info("project updated",
                slog.String("projectID", project.ID),
                slog.String("name", project.Name))

        dto := project.ToDTO()
        return &amp;dto, nil</span>
}

// Delete deletes a project
func (s *Service) Delete(ctx context.Context, id string, userID string) error <span class="cov8" title="1">{
        if !isValidUUID(id) </span><span class="cov8" title="1">{
                return apperror.New(400, "invalid-uuid", "id must be a valid UUID")
        }</span>

        <span class="cov8" title="1">deleted, err := s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !deleted </span><span class="cov8" title="1">{
                return apperror.ErrNotFound.WithMessage("Project not found")
        }</span>

        <span class="cov8" title="1">s.log.Info("project deleted",
                slog.String("projectID", id),
                slog.String("deletedBy", userID))

        return nil</span>
}

// ListMembers returns all members of a project
func (s *Service) ListMembers(ctx context.Context, projectID string) ([]ProjectMemberDTO, error) <span class="cov8" title="1">{
        if !isValidUUID(projectID) </span><span class="cov0" title="0">{
                return nil, apperror.New(400, "invalid-uuid", "projectId must be a valid UUID")
        }</span>

        // Check project exists
        <span class="cov8" title="1">project, err := s.repo.GetByID(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if project == nil </span><span class="cov8" title="1">{
                return nil, apperror.ErrNotFound.WithMessage("Project not found")
        }</span>

        <span class="cov8" title="1">return s.repo.ListMembers(ctx, projectID)</span>
}

// RemoveMember removes a member from a project
func (s *Service) RemoveMember(ctx context.Context, projectID, userID string) error <span class="cov8" title="1">{
        if !isValidUUID(projectID) </span><span class="cov0" title="0">{
                return apperror.New(400, "invalid-uuid", "projectId must be a valid UUID")
        }</span>
        <span class="cov8" title="1">if !isValidUUID(userID) </span><span class="cov0" title="0">{
                return apperror.New(400, "invalid-uuid", "userId must be a valid UUID")
        }</span>

        // Check project exists
        <span class="cov8" title="1">project, err := s.repo.GetByID(ctx, projectID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if project == nil </span><span class="cov8" title="1">{
                return apperror.ErrNotFound.WithMessage("Project not found")
        }</span>

        // Get the membership to check role
        <span class="cov8" title="1">membership, err := s.repo.GetMembership(ctx, projectID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if membership == nil </span><span class="cov8" title="1">{
                return apperror.ErrNotFound.WithMessage("Member not found")
        }</span>

        // If removing an admin, check if they're the last admin
        <span class="cov8" title="1">if membership.Role == RoleProjectAdmin </span><span class="cov8" title="1">{
                adminCount, err := s.repo.CountAdmins(ctx, projectID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if adminCount &lt;= 1 </span><span class="cov8" title="1">{
                        return apperror.New(403, "last-admin", "Cannot remove the last admin from the project. Assign another admin first.")
                }</span>
        }

        // Remove the member
        <span class="cov8" title="1">removed, err := s.repo.RemoveMember(ctx, projectID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !removed </span><span class="cov0" title="0">{
                return apperror.ErrNotFound.WithMessage("Member not found")
        }</span>

        <span class="cov8" title="1">s.log.Info("project member removed",
                slog.String("projectID", projectID),
                slog.String("userID", userID))

        return nil</span>
}

// IsUserMember checks if a user is a member of a project
func (s *Service) IsUserMember(ctx context.Context, projectID, userID string) (bool, error) <span class="cov0" title="0">{
        return s.repo.IsUserMember(ctx, projectID, userID)
}</span>

// Helper to validate UUID format
func isValidUUID(id string) bool <span class="cov8" title="1">{
        return uuidRegex.MatchString(id)
}</span>
</pre>
		
		<pre class="file" id="file82" style="display: none">package scheduler

import (
        "os"
        "strconv"
        "time"
)

// Config holds scheduler configuration
type Config struct {
        // Enabled controls whether the scheduler runs
        Enabled bool

        // RevisionCountRefreshInterval is the interval for refreshing revision counts
        RevisionCountRefreshInterval time.Duration

        // TagCleanupInterval is the interval for cleaning up unused tags
        TagCleanupInterval time.Duration

        // CacheCleanupInterval is the interval for cleaning up expired cache entries
        CacheCleanupInterval time.Duration

        // StaleJobCleanupInterval is the interval for cleaning up stale jobs
        StaleJobCleanupInterval time.Duration

        // StaleJobMinutes is how long a job can be running before it's considered stale
        StaleJobMinutes int
}

// NewConfig creates a new Config from environment variables
func NewConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Enabled:                      getEnvBool("SCHEDULER_ENABLED", true),
                RevisionCountRefreshInterval: getEnvDuration("REVISION_COUNT_REFRESH_INTERVAL_MS", 5*time.Minute),
                TagCleanupInterval:           getEnvDuration("TAG_CLEANUP_INTERVAL_MS", 5*time.Minute),
                CacheCleanupInterval:         getEnvDuration("CACHE_CLEANUP_INTERVAL", 15*time.Minute),
                StaleJobCleanupInterval:      getEnvDuration("STALE_JOB_CLEANUP_INTERVAL_MS", 10*time.Minute),
                StaleJobMinutes:              getEnvInt("STALE_JOB_MINUTES", 30),
        }
}</span>

// getEnvBool returns a boolean from an environment variable
func getEnvBool(key string, defaultVal bool) bool <span class="cov8" title="1">{
        if val := os.Getenv(key); val != "" </span><span class="cov8" title="1">{
                if b, err := strconv.ParseBool(val); err == nil </span><span class="cov8" title="1">{
                        return b
                }</span>
        }
        <span class="cov8" title="1">return defaultVal</span>
}

// getEnvInt returns an integer from an environment variable
func getEnvInt(key string, defaultVal int) int <span class="cov8" title="1">{
        if val := os.Getenv(key); val != "" </span><span class="cov8" title="1">{
                if i, err := strconv.Atoi(val); err == nil </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return defaultVal</span>
}

// getEnvDuration returns a duration from an environment variable (in milliseconds)
func getEnvDuration(key string, defaultVal time.Duration) time.Duration <span class="cov8" title="1">{
        if val := os.Getenv(key); val != "" </span><span class="cov8" title="1">{
                if ms, err := strconv.Atoi(val); err == nil </span><span class="cov8" title="1">{
                        return time.Duration(ms) * time.Millisecond
                }</span>
        }
        <span class="cov8" title="1">return defaultVal</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">package scheduler

import (
        "context"
        "log/slog"

        "github.com/uptrace/bun"
        "go.uber.org/fx"
)

// Module provides scheduled task functionality
var Module = fx.Module("scheduler",
        fx.Provide(
                NewConfig,
                NewScheduler,
        ),
        fx.Invoke(
                RegisterTasks,
                RegisterSchedulerLifecycle,
        ),
)

// TaskParams contains dependencies for creating scheduled tasks
type TaskParams struct {
        fx.In
        Scheduler *Scheduler
        DB        *bun.DB
        Log       *slog.Logger
        Cfg       *Config
}

// RegisterTasks registers all scheduled tasks
func RegisterTasks(p TaskParams) error <span class="cov0" title="0">{
        if !p.Cfg.Enabled </span><span class="cov0" title="0">{
                p.Log.Info("scheduler disabled, skipping task registration")
                return nil
        }</span>

        // Register revision count refresh task
        <span class="cov0" title="0">revisionTask := NewRevisionCountRefreshTask(p.DB, p.Log)
        if err := p.Scheduler.AddIntervalTask("revision_count_refresh",
                p.Cfg.RevisionCountRefreshInterval, revisionTask.Run); err != nil </span><span class="cov0" title="0">{
                p.Log.Error("failed to register revision count refresh task",
                        slog.String("error", err.Error()))
        }</span>

        // Register tag cleanup task
        <span class="cov0" title="0">tagCleanupTask := NewTagCleanupTask(p.DB, p.Log)
        if err := p.Scheduler.AddIntervalTask("tag_cleanup",
                p.Cfg.TagCleanupInterval, tagCleanupTask.Run); err != nil </span><span class="cov0" title="0">{
                p.Log.Error("failed to register tag cleanup task",
                        slog.String("error", err.Error()))
        }</span>

        // Register cache cleanup task
        <span class="cov0" title="0">cacheCleanupTask := NewCacheCleanupTask(p.DB, p.Log)
        if err := p.Scheduler.AddIntervalTask("cache_cleanup",
                p.Cfg.CacheCleanupInterval, cacheCleanupTask.Run); err != nil </span><span class="cov0" title="0">{
                p.Log.Error("failed to register cache cleanup task",
                        slog.String("error", err.Error()))
        }</span>

        // Register stale job cleanup task
        <span class="cov0" title="0">staleJobTask := NewStaleJobCleanupTask(p.DB, p.Log, p.Cfg.StaleJobMinutes)
        if err := p.Scheduler.AddIntervalTask("stale_job_cleanup",
                p.Cfg.StaleJobCleanupInterval, staleJobTask.Run); err != nil </span><span class="cov0" title="0">{
                p.Log.Error("failed to register stale job cleanup task",
                        slog.String("error", err.Error()))
        }</span>

        <span class="cov0" title="0">p.Log.Info("registered scheduled tasks",
                slog.Any("tasks", p.Scheduler.ListTasks()))

        return nil</span>
}

// RegisterSchedulerLifecycle registers the scheduler with fx lifecycle
func RegisterSchedulerLifecycle(lc fx.Lifecycle, scheduler *Scheduler, cfg *Config) <span class="cov0" title="0">{
        if !cfg.Enabled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">lc.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        return scheduler.Start(ctx)
                }</span>,
                OnStop: func(ctx context.Context) error <span class="cov0" title="0">{
                        return scheduler.Stop(ctx)
                }</span>,
        })
}
</pre>
		
		<pre class="file" id="file84" style="display: none">package scheduler

import (
        "context"
        "log/slog"
        "sync"
        "time"

        "github.com/robfig/cron/v3"

        "github.com/emergent/emergent-core/pkg/logger"
)

// Scheduler manages scheduled tasks using robfig/cron.
// It supports both cron expressions and interval-based scheduling.
type Scheduler struct {
        cron    *cron.Cron
        log     *slog.Logger
        tasks   map[string]cron.EntryID
        mu      sync.RWMutex
        running bool
}

// NewScheduler creates a new scheduler
func NewScheduler(log *slog.Logger) *Scheduler <span class="cov8" title="1">{
        // Create cron with seconds precision
        c := cron.New(cron.WithSeconds())
        
        return &amp;Scheduler{
                cron:  c,
                log:   log.With(logger.Scope("scheduler")),
                tasks: make(map[string]cron.EntryID),
        }
}</span>

// Start begins the scheduler
func (s *Scheduler) Start(ctx context.Context) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.running </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">s.cron.Start()
        s.running = true
        s.log.Info("scheduler started", slog.Int("tasks", len(s.tasks)))

        return nil</span>
}

// Stop gracefully stops the scheduler
func (s *Scheduler) Stop(ctx context.Context) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if !s.running </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Stop with context timeout
        <span class="cov8" title="1">stopCtx := s.cron.Stop()
        select </span>{
        case &lt;-stopCtx.Done():<span class="cov8" title="1">
                s.log.Info("scheduler stopped gracefully")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                s.log.Warn("scheduler stop timeout")</span>
        }

        <span class="cov8" title="1">s.running = false
        return nil</span>
}

// AddCronTask adds a task with a cron expression
// Cron format: "second minute hour day-of-month month day-of-week"
func (s *Scheduler) AddCronTask(name string, schedule string, task TaskFunc) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Remove existing task if any
        if entryID, ok := s.tasks[name]; ok </span><span class="cov8" title="1">{
                s.cron.Remove(entryID)
                delete(s.tasks, name)
        }</span>

        <span class="cov8" title="1">entryID, err := s.cron.AddFunc(schedule, func() </span><span class="cov0" title="0">{
                s.runTask(name, task)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">s.tasks[name] = entryID
        s.log.Info("added cron task",
                slog.String("name", name),
                slog.String("schedule", schedule))

        return nil</span>
}

// AddIntervalTask adds a task that runs at a fixed interval
func (s *Scheduler) AddIntervalTask(name string, interval time.Duration, task TaskFunc) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        // Remove existing task if any
        if entryID, ok := s.tasks[name]; ok </span><span class="cov8" title="1">{
                s.cron.Remove(entryID)
                delete(s.tasks, name)
        }</span>

        // Convert interval to cron schedule
        // Use @every directive for simple intervals
        <span class="cov8" title="1">schedule := "@every " + interval.String()

        entryID, err := s.cron.AddFunc(schedule, func() </span><span class="cov8" title="1">{
                s.runTask(name, task)
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">s.tasks[name] = entryID
        s.log.Info("added interval task",
                slog.String("name", name),
                slog.Duration("interval", interval))

        return nil</span>
}

// RemoveTask removes a scheduled task
func (s *Scheduler) RemoveTask(name string) <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if entryID, ok := s.tasks[name]; ok </span><span class="cov8" title="1">{
                s.cron.Remove(entryID)
                delete(s.tasks, name)
                s.log.Info("removed task", slog.String("name", name))
        }</span>
}

// runTask executes a task with error handling
func (s *Scheduler) runTask(name string, task TaskFunc) <span class="cov8" title="1">{
        startTime := time.Now()
        s.log.Debug("running scheduled task", slog.String("name", name))

        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Minute)
        defer cancel()

        if err := task(ctx); err != nil </span><span class="cov0" title="0">{
                s.log.Error("scheduled task failed",
                        slog.String("name", name),
                        slog.String("error", err.Error()),
                        slog.Duration("duration", time.Since(startTime)))
                return
        }</span>

        <span class="cov8" title="1">s.log.Debug("scheduled task completed",
                slog.String("name", name),
                slog.Duration("duration", time.Since(startTime)))</span>
}

// ListTasks returns the names of all scheduled tasks
func (s *Scheduler) ListTasks() []string <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        names := make([]string, 0, len(s.tasks))
        for name := range s.tasks </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">return names</span>
}

// TaskInfo represents information about a scheduled task
type TaskInfo struct {
        Name     string    `json:"name"`
        NextRun  time.Time `json:"next_run"`
        PrevRun  time.Time `json:"prev_run,omitempty"`
        Schedule string    `json:"schedule"`
}

// GetTaskInfo returns information about all scheduled tasks
func (s *Scheduler) GetTaskInfo() []TaskInfo <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()

        var info []TaskInfo
        entries := s.cron.Entries()

        for name, entryID := range s.tasks </span><span class="cov8" title="1">{
                for _, entry := range entries </span><span class="cov8" title="1">{
                        if entry.ID == entryID </span><span class="cov8" title="1">{
                                info = append(info, TaskInfo{
                                        Name:     name,
                                        NextRun:  entry.Next,
                                        PrevRun:  entry.Prev,
                                        Schedule: entry.Schedule.Next(time.Now()).String(),
                                })
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return info</span>
}

// IsRunning returns whether the scheduler is running
func (s *Scheduler) IsRunning() bool <span class="cov8" title="1">{
        s.mu.RLock()
        defer s.mu.RUnlock()
        return s.running
}</span>

// TaskFunc is the function signature for scheduled tasks
type TaskFunc func(ctx context.Context) error
</pre>
		
		<pre class="file" id="file85" style="display: none">package scheduler

import (
        "context"
        "database/sql"
        "log/slog"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/logger"
)

// RevisionCountRefreshTask refreshes the materialized view for revision counts
type RevisionCountRefreshTask struct {
        db  *bun.DB
        log *slog.Logger
}

// NewRevisionCountRefreshTask creates a new revision count refresh task
func NewRevisionCountRefreshTask(db *bun.DB, log *slog.Logger) *RevisionCountRefreshTask <span class="cov0" title="0">{
        return &amp;RevisionCountRefreshTask{
                db:  db,
                log: log.With(logger.Scope("scheduler.revision_count")),
        }
}</span>

// Run executes the revision count refresh
func (t *RevisionCountRefreshTask) Run(ctx context.Context) error <span class="cov0" title="0">{
        start := time.Now()
        t.log.Debug("refreshing revision counts")

        // Call the PostgreSQL function to refresh counts
        _, err := t.db.ExecContext(ctx, "SELECT kb.refresh_revision_counts()")
        if err != nil </span><span class="cov0" title="0">{
                t.log.Error("failed to refresh revision counts",
                        slog.String("error", err.Error()))
                return err
        }</span>

        <span class="cov0" title="0">t.log.Debug("revision counts refreshed",
                slog.Duration("duration", time.Since(start)))
        return nil</span>
}

// TagCleanupTask removes unused tags from the database
type TagCleanupTask struct {
        db  *bun.DB
        log *slog.Logger
}

// NewTagCleanupTask creates a new tag cleanup task
func NewTagCleanupTask(db *bun.DB, log *slog.Logger) *TagCleanupTask <span class="cov8" title="1">{
        return &amp;TagCleanupTask{
                db:  db,
                log: log.With(logger.Scope("scheduler.tag_cleanup")),
        }
}</span>

// Run executes the tag cleanup
func (t *TagCleanupTask) Run(ctx context.Context) error <span class="cov8" title="1">{
        start := time.Now()
        t.log.Debug("cleaning up unused tags")

        // Delete tags that are not referenced by any graph objects
        result, err := t.db.ExecContext(ctx, `
                DELETE FROM kb.tags t
                WHERE NOT EXISTS (
                        SELECT 1 FROM kb.graph_objects go
                        WHERE go.properties-&gt;'tags' @&gt; to_jsonb(t.name)
                )
        `)
        if err != nil </span><span class="cov0" title="0">{
                t.log.Error("failed to clean up tags",
                        slog.String("error", err.Error()))
                return err
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected &gt; 0 </span><span class="cov8" title="1">{
                t.log.Info("cleaned up unused tags",
                        slog.Int64("count", rowsAffected),
                        slog.Duration("duration", time.Since(start)))
        }</span> else<span class="cov8" title="1"> {
                t.log.Debug("no unused tags to clean up",
                        slog.Duration("duration", time.Since(start)))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CacheCleanupTask removes expired cache entries
type CacheCleanupTask struct {
        db  *bun.DB
        log *slog.Logger
}

// NewCacheCleanupTask creates a new cache cleanup task
func NewCacheCleanupTask(db *bun.DB, log *slog.Logger) *CacheCleanupTask <span class="cov8" title="1">{
        return &amp;CacheCleanupTask{
                db:  db,
                log: log.With(logger.Scope("scheduler.cache_cleanup")),
        }
}</span>

// Run executes the cache cleanup
func (t *CacheCleanupTask) Run(ctx context.Context) error <span class="cov8" title="1">{
        start := time.Now()
        t.log.Debug("cleaning up expired cache entries")

        // Delete expired introspection cache entries
        result, err := t.db.ExecContext(ctx, `
                DELETE FROM kb.auth_introspection_cache
                WHERE expires_at &lt; NOW()
        `)
        if err != nil </span><span class="cov0" title="0">{
                t.log.Error("failed to clean up cache",
                        slog.String("error", err.Error()))
                return err
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected &gt; 0 </span><span class="cov8" title="1">{
                t.log.Info("cleaned up expired cache entries",
                        slog.Int64("count", rowsAffected),
                        slog.Duration("duration", time.Since(start)))
        }</span> else<span class="cov0" title="0"> {
                t.log.Debug("no expired cache entries to clean up",
                        slog.Duration("duration", time.Since(start)))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// StaleJobCleanupTask marks stale jobs as failed across all job queues
type StaleJobCleanupTask struct {
        db           *bun.DB
        log          *slog.Logger
        staleMinutes int
}

// NewStaleJobCleanupTask creates a new stale job cleanup task
func NewStaleJobCleanupTask(db *bun.DB, log *slog.Logger, staleMinutes int) *StaleJobCleanupTask <span class="cov8" title="1">{
        if staleMinutes &lt;= 0 </span><span class="cov8" title="1">{
                staleMinutes = 30
        }</span>
        <span class="cov8" title="1">return &amp;StaleJobCleanupTask{
                db:           db,
                log:          log.With(logger.Scope("scheduler.stale_job_cleanup")),
                staleMinutes: staleMinutes,
        }</span>
}

// jobTableConfig holds the configuration for cleaning up a specific job table
type jobTableConfig struct {
        table         string
        hasStartedAt  bool
        hasCompletedAt bool
        errorColumn   string
}

// Run executes the stale job cleanup
func (t *StaleJobCleanupTask) Run(ctx context.Context) error <span class="cov8" title="1">{
        start := time.Now()
        t.log.Debug("cleaning up stale jobs")

        cutoff := time.Now().Add(-time.Duration(t.staleMinutes) * time.Minute)
        totalCleaned := int64(0)

        // Clean up stale extraction jobs (multiple tables with different schemas)
        tables := []jobTableConfig{
                {table: "kb.document_parsing_jobs", hasStartedAt: true, hasCompletedAt: true, errorColumn: "error_message"},
                {table: "kb.chunk_embedding_jobs", hasStartedAt: true, hasCompletedAt: true, errorColumn: "last_error"},
                {table: "kb.graph_embedding_jobs", hasStartedAt: true, hasCompletedAt: true, errorColumn: "last_error"},
                {table: "kb.object_extraction_jobs", hasStartedAt: true, hasCompletedAt: true, errorColumn: "error_message"},
                {table: "kb.data_source_sync_jobs", hasStartedAt: true, hasCompletedAt: true, errorColumn: "error_message"},
                {table: "kb.email_jobs", hasStartedAt: false, hasCompletedAt: false, errorColumn: "last_error"},
        }

        for _, cfg := range tables </span><span class="cov8" title="1">{
                count, err := t.cleanupTable(ctx, cfg, cutoff)
                if err != nil </span><span class="cov0" title="0">{
                        t.log.Warn("failed to clean up stale jobs in table",
                                slog.String("table", cfg.table),
                                slog.String("error", err.Error()))
                        continue</span>
                }
                <span class="cov8" title="1">if count &gt; 0 </span><span class="cov8" title="1">{
                        t.log.Info("cleaned up stale jobs",
                                slog.String("table", cfg.table),
                                slog.Int64("count", count))
                        totalCleaned += count
                }</span>
        }

        <span class="cov8" title="1">t.log.Debug("stale job cleanup completed",
                slog.Int64("total_cleaned", totalCleaned),
                slog.Duration("duration", time.Since(start)))

        return nil</span>
}

// cleanupTable cleans up stale jobs in a specific table
func (t *StaleJobCleanupTask) cleanupTable(ctx context.Context, cfg jobTableConfig, cutoff time.Time) (int64, error) <span class="cov8" title="1">{
        var query string
        
        if cfg.hasStartedAt &amp;&amp; cfg.hasCompletedAt </span><span class="cov8" title="1">{
                // Tables with started_at and completed_at columns
                query = `
                        UPDATE ` + cfg.table + `
                        SET status = 'failed',
                                ` + cfg.errorColumn + ` = 'Job marked as stale during cleanup',
                                completed_at = NOW(),
                                updated_at = NOW()
                        WHERE status IN ('pending', 'processing', 'running')
                        AND (started_at &lt; ? OR (started_at IS NULL AND created_at &lt; ?))
                `
        }</span> else<span class="cov8" title="1"> {
                // Tables without started_at (like email_jobs) - use created_at only
                query = `
                        UPDATE ` + cfg.table + `
                        SET status = 'failed',
                                ` + cfg.errorColumn + ` = 'Job marked as stale during cleanup'
                        WHERE status IN ('pending', 'processing', 'running')
                        AND created_at &lt; ?
                `
        }</span>
        
        <span class="cov8" title="1">var result sql.Result
        var err error
        
        if cfg.hasStartedAt </span><span class="cov8" title="1">{
                result, err = t.db.ExecContext(ctx, query, cutoff, cutoff)
        }</span> else<span class="cov8" title="1"> {
                result, err = t.db.ExecContext(ctx, query, cutoff)
        }</span>
        
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        
        <span class="cov8" title="1">return result.RowsAffected()</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">package search

import (
        "net/http"

        "github.com/google/uuid"
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

// Handler handles HTTP requests for unified search
type Handler struct {
        svc *Service
}

// NewHandler creates a new search handler
func NewHandler(svc *Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{svc: svc}
}</span>

// Search handles POST /search/unified
// @Summary Unified search
// @Description Search across graph objects and document chunks with configurable fusion strategies
// @Tags search
// @Accept json
// @Produce json
// @Param body body UnifiedSearchRequest true "Search request"
// @Success 200 {object} UnifiedSearchResponse
// @Failure 400 {object} apperror.Error
// @Failure 401 {object} apperror.Error
// @Failure 403 {object} apperror.Error
// @Router /search/unified [post]
func (h *Handler) Search(c echo.Context) error <span class="cov8" title="1">{
        // Get authenticated user
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        // Get project ID
        <span class="cov8" title="1">projectIDStr, err := auth.GetProjectID(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">projectID, err := uuid.Parse(projectIDStr)
        if err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid project ID")
        }</span>

        // Get org ID from user context
        <span class="cov8" title="1">var orgID uuid.UUID
        if user.OrgID != "" </span><span class="cov0" title="0">{
                orgID, err = uuid.Parse(user.OrgID)
                if err != nil </span><span class="cov0" title="0">{
                        return apperror.ErrBadRequest.WithMessage("invalid org ID")
                }</span>
        }

        // Parse request body
        <span class="cov8" title="1">var req UnifiedSearchRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov0" title="0">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        // Validate request
        <span class="cov8" title="1">if req.Query == "" </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("query is required")
        }</span>
        <span class="cov8" title="1">if len(req.Query) &gt; 800 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("query must be 800 characters or less")
        }</span>

        // Get user scopes
        <span class="cov8" title="1">scopes := user.Scopes
        if scopes == nil </span><span class="cov0" title="0">{
                scopes = []string{}
        }</span>

        // Check debug scope if debug mode requested
        <span class="cov8" title="1">if req.IncludeDebug &amp;&amp; !hasScope(scopes, "search:debug") </span><span class="cov8" title="1">{
                return apperror.ErrForbidden.WithMessage("debug scope required for includeDebug=true")
        }</span>

        // Build search context
        <span class="cov8" title="1">searchCtx := &amp;SearchContext{
                OrgID:     orgID,
                ProjectID: projectID,
                Scopes:    scopes,
        }

        // Execute unified search
        response, err := h.svc.Search(c.Request().Context(), projectID, &amp;req, searchCtx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, response)</span>
}

// hasScope checks if the given scope exists in the list
func hasScope(scopes []string, scope string) bool <span class="cov8" title="1">{
        for _, s := range scopes </span><span class="cov8" title="1">{
                if s == scope </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">package search

import (
        "context"
        "log/slog"
        "sort"

        "github.com/google/uuid"
        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
        "github.com/emergent/emergent-core/pkg/mathutil"
        "github.com/emergent/emergent-core/pkg/pgutils"
)

// Repository handles text search operations on kb.chunks
type Repository struct {
        db  bun.IDB
        log *slog.Logger
}

// NewRepository creates a new search repository
func NewRepository(db bun.IDB, log *slog.Logger) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                db:  db,
                log: log.With(logger.Scope("search.repo")),
        }
}</span>

// TextSearchMode defines the type of text search
type TextSearchMode string

const (
        TextSearchModeLexical TextSearchMode = "lexical"
        TextSearchModeVector  TextSearchMode = "vector"
        TextSearchModeHybrid  TextSearchMode = "hybrid"
)

// TextSearchParams contains parameters for text search
type TextSearchParams struct {
        ProjectID     uuid.UUID
        Query         string
        Vector        []float32 // Query embedding for vector/hybrid search
        Mode          TextSearchMode
        LexicalWeight float32
        VectorWeight  float32
        Limit         int
}

// TextSearchResultRow represents a single text search result from the database
type TextSearchResultRow struct {
        ID         uuid.UUID
        DocumentID uuid.UUID
        ChunkIndex int
        Text       string
        Score      float32
}

// TextSearchResponse contains the search results and metadata
type TextSearchResponse struct {
        Results         []*TextSearchResult
        Mode            TextSearchMode
        TotalCandidates int
}

// LexicalSearch performs full-text search on kb.chunks using tsv column
func (r *Repository) LexicalSearch(ctx context.Context, params TextSearchParams) (*TextSearchResponse, error) <span class="cov8" title="1">{
        limit := mathutil.ClampLimit(params.Limit, 20, 100)

        query := `
                SELECT c.id, c.document_id, c.chunk_index, c.text,
                           ts_rank(c.tsv, websearch_to_tsquery('simple', ?)) AS score
                FROM kb.chunks c
                JOIN kb.documents d ON d.id = c.document_id
                WHERE c.tsv @@ websearch_to_tsquery('simple', ?)
                  AND d.project_id = ?
                ORDER BY score DESC
                LIMIT ?
        `

        rows, err := r.db.QueryContext(ctx, query, params.Query, params.Query, params.ProjectID, limit)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("lexical search failed", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var results []*TextSearchResult
        for rows.Next() </span><span class="cov8" title="1">{
                var row TextSearchResultRow
                if err := rows.Scan(&amp;row.ID, &amp;row.DocumentID, &amp;row.ChunkIndex, &amp;row.Text, &amp;row.Score); err != nil </span><span class="cov0" title="0">{
                        r.log.Error("lexical search row scan failed", logger.Error(err))
                        return nil, apperror.ErrDatabase.WithInternal(err)
                }</span>
                <span class="cov8" title="1">mode := string(TextSearchModeLexical)
                docID := row.DocumentID.String()
                results = append(results, &amp;TextSearchResult{
                        ID:         row.ID,
                        DocumentID: row.DocumentID,
                        ChunkIndex: row.ChunkIndex,
                        Text:       row.Text,
                        Score:      row.Score,
                        Mode:       &amp;mode,
                        Source:     &amp;docID,
                })</span>
        }

        <span class="cov8" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return &amp;TextSearchResponse{
                Results:         results,
                Mode:            TextSearchModeLexical,
                TotalCandidates: len(results),
        }, nil</span>
}

// VectorSearch performs vector similarity search on kb.chunks using embedding column
func (r *Repository) VectorSearch(ctx context.Context, params TextSearchParams) (*TextSearchResponse, error) <span class="cov0" title="0">{
        if len(params.Vector) == 0 </span><span class="cov0" title="0">{
                return nil, apperror.ErrBadRequest.WithMessage("vector required for vector search")
        }</span>

        <span class="cov0" title="0">limit := mathutil.ClampLimit(params.Limit, 20, 100)
        vectorStr := pgutils.FormatVector(params.Vector)

        // Cosine distance: lower is better, convert to similarity score (1 - distance)
        query := `
                SELECT c.id, c.document_id, c.chunk_index, c.text,
                           (1 - (c.embedding &lt;=&gt; ?::vector)) AS score
                FROM kb.chunks c
                JOIN kb.documents d ON d.id = c.document_id
                WHERE c.embedding IS NOT NULL
                  AND d.project_id = ?
                ORDER BY c.embedding &lt;=&gt; ?::vector
                LIMIT ?
        `

        rows, err := r.db.QueryContext(ctx, query, vectorStr, params.ProjectID, vectorStr, limit)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("vector search failed", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var results []*TextSearchResult
        for rows.Next() </span><span class="cov0" title="0">{
                var row TextSearchResultRow
                if err := rows.Scan(&amp;row.ID, &amp;row.DocumentID, &amp;row.ChunkIndex, &amp;row.Text, &amp;row.Score); err != nil </span><span class="cov0" title="0">{
                        r.log.Error("vector search row scan failed", logger.Error(err))
                        return nil, apperror.ErrDatabase.WithInternal(err)
                }</span>
                <span class="cov0" title="0">mode := string(TextSearchModeVector)
                docID := row.DocumentID.String()
                results = append(results, &amp;TextSearchResult{
                        ID:         row.ID,
                        DocumentID: row.DocumentID,
                        ChunkIndex: row.ChunkIndex,
                        Text:       row.Text,
                        Score:      row.Score,
                        Mode:       &amp;mode,
                        Source:     &amp;docID,
                })</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov0" title="0">return &amp;TextSearchResponse{
                Results:         results,
                Mode:            TextSearchModeVector,
                TotalCandidates: len(results),
        }, nil</span>
}

// HybridSearch combines lexical and vector search using z-score normalization and weighted fusion
func (r *Repository) HybridSearch(ctx context.Context, params TextSearchParams) (*TextSearchResponse, error) <span class="cov0" title="0">{
        if len(params.Vector) == 0 </span><span class="cov0" title="0">{
                // Fall back to lexical only
                return r.LexicalSearch(ctx, params)
        }</span>

        <span class="cov0" title="0">limit := mathutil.ClampLimit(params.Limit, 20, 100)

        // Fetch 2x limit from each source for better fusion
        fetchLimit := limit * 2
        vectorStr := pgutils.FormatVector(params.Vector)

        // Set default weights
        lexicalWeight := params.LexicalWeight
        vectorWeight := params.VectorWeight
        if lexicalWeight &lt;= 0 </span><span class="cov0" title="0">{
                lexicalWeight = 0.5
        }</span>
        <span class="cov0" title="0">if vectorWeight &lt;= 0 </span><span class="cov0" title="0">{
                vectorWeight = 0.5
        }</span>

        // Execute lexical search
        <span class="cov0" title="0">lexicalQuery := `
                SELECT c.id, c.document_id, c.chunk_index, c.text,
                           ts_rank(c.tsv, websearch_to_tsquery('simple', ?)) AS score
                FROM kb.chunks c
                JOIN kb.documents d ON d.id = c.document_id
                WHERE c.tsv @@ websearch_to_tsquery('simple', ?)
                  AND d.project_id = ?
                ORDER BY score DESC
                LIMIT ?
        `
        lexicalRows, err := r.db.QueryContext(ctx, lexicalQuery, params.Query, params.Query, params.ProjectID, fetchLimit)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("hybrid lexical search failed", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov0" title="0">lexicalResults := make(map[uuid.UUID]*hybridCandidate)
        var lexicalScores []float32
        for lexicalRows.Next() </span><span class="cov0" title="0">{
                var row TextSearchResultRow
                if err := lexicalRows.Scan(&amp;row.ID, &amp;row.DocumentID, &amp;row.ChunkIndex, &amp;row.Text, &amp;row.Score); err != nil </span><span class="cov0" title="0">{
                        lexicalRows.Close()
                        return nil, apperror.ErrDatabase.WithInternal(err)
                }</span>
                <span class="cov0" title="0">lexicalResults[row.ID] = &amp;hybridCandidate{
                        ID:           row.ID,
                        DocumentID:   row.DocumentID,
                        ChunkIndex:   row.ChunkIndex,
                        Text:         row.Text,
                        LexicalScore: row.Score,
                }
                lexicalScores = append(lexicalScores, row.Score)</span>
        }
        <span class="cov0" title="0">lexicalRows.Close()

        // Execute vector search
        vectorQuery := `
                SELECT c.id, c.document_id, c.chunk_index, c.text,
                           (1 - (c.embedding &lt;=&gt; ?::vector)) AS score
                FROM kb.chunks c
                JOIN kb.documents d ON d.id = c.document_id
                WHERE c.embedding IS NOT NULL
                  AND d.project_id = ?
                ORDER BY c.embedding &lt;=&gt; ?::vector
                LIMIT ?
        `
        vectorRows, err := r.db.QueryContext(ctx, vectorQuery, vectorStr, params.ProjectID, vectorStr, fetchLimit)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("hybrid vector search failed", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov0" title="0">var vectorScores []float32
        for vectorRows.Next() </span><span class="cov0" title="0">{
                var row TextSearchResultRow
                if err := vectorRows.Scan(&amp;row.ID, &amp;row.DocumentID, &amp;row.ChunkIndex, &amp;row.Text, &amp;row.Score); err != nil </span><span class="cov0" title="0">{
                        vectorRows.Close()
                        return nil, apperror.ErrDatabase.WithInternal(err)
                }</span>
                <span class="cov0" title="0">if existing, ok := lexicalResults[row.ID]; ok </span><span class="cov0" title="0">{
                        existing.VectorScore = row.Score
                }</span> else<span class="cov0" title="0"> {
                        lexicalResults[row.ID] = &amp;hybridCandidate{
                                ID:          row.ID,
                                DocumentID:  row.DocumentID,
                                ChunkIndex:  row.ChunkIndex,
                                Text:        row.Text,
                                VectorScore: row.Score,
                        }
                }</span>
                <span class="cov0" title="0">vectorScores = append(vectorScores, row.Score)</span>
        }
        <span class="cov0" title="0">vectorRows.Close()

        // Calculate z-score normalization parameters
        lexicalMean, lexicalStd := mathutil.CalcMeanStd(lexicalScores)
        vectorMean, vectorStd := mathutil.CalcMeanStd(vectorScores)

        // Normalize and fuse scores
        var candidates []*hybridCandidate
        for _, c := range lexicalResults </span><span class="cov0" title="0">{
                // Z-score normalize each score, then apply sigmoid to get [0,1]
                normalizedLexical := float32(0)
                if c.LexicalScore &gt; 0 &amp;&amp; lexicalStd &gt; 0 </span><span class="cov0" title="0">{
                        z := (c.LexicalScore - lexicalMean) / lexicalStd
                        normalizedLexical = mathutil.Sigmoid(z)
                }</span>

                <span class="cov0" title="0">normalizedVector := float32(0)
                if c.VectorScore &gt; 0 &amp;&amp; vectorStd &gt; 0 </span><span class="cov0" title="0">{
                        z := (c.VectorScore - vectorMean) / vectorStd
                        normalizedVector = mathutil.Sigmoid(z)
                }</span>

                // Weighted combination
                <span class="cov0" title="0">c.FusedScore = normalizedLexical*lexicalWeight + normalizedVector*vectorWeight
                candidates = append(candidates, c)</span>
        }

        // Sort by fused score descending
        <span class="cov0" title="0">sort.Slice(candidates, func(i, j int) bool </span><span class="cov0" title="0">{
                return candidates[i].FusedScore &gt; candidates[j].FusedScore
        }</span>)

        // Take top results
        <span class="cov0" title="0">if len(candidates) &gt; limit </span><span class="cov0" title="0">{
                candidates = candidates[:limit]
        }</span>

        // Convert to results
        <span class="cov0" title="0">results := make([]*TextSearchResult, len(candidates))
        mode := string(TextSearchModeHybrid)
        for i, c := range candidates </span><span class="cov0" title="0">{
                docID := c.DocumentID.String()
                results[i] = &amp;TextSearchResult{
                        ID:         c.ID,
                        DocumentID: c.DocumentID,
                        ChunkIndex: c.ChunkIndex,
                        Text:       c.Text,
                        Score:      c.FusedScore,
                        Mode:       &amp;mode,
                        Source:     &amp;docID,
                }
        }</span>

        <span class="cov0" title="0">return &amp;TextSearchResponse{
                Results:         results,
                Mode:            TextSearchModeHybrid,
                TotalCandidates: len(lexicalResults),
        }, nil</span>
}

// hybridCandidate holds intermediate fusion data
type hybridCandidate struct {
        ID           uuid.UUID
        DocumentID   uuid.UUID
        ChunkIndex   int
        Text         string
        LexicalScore float32
        VectorScore  float32
        FusedScore   float32
}
</pre>
		
		<pre class="file" id="file88" style="display: none">package search

import (
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/auth"
)

// RegisterRoutes registers the search routes
func RegisterRoutes(e *echo.Echo, handler *Handler, authMiddleware *auth.Middleware) <span class="cov8" title="1">{
        // Search routes require authentication and project ID
        search := e.Group("/api/v2/search")
        search.Use(authMiddleware.RequireAuth())
        search.Use(authMiddleware.RequireProjectID())

        // Unified search requires search:read scope
        unified := search.Group("/unified")
        unified.Use(authMiddleware.RequireScopes("search:read"))
        unified.POST("", handler.Search)
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package search

import (
        "context"
        "log/slog"
        "sort"
        "time"

        "github.com/google/uuid"

        "github.com/emergent/emergent-core/domain/graph"
        "github.com/emergent/emergent-core/pkg/embeddings"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Service handles unified search combining graph and text results
type Service struct {
        repo         *Repository
        graphService *graph.Service
        embeddings   *embeddings.Service
        log          *slog.Logger
}

// NewService creates a new search service
func NewService(
        repo *Repository,
        graphService *graph.Service,
        embeddingsSvc *embeddings.Service,
        log *slog.Logger,
) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo:         repo,
                graphService: graphService,
                embeddings:   embeddingsSvc,
                log:          log.With(logger.Scope("search.svc")),
        }
}</span>

// Search executes unified search combining graph and text results
func (s *Service) Search(ctx context.Context, projectID uuid.UUID, req *UnifiedSearchRequest, searchCtx *SearchContext) (*UnifiedSearchResponse, error) <span class="cov8" title="1">{
        startTime := time.Now()

        // Apply defaults
        limit := req.Limit
        if limit &lt;= 0 </span><span class="cov8" title="1">{
                limit = 20
        }</span>
        <span class="cov8" title="1">if limit &gt; 100 </span><span class="cov0" title="0">{
                limit = 100
        }</span>

        <span class="cov8" title="1">resultTypes := req.ResultTypes
        if resultTypes == "" </span><span class="cov8" title="1">{
                resultTypes = ResultTypeBoth
        }</span>

        <span class="cov8" title="1">fusionStrategy := req.FusionStrategy
        if fusionStrategy == "" </span><span class="cov8" title="1">{
                fusionStrategy = FusionStrategyWeighted
        }</span>

        // Execute graph and text searches in parallel
        <span class="cov8" title="1">type graphResult struct {
                results   []*UnifiedSearchGraphResult
                elapsed   time.Duration
                rawDebug  any
                err       error
        }
        type textResult struct {
                results   []*TextSearchResult
                mode      string
                elapsed   time.Duration
                rawDebug  any
                err       error
        }

        graphCh := make(chan graphResult, 1)
        textCh := make(chan textResult, 1)

        // Execute graph search
        go func() </span><span class="cov8" title="1">{
                if resultTypes == ResultTypeText </span><span class="cov8" title="1">{
                        graphCh &lt;- graphResult{results: nil, elapsed: 0}
                        return
                }</span>
                <span class="cov8" title="1">start := time.Now()
                results, rawDebug, err := s.executeGraphSearch(ctx, projectID, req, searchCtx)
                graphCh &lt;- graphResult{results: results, elapsed: time.Since(start), rawDebug: rawDebug, err: err}</span>
        }()

        // Execute text search
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                if resultTypes == ResultTypeGraph </span><span class="cov8" title="1">{
                        textCh &lt;- textResult{results: nil, elapsed: 0}
                        return
                }</span>
                <span class="cov8" title="1">start := time.Now()
                results, mode, rawDebug, err := s.executeTextSearch(ctx, projectID, req)
                textCh &lt;- textResult{results: results, mode: mode, elapsed: time.Since(start), rawDebug: rawDebug, err: err}</span>
        }()

        // Wait for both searches
        <span class="cov8" title="1">graphRes := &lt;-graphCh
        textRes := &lt;-textCh

        if graphRes.err != nil </span><span class="cov0" title="0">{
                return nil, graphRes.err
        }</span>
        <span class="cov8" title="1">if textRes.err != nil </span><span class="cov0" title="0">{
                return nil, textRes.err
        }</span>

        // Expand relationships for graph results if enabled
        <span class="cov8" title="1">graphResults := graphRes.results
        var relationshipElapsed time.Duration
        if req.RelationshipOptions != nil &amp;&amp; req.RelationshipOptions.Enabled &amp;&amp; len(graphResults) &gt; 0 </span><span class="cov0" title="0">{
                start := time.Now()
                graphResults = s.expandRelationships(ctx, projectID, graphResults, req.RelationshipOptions)
                relationshipElapsed = time.Since(start)
        }</span>

        // Fuse results
        <span class="cov8" title="1">fusionStart := time.Now()
        fusedResults := s.fuseResults(graphResults, textRes.results, fusionStrategy, req.Weights, limit)
        fusionElapsed := time.Since(fusionStart)

        // Count result types
        graphCount := 0
        textCount := 0
        for _, r := range fusedResults </span><span class="cov8" title="1">{
                if r.Type == ItemTypeGraph </span><span class="cov0" title="0">{
                        graphCount++
                }</span> else<span class="cov8" title="1"> {
                        textCount++
                }</span>
        }

        // Build metadata
        <span class="cov8" title="1">metadata := UnifiedSearchMetadata{
                TotalResults:     len(fusedResults),
                GraphResultCount: graphCount,
                TextResultCount:  textCount,
                FusionStrategy:   fusionStrategy,
                ExecutionTime: UnifiedSearchExecutionTime{
                        FusionMs: int(fusionElapsed.Milliseconds()),
                        TotalMs:  int(time.Since(startTime).Milliseconds()),
                },
        }

        if resultTypes != ResultTypeText </span><span class="cov8" title="1">{
                graphMs := int(graphRes.elapsed.Milliseconds())
                metadata.ExecutionTime.GraphSearchMs = &amp;graphMs
        }</span>
        <span class="cov8" title="1">if resultTypes != ResultTypeGraph </span><span class="cov8" title="1">{
                textMs := int(textRes.elapsed.Milliseconds())
                metadata.ExecutionTime.TextSearchMs = &amp;textMs
        }</span>
        <span class="cov8" title="1">if relationshipElapsed &gt; 0 </span><span class="cov0" title="0">{
                relMs := int(relationshipElapsed.Milliseconds())
                metadata.ExecutionTime.RelationshipExpansionMs = &amp;relMs
        }</span>

        // Build debug info if requested
        <span class="cov8" title="1">var debug *UnifiedSearchDebug
        if req.IncludeDebug </span><span class="cov0" title="0">{
                debug = s.buildDebugInfo(graphRes.rawDebug, textRes.rawDebug, graphResults, textRes.results, fusionStrategy, req.Weights, len(fusedResults))
        }</span>

        <span class="cov8" title="1">return &amp;UnifiedSearchResponse{
                Results:  fusedResults,
                Metadata: metadata,
                Debug:    debug,
        }, nil</span>
}

// executeGraphSearch runs the graph search using the graph service
func (s *Service) executeGraphSearch(ctx context.Context, projectID uuid.UUID, req *UnifiedSearchRequest, searchCtx *SearchContext) ([]*UnifiedSearchGraphResult, any, error) <span class="cov8" title="1">{
        // Get query embedding for hybrid search
        var vector []float32
        if s.embeddings != nil </span><span class="cov8" title="1">{
                vec, err := s.embeddings.EmbedQuery(ctx, req.Query)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Warn("failed to generate query embedding for graph search", logger.Error(err))
                        // Continue with lexical-only search
                }</span> else<span class="cov8" title="1"> {
                        vector = vec
                }</span>
        }

        // Build hybrid search request
        <span class="cov8" title="1">hybridReq := &amp;graph.HybridSearchRequest{
                Query:  req.Query,
                Vector: vector,
                Limit:  req.Limit,
        }

        // Execute search
        searchResp, err := s.graphService.HybridSearch(ctx, projectID, hybridReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        // Convert to unified search results
        <span class="cov8" title="1">results := make([]*UnifiedSearchGraphResult, len(searchResp.Data))
        for i, item := range searchResp.Data </span><span class="cov0" title="0">{
                key := ""
                if item.Object.Key != nil </span><span class="cov0" title="0">{
                        key = *item.Object.Key
                }</span>
                <span class="cov0" title="0">results[i] = &amp;UnifiedSearchGraphResult{
                        ObjectID:      item.Object.ID.String(),
                        CanonicalID:   item.Object.CanonicalID.String(),
                        ObjectType:    item.Object.Type,
                        Key:           key,
                        Fields:        item.Object.Properties,
                        Score:         item.Score,
                        Rank:          i + 1,
                        LexicalScore:  item.LexicalScore,
                        VectorScore:   item.VectorScore,
                        Relationships: []UnifiedSearchRelationship{}, // Will be populated if expansion is enabled
                }</span>
        }

        // Return raw debug items if debug is enabled
        <span class="cov8" title="1">var rawDebug any
        if req.IncludeDebug </span><span class="cov0" title="0">{
                rawDebug = searchResp.Data
        }</span>

        <span class="cov8" title="1">return results, rawDebug, nil</span>
}

// executeTextSearch runs text search on document chunks
func (s *Service) executeTextSearch(ctx context.Context, projectID uuid.UUID, req *UnifiedSearchRequest) ([]*TextSearchResult, string, any, error) <span class="cov8" title="1">{
        // Get query embedding for hybrid search
        var vector []float32
        if s.embeddings != nil </span><span class="cov8" title="1">{
                vec, err := s.embeddings.EmbedQuery(ctx, req.Query)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Warn("failed to generate query embedding for text search", logger.Error(err))
                        // Continue with lexical-only search
                }</span> else<span class="cov8" title="1"> {
                        vector = vec
                }</span>
        }

        // Execute hybrid search (or lexical if no embedding)
        <span class="cov8" title="1">params := TextSearchParams{
                ProjectID:     projectID,
                Query:         req.Query,
                Vector:        vector,
                Mode:          TextSearchModeHybrid,
                LexicalWeight: 0.5,
                VectorWeight:  0.5,
                Limit:         req.Limit,
        }

        var resp *TextSearchResponse
        var err error

        if len(vector) &gt; 0 </span><span class="cov0" title="0">{
                resp, err = s.repo.HybridSearch(ctx, params)
        }</span> else<span class="cov8" title="1"> {
                resp, err = s.repo.LexicalSearch(ctx, params)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, "", nil, err
        }</span>

        // Return raw debug info
        <span class="cov8" title="1">var rawDebug any
        if req.IncludeDebug </span><span class="cov0" title="0">{
                rawDebug = resp.Results
        }</span>

        <span class="cov8" title="1">return resp.Results, string(resp.Mode), rawDebug, nil</span>
}

// expandRelationships fetches relationships for graph results
func (s *Service) expandRelationships(ctx context.Context, projectID uuid.UUID, results []*UnifiedSearchGraphResult, options *UnifiedSearchRelationshipOptions) []*UnifiedSearchGraphResult <span class="cov0" title="0">{
        if options == nil || !options.Enabled || options.MaxDepth == 0 </span><span class="cov0" title="0">{
                return results
        }</span>

        // Collect object IDs
        <span class="cov0" title="0">objectIDs := make([]uuid.UUID, len(results))
        for i, r := range results </span><span class="cov0" title="0">{
                objectIDs[i] = uuid.MustParse(r.ObjectID)
        }</span>

        // Build relationship map for each object
        <span class="cov0" title="0">relationshipMap := make(map[string][]UnifiedSearchRelationship)

        for _, objID := range objectIDs </span><span class="cov0" title="0">{
                edgesResp, err := s.graphService.GetEdges(ctx, projectID, objID)
                if err != nil </span><span class="cov0" title="0">{
                        s.log.Warn("failed to expand relationships", logger.Error(err), slog.String("object_id", objID.String()))
                        continue</span>
                }

                <span class="cov0" title="0">var rels []UnifiedSearchRelationship

                // Add incoming relationships
                if options.Direction == "" || options.Direction == "in" || options.Direction == "both" </span><span class="cov0" title="0">{
                        for _, rel := range edgesResp.Incoming </span><span class="cov0" title="0">{
                                rels = append(rels, UnifiedSearchRelationship{
                                        ObjectID:   rel.SrcID.String(),
                                        Type:       rel.Type,
                                        Direction:  "in",
                                        Properties: rel.Properties,
                                })
                        }</span>
                }

                // Add outgoing relationships
                <span class="cov0" title="0">if options.Direction == "" || options.Direction == "out" || options.Direction == "both" </span><span class="cov0" title="0">{
                        for _, rel := range edgesResp.Outgoing </span><span class="cov0" title="0">{
                                rels = append(rels, UnifiedSearchRelationship{
                                        ObjectID:   rel.DstID.String(),
                                        Type:       rel.Type,
                                        Direction:  "out",
                                        Properties: rel.Properties,
                                })
                        }</span>
                }

                // Apply maxNeighbors limit
                <span class="cov0" title="0">if options.MaxNeighbors &gt; 0 &amp;&amp; len(rels) &gt; options.MaxNeighbors </span><span class="cov0" title="0">{
                        rels = rels[:options.MaxNeighbors]
                }</span>

                <span class="cov0" title="0">relationshipMap[objID.String()] = rels</span>
        }

        // Attach relationships to results
        <span class="cov0" title="0">for _, r := range results </span><span class="cov0" title="0">{
                if rels, ok := relationshipMap[r.ObjectID]; ok </span><span class="cov0" title="0">{
                        r.Relationships = rels
                }</span>
        }

        <span class="cov0" title="0">return results</span>
}

// fuseResults combines graph and text results using the specified strategy
func (s *Service) fuseResults(graphResults []*UnifiedSearchGraphResult, textResults []*TextSearchResult, strategy UnifiedSearchFusionStrategy, weights *UnifiedSearchWeights, limit int) []UnifiedSearchResultItem <span class="cov8" title="1">{
        switch strategy </span>{
        case FusionStrategyWeighted:<span class="cov8" title="1">
                return s.fuseWeighted(graphResults, textResults, weights, limit)</span>
        case FusionStrategyRRF:<span class="cov8" title="1">
                return s.fuseRRF(graphResults, textResults, limit)</span>
        case FusionStrategyInterleave:<span class="cov8" title="1">
                return s.fuseInterleave(graphResults, textResults, limit)</span>
        case FusionStrategyGraphFirst:<span class="cov8" title="1">
                return s.fuseGraphFirst(graphResults, textResults, limit)</span>
        case FusionStrategyTextFirst:<span class="cov8" title="1">
                return s.fuseTextFirst(graphResults, textResults, limit)</span>
        default:<span class="cov8" title="1">
                return s.fuseWeighted(graphResults, textResults, weights, limit)</span>
        }
}

// fuseWeighted combines results using weighted scores
func (s *Service) fuseWeighted(graphResults []*UnifiedSearchGraphResult, textResults []*TextSearchResult, weights *UnifiedSearchWeights, limit int) []UnifiedSearchResultItem <span class="cov8" title="1">{
        graphWeight := float32(0.5)
        textWeight := float32(0.5)
        if weights != nil </span><span class="cov8" title="1">{
                if weights.GraphWeight &gt; 0 </span><span class="cov8" title="1">{
                        graphWeight = weights.GraphWeight
                }</span>
                <span class="cov8" title="1">if weights.TextWeight &gt; 0 </span><span class="cov8" title="1">{
                        textWeight = weights.TextWeight
                }</span>
        }

        // Normalize weights
        <span class="cov8" title="1">totalWeight := graphWeight + textWeight
        if totalWeight &gt; 0 </span><span class="cov8" title="1">{
                graphWeight /= totalWeight
                textWeight /= totalWeight
        }</span>

        // Create scored items
        <span class="cov8" title="1">type scoredItem struct {
                item       UnifiedSearchResultItem
                fusedScore float32
        }

        var combined []scoredItem

        for _, g := range graphResults </span><span class="cov8" title="1">{
                item := s.graphResultToItem(g)
                combined = append(combined, scoredItem{
                        item:       item,
                        fusedScore: g.Score * graphWeight,
                })
        }</span>

        <span class="cov8" title="1">for _, t := range textResults </span><span class="cov8" title="1">{
                item := s.textResultToItem(t)
                combined = append(combined, scoredItem{
                        item:       item,
                        fusedScore: t.Score * textWeight,
                })
        }</span>

        // Sort by fused score descending
        <span class="cov8" title="1">sort.Slice(combined, func(i, j int) bool </span><span class="cov8" title="1">{
                return combined[i].fusedScore &gt; combined[j].fusedScore
        }</span>)

        // Apply limit
        <span class="cov8" title="1">if len(combined) &gt; limit </span><span class="cov8" title="1">{
                combined = combined[:limit]
        }</span>

        // Extract items with updated scores
        <span class="cov8" title="1">results := make([]UnifiedSearchResultItem, len(combined))
        for i, c := range combined </span><span class="cov8" title="1">{
                c.item.Score = c.fusedScore
                results[i] = c.item
        }</span>

        <span class="cov8" title="1">return results</span>
}

// fuseRRF combines results using Reciprocal Rank Fusion
func (s *Service) fuseRRF(graphResults []*UnifiedSearchGraphResult, textResults []*TextSearchResult, limit int) []UnifiedSearchResultItem <span class="cov8" title="1">{
        const k = 60 // Standard RRF constant

        scoreMap := make(map[string]struct {
                item  UnifiedSearchResultItem
                score float32
        })

        // Add graph results with RRF score
        for i, g := range graphResults </span><span class="cov8" title="1">{
                rrfScore := float32(1.0) / float32(k+i+1)
                item := s.graphResultToItem(g)
                scoreMap[g.ObjectID] = struct {
                        item  UnifiedSearchResultItem
                        score float32
                }{item: item, score: rrfScore}
        }</span>

        // Add text results with RRF score (combine if overlapping)
        <span class="cov8" title="1">for i, t := range textResults </span><span class="cov8" title="1">{
                rrfScore := float32(1.0) / float32(k+i+1)
                id := t.ID.String()

                if existing, ok := scoreMap[id]; ok </span><span class="cov8" title="1">{
                        // Item appears in both - boost score
                        existing.score += rrfScore
                        scoreMap[id] = existing
                }</span> else<span class="cov8" title="1"> {
                        item := s.textResultToItem(t)
                        scoreMap[id] = struct {
                                item  UnifiedSearchResultItem
                                score float32
                        }{item: item, score: rrfScore}
                }</span>
        }

        // Convert to slice and sort
        <span class="cov8" title="1">type entry struct {
                id    string
                item  UnifiedSearchResultItem
                score float32
        }
        var entries []entry
        for id, v := range scoreMap </span><span class="cov8" title="1">{
                entries = append(entries, entry{id: id, item: v.item, score: v.score})
        }</span>

        <span class="cov8" title="1">sort.Slice(entries, func(i, j int) bool </span><span class="cov8" title="1">{
                return entries[i].score &gt; entries[j].score
        }</span>)

        // Apply limit and update scores
        <span class="cov8" title="1">if len(entries) &gt; limit </span><span class="cov8" title="1">{
                entries = entries[:limit]
        }</span>

        <span class="cov8" title="1">results := make([]UnifiedSearchResultItem, len(entries))
        for i, e := range entries </span><span class="cov8" title="1">{
                e.item.Score = e.score
                results[i] = e.item
        }</span>

        <span class="cov8" title="1">return results</span>
}

// fuseInterleave alternates between graph and text results
func (s *Service) fuseInterleave(graphResults []*UnifiedSearchGraphResult, textResults []*TextSearchResult, limit int) []UnifiedSearchResultItem <span class="cov8" title="1">{
        var results []UnifiedSearchResultItem

        graphIdx := 0
        textIdx := 0

        for len(results) &lt; limit </span><span class="cov8" title="1">{
                // Add graph result
                if graphIdx &lt; len(graphResults) </span><span class="cov8" title="1">{
                        results = append(results, s.graphResultToItem(graphResults[graphIdx]))
                        graphIdx++
                }</span>
                <span class="cov8" title="1">if len(results) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }

                // Add text result
                <span class="cov8" title="1">if textIdx &lt; len(textResults) </span><span class="cov8" title="1">{
                        results = append(results, s.textResultToItem(textResults[textIdx]))
                        textIdx++
                }</span>
                <span class="cov8" title="1">if len(results) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }

                // Stop if both exhausted
                <span class="cov8" title="1">if graphIdx &gt;= len(graphResults) &amp;&amp; textIdx &gt;= len(textResults) </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return results</span>
}

// fuseGraphFirst shows all graph results, then text results
func (s *Service) fuseGraphFirst(graphResults []*UnifiedSearchGraphResult, textResults []*TextSearchResult, limit int) []UnifiedSearchResultItem <span class="cov8" title="1">{
        var results []UnifiedSearchResultItem

        for _, g := range graphResults </span><span class="cov8" title="1">{
                if len(results) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">results = append(results, s.graphResultToItem(g))</span>
        }

        <span class="cov8" title="1">for _, t := range textResults </span><span class="cov8" title="1">{
                if len(results) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">results = append(results, s.textResultToItem(t))</span>
        }

        <span class="cov8" title="1">return results</span>
}

// fuseTextFirst shows all text results, then graph results
func (s *Service) fuseTextFirst(graphResults []*UnifiedSearchGraphResult, textResults []*TextSearchResult, limit int) []UnifiedSearchResultItem <span class="cov8" title="1">{
        var results []UnifiedSearchResultItem

        for _, t := range textResults </span><span class="cov8" title="1">{
                if len(results) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">results = append(results, s.textResultToItem(t))</span>
        }

        <span class="cov8" title="1">for _, g := range graphResults </span><span class="cov8" title="1">{
                if len(results) &gt;= limit </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">results = append(results, s.graphResultToItem(g))</span>
        }

        <span class="cov8" title="1">return results</span>
}

// graphResultToItem converts a graph result to a unified search result item
func (s *Service) graphResultToItem(g *UnifiedSearchGraphResult) UnifiedSearchResultItem <span class="cov8" title="1">{
        return UnifiedSearchResultItem{
                Type:          ItemTypeGraph,
                ID:            g.ObjectID,
                Score:         g.Score,
                ObjectID:      g.ObjectID,
                CanonicalID:   g.CanonicalID,
                Rank:          g.Rank,
                ObjectType:    g.ObjectType,
                Key:           g.Key,
                Fields:        g.Fields,
                Relationships: g.Relationships,
                Explanation:   g.Explanation,
        }
}</span>

// textResultToItem converts a text result to a unified search result item
func (s *Service) textResultToItem(t *TextSearchResult) UnifiedSearchResultItem <span class="cov8" title="1">{
        docID := t.DocumentID.String()
        return UnifiedSearchResultItem{
                Type:       ItemTypeText,
                ID:         t.ID.String(),
                Score:      t.Score,
                Snippet:    t.Text,
                Source:     t.Source,
                Mode:       t.Mode,
                DocumentID: &amp;docID,
        }
}</span>

// buildDebugInfo creates debug information for the search response
func (s *Service) buildDebugInfo(graphDebug, textDebug any, graphResults []*UnifiedSearchGraphResult, textResults []*TextSearchResult, strategy UnifiedSearchFusionStrategy, weights *UnifiedSearchWeights, postFusionCount int) *UnifiedSearchDebug <span class="cov0" title="0">{
        // Calculate score distribution
        var scoreDistribution *UnifiedSearchScoreDistribution

        if len(graphResults) &gt; 0 || len(textResults) &gt; 0 </span><span class="cov0" title="0">{
                scoreDistribution = &amp;UnifiedSearchScoreDistribution{}

                if len(graphResults) &gt; 0 </span><span class="cov0" title="0">{
                        graphScores := make([]float32, len(graphResults))
                        for i, g := range graphResults </span><span class="cov0" title="0">{
                                graphScores[i] = g.Score
                        }</span>
                        <span class="cov0" title="0">min, max, mean := calcScoreStats(graphScores)
                        scoreDistribution.Graph = &amp;ScoreStats{Min: min, Max: max, Mean: mean}</span>
                }

                <span class="cov0" title="0">if len(textResults) &gt; 0 </span><span class="cov0" title="0">{
                        textScores := make([]float32, len(textResults))
                        for i, t := range textResults </span><span class="cov0" title="0">{
                                textScores[i] = t.Score
                        }</span>
                        <span class="cov0" title="0">min, max, mean := calcScoreStats(textScores)
                        scoreDistribution.Text = &amp;ScoreStats{Min: min, Max: max, Mean: mean}</span>
                }
        }

        // Build fusion details
        <span class="cov0" title="0">fusionDetails := &amp;UnifiedSearchFusionDetails{
                Strategy:        strategy,
                Weights:         weights,
                PostFusionCount: postFusionCount,
                PreFusionCounts: &amp;PreFusionCounts{
                        Graph: len(graphResults),
                        Text:  len(textResults),
                },
        }

        return &amp;UnifiedSearchDebug{
                GraphSearch:       graphDebug,
                TextSearch:        textDebug,
                ScoreDistribution: scoreDistribution,
                FusionDetails:     fusionDetails,
        }</span>
}

// calcScoreStats calculates min, max, mean for a slice of scores
func calcScoreStats(scores []float32) (min, max, mean float32) <span class="cov8" title="1">{
        if len(scores) == 0 </span><span class="cov8" title="1">{
                return 0, 0, 0
        }</span>

        <span class="cov8" title="1">min = scores[0]
        max = scores[0]
        var sum float32

        for _, s := range scores </span><span class="cov8" title="1">{
                if s &lt; min </span><span class="cov8" title="1">{
                        min = s
                }</span>
                <span class="cov8" title="1">if s &gt; max </span><span class="cov8" title="1">{
                        max = s
                }</span>
                <span class="cov8" title="1">sum += s</span>
        }

        <span class="cov8" title="1">mean = sum / float32(len(scores))
        return min, max, mean</span>
}
</pre>
		
		<pre class="file" id="file90" style="display: none">package useraccess

import (
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

// Handler handles HTTP requests for user access
type Handler struct {
        svc *Service
}

// NewHandler creates a new user access handler
func NewHandler(svc *Service) *Handler <span class="cov0" title="0">{
        return &amp;Handler{svc: svc}
}</span>

// GetOrgsAndProjects returns the user's access tree (organizations and projects with roles)
// GET /user/orgs-and-projects
func (h *Handler) GetOrgsAndProjects(c echo.Context) error <span class="cov0" title="0">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov0" title="0">tree, err := h.svc.GetAccessTree(c.Request().Context(), user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return c.JSON(http.StatusOK, tree)</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">package useraccess

import (
        "github.com/labstack/echo/v4"
        "go.uber.org/fx"

        "github.com/emergent/emergent-core/pkg/auth"
)

// Module provides the user access domain
var Module = fx.Module("useraccess",
        fx.Provide(NewService),
        fx.Provide(NewHandler),
        fx.Invoke(RegisterRoutes),
)

// RegisterRoutes registers the user access routes
func RegisterRoutes(e *echo.Echo, h *Handler, authMiddleware *auth.Middleware) <span class="cov0" title="0">{
        // GET /api/user/orgs-and-projects - authenticated endpoint
        // Note: /api prefix matches frontend expectations
        e.GET("/api/user/orgs-and-projects", h.GetOrgsAndProjects, authMiddleware.RequireAuth())
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">// Package useraccess handles user access tree (orgs and projects with roles)
package useraccess

import (
        "context"

        "github.com/uptrace/bun"
)

// ProjectWithRole represents a project with the user's role
type ProjectWithRole struct {
        ID                string                 `json:"id"`
        Name              string                 `json:"name"`
        OrgID             string                 `json:"orgId"`
        Role              string                 `json:"role"`
        KBPurpose         *string                `json:"kb_purpose,omitempty"`
        AutoExtractConfig map[string]interface{} `json:"auto_extract_config,omitempty"`
}

// OrgWithProjects represents an organization with its projects
type OrgWithProjects struct {
        ID       string            `json:"id"`
        Name     string            `json:"name"`
        Role     string            `json:"role"`
        Projects []ProjectWithRole `json:"projects"`
}

// Service handles user access operations
type Service struct {
        db bun.IDB
}

// NewService creates a new user access service
func NewService(db bun.IDB) *Service <span class="cov0" title="0">{
        return &amp;Service{db: db}
}</span>

type orgRow struct {
        OrgID   string `bun:"org_id"`
        OrgName string `bun:"org_name"`
        Role    string `bun:"role"`
}

type projectRow struct {
        ProjectID         string                 `bun:"project_id"`
        ProjectName       string                 `bun:"project_name"`
        OrgID             string                 `bun:"org_id"`
        Role              string                 `bun:"role"`
        KBPurpose         *string                `bun:"kb_purpose"`
        AutoExtractConfig map[string]interface{} `bun:"auto_extract_config,type:jsonb"`
}

// GetAccessTree returns the complete access tree for a user
func (s *Service) GetAccessTree(ctx context.Context, userID string) ([]OrgWithProjects, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return []OrgWithProjects{}, nil
        }</span>

        // Query organizations with membership
        <span class="cov0" title="0">var orgRows []orgRow
        err := s.db.NewRaw(`
                SELECT o.id as org_id, o.name as org_name, om.role
                FROM kb.orgs o
                INNER JOIN kb.organization_memberships om ON o.id = om.organization_id
                WHERE om.user_id = ?
                ORDER BY o.created_at DESC
        `, userID).Scan(ctx, &amp;orgRows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Query projects with membership
        <span class="cov0" title="0">var projectRows []projectRow
        err = s.db.NewRaw(`
                SELECT p.id as project_id, p.name as project_name, p.organization_id as org_id,
                       pm.role, p.kb_purpose, p.auto_extract_config
                FROM kb.projects p
                INNER JOIN kb.project_memberships pm ON p.id = pm.project_id
                WHERE pm.user_id = ?
                ORDER BY p.created_at DESC
        `, userID).Scan(ctx, &amp;projectRows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Build hierarchical structure
        <span class="cov0" title="0">orgsMap := make(map[string]*OrgWithProjects)

        // Initialize all orgs
        for _, org := range orgRows </span><span class="cov0" title="0">{
                orgsMap[org.OrgID] = &amp;OrgWithProjects{
                        ID:       org.OrgID,
                        Name:     org.OrgName,
                        Role:     org.Role,
                        Projects: []ProjectWithRole{},
                }
        }</span>

        // Add projects to their parent organizations
        <span class="cov0" title="0">for _, proj := range projectRows </span><span class="cov0" title="0">{
                if org, ok := orgsMap[proj.OrgID]; ok </span><span class="cov0" title="0">{
                        project := ProjectWithRole{
                                ID:    proj.ProjectID,
                                Name:  proj.ProjectName,
                                OrgID: proj.OrgID,
                                Role:  proj.Role,
                        }
                        if proj.KBPurpose != nil </span><span class="cov0" title="0">{
                                project.KBPurpose = proj.KBPurpose
                        }</span>
                        <span class="cov0" title="0">if proj.AutoExtractConfig != nil </span><span class="cov0" title="0">{
                                project.AutoExtractConfig = proj.AutoExtractConfig
                        }</span>
                        <span class="cov0" title="0">org.Projects = append(org.Projects, project)</span>
                }
        }

        // Convert to slice maintaining order
        <span class="cov0" title="0">result := make([]OrgWithProjects, 0, len(orgRows))
        for _, org := range orgRows </span><span class="cov0" title="0">{
                result = append(result, *orgsMap[org.OrgID])
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">package userprofile

import (
        "time"

        "github.com/uptrace/bun"
)

// Profile represents a user profile from core.user_profiles
type Profile struct {
        bun.BaseModel `bun:"table:core.user_profiles,alias:up"`

        ID              string     `bun:"id,pk,type:uuid"`
        ZitadelUserID   string     `bun:"zitadel_user_id"`
        FirstName       *string    `bun:"first_name"`
        LastName        *string    `bun:"last_name"`
        DisplayName     *string    `bun:"display_name"`
        PhoneE164       *string    `bun:"phone_e164"`
        AvatarObjectKey *string    `bun:"avatar_object_key"`
        CreatedAt       time.Time  `bun:"created_at"`
        UpdatedAt       time.Time  `bun:"updated_at"`
        DeletedAt       *time.Time `bun:"deleted_at"`
        DeletedBy       *string    `bun:"deleted_by,type:uuid"`
}

// ProfileDTO is the response DTO for the user profile endpoint
type ProfileDTO struct {
        ID              string  `json:"id"`
        SubjectID       string  `json:"subjectId"`
        ZitadelUserID   *string `json:"zitadelUserId,omitempty"`
        FirstName       *string `json:"firstName,omitempty"`
        LastName        *string `json:"lastName,omitempty"`
        DisplayName     *string `json:"displayName,omitempty"`
        PhoneE164       *string `json:"phoneE164,omitempty"`
        AvatarObjectKey *string `json:"avatarObjectKey,omitempty"`
        Email           string  `json:"email,omitempty"`
}

// UpdateProfileRequest is the request body for updating profile
type UpdateProfileRequest struct {
        FirstName   *string `json:"firstName,omitempty"`
        LastName    *string `json:"lastName,omitempty"`
        DisplayName *string `json:"displayName,omitempty"`
        PhoneE164   *string `json:"phoneE164,omitempty"`
}

// ToDTO converts a Profile entity to ProfileDTO
func (p *Profile) ToDTO(email string) ProfileDTO <span class="cov8" title="1">{
        return ProfileDTO{
                ID:              p.ID,
                SubjectID:       p.ZitadelUserID,
                ZitadelUserID:   &amp;p.ZitadelUserID,
                FirstName:       p.FirstName,
                LastName:        p.LastName,
                DisplayName:     p.DisplayName,
                PhoneE164:       p.PhoneE164,
                AvatarObjectKey: p.AvatarObjectKey,
                Email:           email,
        }
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package userprofile

import (
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

// Handler handles HTTP requests for user profiles
type Handler struct {
        svc *Service
}

// NewHandler creates a new user profile handler
func NewHandler(svc *Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{svc: svc}
}</span>

// Get returns the current user's profile
// GET /api/v2/user/profile
func (h *Handler) Get(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">profile, err := h.svc.GetByID(c.Request().Context(), user.ID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, profile)</span>
}

// Update updates the current user's profile
// PUT /api/v2/user/profile
func (h *Handler) Update(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">var req UpdateProfileRequest
        if err := c.Bind(&amp;req); err != nil </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("invalid request body")
        }</span>

        // Validate request - at least one field should be provided
        <span class="cov8" title="1">if req.FirstName == nil &amp;&amp; req.LastName == nil &amp;&amp; req.DisplayName == nil &amp;&amp; req.PhoneE164 == nil </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("at least one field must be provided")
        }</span>

        // Validate field lengths if provided
        <span class="cov8" title="1">if req.FirstName != nil &amp;&amp; len(*req.FirstName) &gt; 100 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("firstName must be at most 100 characters")
        }</span>
        <span class="cov8" title="1">if req.LastName != nil &amp;&amp; len(*req.LastName) &gt; 100 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("lastName must be at most 100 characters")
        }</span>
        <span class="cov8" title="1">if req.DisplayName != nil &amp;&amp; len(*req.DisplayName) &gt; 200 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("displayName must be at most 200 characters")
        }</span>
        <span class="cov8" title="1">if req.PhoneE164 != nil &amp;&amp; len(*req.PhoneE164) &gt; 20 </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("phoneE164 must be at most 20 characters")
        }</span>

        <span class="cov8" title="1">profile, err := h.svc.Update(c.Request().Context(), user.ID, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, profile)</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package userprofile

import (
        "context"
        "database/sql"
        "errors"
        "log/slog"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Repository handles database operations for user profiles
type Repository struct {
        db  bun.IDB
        log *slog.Logger
}

// NewRepository creates a new user profile repository
func NewRepository(db bun.IDB, log *slog.Logger) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                db:  db,
                log: log.With(logger.Scope("userprofile.repo")),
        }
}</span>

// GetByID retrieves a user profile by internal ID
func (r *Repository) GetByID(ctx context.Context, id string) (*Profile, error) <span class="cov8" title="1">{
        var profile Profile
        err := r.db.NewSelect().
                Model(&amp;profile).
                Where("id = ?", id).
                Where("deleted_at IS NULL").
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, apperror.ErrNotFound.WithMessage("user profile not found")
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to get profile by id", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return &amp;profile, nil</span>
}

// GetByZitadelUserID retrieves a user profile by Zitadel user ID
func (r *Repository) GetByZitadelUserID(ctx context.Context, zitadelUserID string) (*Profile, error) <span class="cov0" title="0">{
        var profile Profile
        err := r.db.NewSelect().
                Model(&amp;profile).
                Where("zitadel_user_id = ?", zitadelUserID).
                Where("deleted_at IS NULL").
                Scan(ctx)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, apperror.ErrNotFound.WithMessage("user profile not found")
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to get profile by zitadel user id", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov0" title="0">return &amp;profile, nil</span>
}

// Update updates a user profile
func (r *Repository) Update(ctx context.Context, id string, req *UpdateProfileRequest) (*Profile, error) <span class="cov8" title="1">{
        // Build update query dynamically based on provided fields
        query := r.db.NewUpdate().
                Model((*Profile)(nil)).
                Where("id = ?", id).
                Where("deleted_at IS NULL").
                Set("updated_at = ?", time.Now())

        // Only update fields that are provided (not nil)
        if req.FirstName != nil </span><span class="cov8" title="1">{
                query = query.Set("first_name = ?", req.FirstName)
        }</span>
        <span class="cov8" title="1">if req.LastName != nil </span><span class="cov8" title="1">{
                query = query.Set("last_name = ?", req.LastName)
        }</span>
        <span class="cov8" title="1">if req.DisplayName != nil </span><span class="cov8" title="1">{
                query = query.Set("display_name = ?", req.DisplayName)
        }</span>
        <span class="cov8" title="1">if req.PhoneE164 != nil </span><span class="cov8" title="1">{
                query = query.Set("phone_e164 = ?", req.PhoneE164)
        }</span>

        <span class="cov8" title="1">result, err := query.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                r.log.Error("failed to update profile", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)
        }</span>

        <span class="cov8" title="1">rowsAffected, _ := result.RowsAffected()
        if rowsAffected == 0 </span><span class="cov0" title="0">{
                return nil, apperror.ErrNotFound.WithMessage("user profile not found")
        }</span>

        // Fetch and return the updated profile
        <span class="cov8" title="1">return r.GetByID(ctx, id)</span>
}

// GetEmail retrieves the primary verified email for a user
func (r *Repository) GetEmail(ctx context.Context, userID string) (string, error) <span class="cov8" title="1">{
        var email string
        err := r.db.NewSelect().
                TableExpr("core.user_emails").
                Column("email").
                Where("user_id = ?", userID).
                Where("verified = true").
                OrderExpr("created_at ASC"). // First verified email is primary
                Limit(1).
                Scan(ctx, &amp;email)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return "", nil
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }
        <span class="cov8" title="1">return email, nil</span>
}
</pre>
		
		<pre class="file" id="file96" style="display: none">package userprofile

import (
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/auth"
)

// RegisterRoutes registers the user profile routes
func RegisterRoutes(e *echo.Echo, h *Handler, authMiddleware *auth.Middleware) <span class="cov8" title="1">{
        g := e.Group("/api/v2/user/profile")
        g.Use(authMiddleware.RequireAuth())

        g.GET("", h.Get)
        g.PUT("", h.Update)
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package userprofile

import (
        "context"
        "log/slog"

        "github.com/emergent/emergent-core/pkg/logger"
)

// Service handles business logic for user profiles
type Service struct {
        repo *Repository
        log  *slog.Logger
}

// NewService creates a new user profile service
func NewService(repo *Repository, log *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: repo,
                log:  log.With(logger.Scope("userprofile.svc")),
        }
}</span>

// GetByID retrieves a user profile by internal ID and returns as DTO
func (s *Service) GetByID(ctx context.Context, id string) (*ProfileDTO, error) <span class="cov8" title="1">{
        profile, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fetch email
        <span class="cov8" title="1">email, _ := s.repo.GetEmail(ctx, profile.ID)

        dto := profile.ToDTO(email)
        return &amp;dto, nil</span>
}

// GetByZitadelUserID retrieves a user profile by Zitadel user ID and returns as DTO
func (s *Service) GetByZitadelUserID(ctx context.Context, zitadelUserID string) (*ProfileDTO, error) <span class="cov0" title="0">{
        profile, err := s.repo.GetByZitadelUserID(ctx, zitadelUserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fetch email
        <span class="cov0" title="0">email, _ := s.repo.GetEmail(ctx, profile.ID)

        dto := profile.ToDTO(email)
        return &amp;dto, nil</span>
}

// Update updates a user profile and returns the updated DTO
func (s *Service) Update(ctx context.Context, id string, req *UpdateProfileRequest) (*ProfileDTO, error) <span class="cov8" title="1">{
        profile, err := s.repo.Update(ctx, id, req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Fetch email
        <span class="cov8" title="1">email, _ := s.repo.GetEmail(ctx, profile.ID)

        dto := profile.ToDTO(email)
        return &amp;dto, nil</span>
}
</pre>
		
		<pre class="file" id="file98" style="display: none">package users

import (
        "net/http"

        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
)

// Handler handles HTTP requests for users
type Handler struct {
        svc *Service
}

// NewHandler creates a new users handler
func NewHandler(svc *Service) *Handler <span class="cov8" title="1">{
        return &amp;Handler{svc: svc}
}</span>

// Search searches for users by email
// GET /api/v2/users/search?email=&lt;query&gt;
func (h *Handler) Search(c echo.Context) error <span class="cov8" title="1">{
        user := auth.GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return apperror.ErrUnauthorized
        }</span>

        <span class="cov8" title="1">emailQuery := c.QueryParam("email")
        if emailQuery == "" </span><span class="cov8" title="1">{
                return apperror.ErrBadRequest.WithMessage("email query parameter is required")
        }</span>

        // Exclude the current user from search results
        <span class="cov8" title="1">excludeUserID := &amp;user.ID

        result, err := h.svc.SearchByEmail(c.Request().Context(), emailQuery, excludeUserID)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return c.JSON(http.StatusOK, result)</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package users

import (
        "context"
        "database/sql"
        "errors"
        "log/slog"
        "strings"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Repository handles database operations for users
type Repository struct {
        db  bun.IDB
        log *slog.Logger
}

// NewRepository creates a new users repository
func NewRepository(db bun.IDB, log *slog.Logger) *Repository <span class="cov8" title="1">{
        return &amp;Repository{
                db:  db,
                log: log.With(logger.Scope("users.repo")),
        }
}</span>

// SearchByEmail searches for users by email (partial match)
// Returns up to 10 results, optionally excluding a specific user
func (r *Repository) SearchByEmail(ctx context.Context, emailQuery string, excludeUserID *string) ([]UserSearchResult, error) <span class="cov8" title="1">{
        // Normalize and prepare the search pattern
        emailQuery = strings.TrimSpace(strings.ToLower(emailQuery))
        if len(emailQuery) &lt; 2 </span><span class="cov0" title="0">{
                return []UserSearchResult{}, nil
        }</span>

        // Use ILIKE for case-insensitive partial match
        <span class="cov8" title="1">pattern := "%" + emailQuery + "%"

        // Query to find users by email with their profile info
        // Join user_profiles with user_emails to get email and profile data
        query := r.db.NewSelect().
                TableExpr("core.user_emails AS ue").
                ColumnExpr("up.id").
                ColumnExpr("ue.email").
                ColumnExpr("up.display_name").
                ColumnExpr("up.first_name").
                ColumnExpr("up.last_name").
                ColumnExpr("up.avatar_object_key").
                Join("INNER JOIN core.user_profiles AS up ON up.id = ue.user_id").
                Where("ue.email ILIKE ?", pattern).
                Where("ue.verified = true").
                Where("up.deleted_at IS NULL").
                OrderExpr("ue.email ASC").
                Limit(10)

        // Optionally exclude a user (e.g., the current user)
        if excludeUserID != nil &amp;&amp; *excludeUserID != "" </span><span class="cov8" title="1">{
                query = query.Where("up.id != ?", *excludeUserID)
        }</span>

        <span class="cov8" title="1">var results []UserSearchResult
        err := query.Scan(ctx, &amp;results)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return []UserSearchResult{}, nil
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to search users by email", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// FindByEmail finds a user by exact email match
func (r *Repository) FindByEmail(ctx context.Context, email string) (*UserSearchResult, error) <span class="cov0" title="0">{
        email = strings.TrimSpace(strings.ToLower(email))

        var result UserSearchResult
        err := r.db.NewSelect().
                TableExpr("core.user_emails AS ue").
                ColumnExpr("up.id").
                ColumnExpr("ue.email").
                ColumnExpr("up.display_name").
                ColumnExpr("up.first_name").
                ColumnExpr("up.last_name").
                ColumnExpr("up.avatar_object_key").
                Join("INNER JOIN core.user_profiles AS up ON up.id = ue.user_id").
                Where("ue.email = ?", email).
                Where("ue.verified = true").
                Where("up.deleted_at IS NULL").
                Limit(1).
                Scan(ctx, &amp;result)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil // Not found, not an error
                }</span>
                <span class="cov0" title="0">r.log.Error("failed to find user by email", logger.Error(err))
                return nil, apperror.ErrDatabase.WithInternal(err)</span>
        }

        <span class="cov0" title="0">return &amp;result, nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">package users

import (
        "github.com/labstack/echo/v4"

        "github.com/emergent/emergent-core/pkg/auth"
)

// RegisterRoutes registers the users routes
func RegisterRoutes(e *echo.Echo, h *Handler, authMiddleware *auth.Middleware) <span class="cov8" title="1">{
        g := e.Group("/api/v2/users")
        g.Use(authMiddleware.RequireAuth())
        g.Use(authMiddleware.RequireScopes("org:read")) // Same scope as NestJS

        g.GET("/search", h.Search)
}</span>
</pre>
		
		<pre class="file" id="file101" style="display: none">package users

import (
        "context"
        "log/slog"

        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

// Service handles business logic for users
type Service struct {
        repo *Repository
        log  *slog.Logger
}

// NewService creates a new users service
func NewService(repo *Repository, log *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                repo: repo,
                log:  log.With(logger.Scope("users.svc")),
        }
}</span>

// SearchByEmail searches for users by email (partial match)
// Requires at least 2 characters in the query
func (s *Service) SearchByEmail(ctx context.Context, emailQuery string, excludeUserID *string) (*UserSearchResponse, error) <span class="cov8" title="1">{
        if len(emailQuery) &lt; 2 </span><span class="cov8" title="1">{
                return nil, apperror.ErrBadRequest.WithMessage("email query must be at least 2 characters")
        }</span>

        <span class="cov8" title="1">results, err := s.repo.SearchByEmail(ctx, emailQuery, excludeUserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Ensure we return empty slice, not nil
        <span class="cov8" title="1">if results == nil </span><span class="cov8" title="1">{
                results = []UserSearchResult{}
        }</span>

        <span class="cov8" title="1">return &amp;UserSearchResponse{
                Users: results,
        }, nil</span>
}

// FindByEmail finds a user by exact email match
func (s *Service) FindByEmail(ctx context.Context, email string) (*UserSearchResult, error) <span class="cov0" title="0">{
        return s.repo.FindByEmail(ctx, email)
}</span>
</pre>
		
		<pre class="file" id="file102" style="display: none">package config

import (
        "fmt"
        "log/slog"
        "time"

        "github.com/caarlos0/env/v11"
        "go.uber.org/fx"
)

var Module = fx.Module("config",
        fx.Provide(NewConfig),
)

// Config holds all application configuration
type Config struct {
        // Server settings
        ServerPort    int    `env:"SERVER_PORT" envDefault:"3002"`
        ServerAddress string `env:"SERVER_ADDRESS" envDefault:"0.0.0.0"`
        Environment   string `env:"ENVIRONMENT" envDefault:"local"`
        Debug         bool   `env:"DEBUG" envDefault:"false"`
        LogLevel      string `env:"LOG_LEVEL" envDefault:"info"`

        // Database settings (matches NestJS POSTGRES_* vars)
        Database DatabaseConfig

        // Zitadel authentication
        Zitadel ZitadelConfig

        // Embeddings configuration
        Embeddings EmbeddingsConfig

        // LLM configuration (for chat completions)
        LLM LLMConfig

        // Email configuration
        Email EmailConfig

        // Kreuzberg document parsing configuration
        Kreuzberg KreuzbergConfig

        // Storage configuration
        Storage StorageConfig

        // Server timeouts
        ReadTimeout     time.Duration `env:"SERVER_READ_TIMEOUT" envDefault:"5s"`
        WriteTimeout    time.Duration `env:"SERVER_WRITE_TIMEOUT" envDefault:"10s"`
        IdleTimeout     time.Duration `env:"SERVER_IDLE_TIMEOUT" envDefault:"120s"`
        ShutdownTimeout time.Duration `env:"SHUTDOWN_TIMEOUT" envDefault:"10s"`
}

// DatabaseConfig holds PostgreSQL connection settings
type DatabaseConfig struct {
        Host         string        `env:"POSTGRES_HOST" envDefault:"localhost"`
        Port         int           `env:"POSTGRES_PORT" envDefault:"5432"`
        User         string        `env:"POSTGRES_USER" envDefault:"emergent"`
        Password     string        `env:"POSTGRES_PASSWORD" envDefault:""`
        Database     string        `env:"POSTGRES_DB" envDefault:"emergent"`
        SSLMode      string        `env:"POSTGRES_SSL_MODE" envDefault:"disable"`
        MaxOpenConns int           `env:"DB_MAX_OPEN_CONNS" envDefault:"25"`
        MaxIdleConns int           `env:"DB_MAX_IDLE_CONNS" envDefault:"5"`
        MaxIdleTime  time.Duration `env:"DB_MAX_IDLE_TIME" envDefault:"5m"`
        QueryDebug   bool          `env:"DB_QUERY_DEBUG" envDefault:"false"`
}

// DSN returns the PostgreSQL connection string
func (d *DatabaseConfig) DSN() string <span class="cov8" title="1">{
        return fmt.Sprintf(
                "postgres://%s:%s@%s:%d/%s?sslmode=%s",
                d.User, d.Password, d.Host, d.Port, d.Database, d.SSLMode,
        )
}</span>

// ZitadelConfig holds Zitadel/OIDC authentication settings
type ZitadelConfig struct {
        // Domain for Zitadel instance (e.g., "zitadel.dev.emergent-company.ai")
        Domain string `env:"ZITADEL_DOMAIN" envDefault:"localhost:8080"`

        // Issuer URL for OIDC (defaults to https://{Domain} if not set)
        Issuer string `env:"ZITADEL_ISSUER"`

        // Service account JWT key for introspection (JSON key file content)
        ClientJWT string `env:"ZITADEL_CLIENT_JWT"`

        // Path to JWT key file (alternative to ZITADEL_CLIENT_JWT)
        ClientJWTPath string `env:"ZITADEL_CLIENT_JWT_PATH"`

        // API JWT for management API calls (JSON key file content)
        APIJWT string `env:"ZITADEL_API_JWT"`

        // Path to API JWT key file (alternative to ZITADEL_API_JWT)
        APIJWTPath string `env:"ZITADEL_API_JWT_PATH"`

        // Organization ID for role checks
        MainOrgID string `env:"ZITADEL_MAIN_ORG_ID"`

        // Project ID for scopes
        ProjectID string `env:"ZITADEL_PROJECT_ID"`

        // Organization ID (alias for compatibility)
        OrgID string `env:"ZITADEL_ORG_ID"`

        // Disable token introspection (for testing)
        DisableIntrospection bool `env:"DISABLE_ZITADEL_INTROSPECTION" envDefault:"false"`

        // Introspection cache TTL
        IntrospectCacheTTL time.Duration `env:"ZITADEL_INTROSPECT_CACHE_TTL" envDefault:"5m"`

        // Debug token for development (bypasses auth)
        DebugToken string `env:"ZITADEL_DEBUG_TOKEN"`

        // Insecure mode (HTTP instead of HTTPS)
        Insecure bool `env:"ZITADEL_INSECURE" envDefault:"false"`
}

// EmbeddingsConfig holds embedding service configuration
type EmbeddingsConfig struct {
        // Provider: "vertex" (production) or "genai" (development)
        Provider string `env:"EMBEDDING_PROVIDER" envDefault:""`

        // GCP Project ID for Vertex AI
        GCPProjectID string `env:"GCP_PROJECT_ID" envDefault:""`

        // Vertex AI location (e.g., "us-central1")
        VertexAILocation string `env:"VERTEX_AI_LOCATION" envDefault:"us-central1"`

        // Embedding model name
        Model string `env:"EMBEDDING_MODEL" envDefault:"text-embedding-004"`

        // Embedding dimension (768 for text-embedding-004)
        Dimension int `env:"EMBEDDING_DIMENSION" envDefault:"768"`

        // Google API Key for Generative AI (development)
        GoogleAPIKey string `env:"GOOGLE_API_KEY" envDefault:""`

        // Disable embeddings network calls (for testing)
        NetworkDisabled bool `env:"EMBEDDINGS_NETWORK_DISABLED" envDefault:"false"`
}

// IsEnabled returns true if embeddings are configured
func (e *EmbeddingsConfig) IsEnabled() bool <span class="cov8" title="1">{
        if e.NetworkDisabled </span><span class="cov8" title="1">{
                return false
        }</span>
        // Enabled if Vertex AI is configured OR Google API Key is set
        <span class="cov8" title="1">return (e.GCPProjectID != "" &amp;&amp; e.VertexAILocation != "") || e.GoogleAPIKey != ""</span>
}

// UseVertexAI returns true if Vertex AI should be used
func (e *EmbeddingsConfig) UseVertexAI() bool <span class="cov8" title="1">{
        return e.GCPProjectID != "" &amp;&amp; e.VertexAILocation != ""
}</span>

// LLMConfig holds LLM (chat completion) configuration
type LLMConfig struct {
        // GCP Project ID for Vertex AI (reuses EMBEDDING_PROVIDER's GCP_PROJECT_ID)
        GCPProjectID string `env:"GCP_PROJECT_ID" envDefault:""`

        // Vertex AI location (e.g., "us-central1")
        VertexAILocation string `env:"VERTEX_AI_LOCATION" envDefault:"us-central1"`

        // Chat model name
        Model string `env:"VERTEX_AI_MODEL" envDefault:"gemini-2.5-flash-preview"`

        // Max output tokens for chat completions
        MaxOutputTokens int `env:"LLM_MAX_OUTPUT_TOKENS" envDefault:"8192"`

        // Temperature for chat completions (0.0-1.0)
        Temperature float64 `env:"LLM_TEMPERATURE" envDefault:"0"`

        // Request timeout
        Timeout time.Duration `env:"LLM_TIMEOUT" envDefault:"120s"`

        // Disable LLM network calls (for testing)
        NetworkDisabled bool `env:"LLM_NETWORK_DISABLED" envDefault:"false"`
}

// IsEnabled returns true if LLM is configured
func (l *LLMConfig) IsEnabled() bool <span class="cov8" title="1">{
        if l.NetworkDisabled </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return l.GCPProjectID != "" &amp;&amp; l.VertexAILocation != ""</span>
}

// EmailConfig holds email service configuration
type EmailConfig struct {
        // Enabled determines if email sending is enabled
        Enabled bool `env:"EMAIL_ENABLED" envDefault:"false"`
        // MailgunDomain is the Mailgun domain
        MailgunDomain string `env:"MAILGUN_DOMAIN" envDefault:""`
        // MailgunAPIKey is the Mailgun API key
        MailgunAPIKey string `env:"MAILGUN_API_KEY" envDefault:""`
        // FromEmail is the default from email address
        FromEmail string `env:"EMAIL_FROM_ADDRESS" envDefault:"noreply@example.com"`
        // FromName is the default from name
        FromName string `env:"EMAIL_FROM_NAME" envDefault:"Emergent"`
        // MaxRetries is the maximum number of retry attempts (default: 3)
        MaxRetries int `env:"EMAIL_MAX_RETRIES" envDefault:"3"`
        // RetryDelaySec is the base delay in seconds for retries (default: 60)
        RetryDelaySec int `env:"EMAIL_RETRY_DELAY_SEC" envDefault:"60"`
        // WorkerIntervalMs is the polling interval in milliseconds (default: 5000)
        WorkerIntervalMs int `env:"EMAIL_WORKER_INTERVAL_MS" envDefault:"5000"`
        // WorkerBatchSize is the number of jobs to process per poll (default: 10)
        WorkerBatchSize int `env:"EMAIL_WORKER_BATCH_SIZE" envDefault:"10"`
}

// IsConfigured returns true if Mailgun is configured
func (e *EmailConfig) IsConfigured() bool <span class="cov8" title="1">{
        return e.MailgunDomain != "" &amp;&amp; e.MailgunAPIKey != ""
}</span>

// KreuzbergConfig holds Kreuzberg document parsing service configuration
type KreuzbergConfig struct {
        // Enabled determines if Kreuzberg parsing is enabled
        Enabled bool `env:"KREUZBERG_ENABLED" envDefault:"true"`
        // ServiceURL is the Kreuzberg service URL
        ServiceURL string `env:"KREUZBERG_SERVICE_URL" envDefault:"http://localhost:8000"`
        // Timeout is the request timeout in milliseconds (default: 300000 = 5 minutes)
        TimeoutMs int `env:"KREUZBERG_SERVICE_TIMEOUT" envDefault:"300000"`
        // MaxFileSizeMB is the maximum file size for document parsing
        MaxFileSizeMB int `env:"KREUZBERG_MAX_FILE_SIZE_MB" envDefault:"100"`
        // WorkerIntervalMs is the polling interval in milliseconds (default: 5000)
        WorkerIntervalMs int `env:"DOCUMENT_PARSING_WORKER_INTERVAL_MS" envDefault:"5000"`
        // WorkerBatchSize is the number of jobs to process per poll (default: 5)
        WorkerBatchSize int `env:"DOCUMENT_PARSING_WORKER_BATCH_SIZE" envDefault:"5"`
}

// Timeout returns the request timeout as a Duration
func (k *KreuzbergConfig) Timeout() time.Duration <span class="cov8" title="1">{
        return time.Duration(k.TimeoutMs) * time.Millisecond
}</span>

// WorkerInterval returns the worker interval as a Duration
func (k *KreuzbergConfig) WorkerInterval() time.Duration <span class="cov8" title="1">{
        return time.Duration(k.WorkerIntervalMs) * time.Millisecond
}</span>

// StorageConfig holds storage (MinIO/S3) configuration
type StorageConfig struct {
        // Endpoint is the MinIO/S3 endpoint URL
        Endpoint string `env:"MINIO_ENDPOINT" envDefault:"localhost:9000"`
        // AccessKeyID is the access key ID
        AccessKeyID string `env:"MINIO_ACCESS_KEY" envDefault:""`
        // SecretAccessKey is the secret access key
        SecretAccessKey string `env:"MINIO_SECRET_KEY" envDefault:""`
        // Bucket is the bucket name
        Bucket string `env:"MINIO_BUCKET" envDefault:"emergent"`
        // UseSSL determines if SSL should be used
        UseSSL bool `env:"MINIO_USE_SSL" envDefault:"false"`
        // Region is the bucket region (for S3 compatibility)
        Region string `env:"MINIO_REGION" envDefault:"us-east-1"`
}

// IsConfigured returns true if storage is configured
func (s *StorageConfig) IsConfigured() bool <span class="cov8" title="1">{
        return s.Endpoint != "" &amp;&amp; s.AccessKeyID != "" &amp;&amp; s.SecretAccessKey != ""
}</span>

// GetIssuer returns the issuer URL, defaulting to https://{Domain}
func (z *ZitadelConfig) GetIssuer() string <span class="cov8" title="1">{
        if z.Issuer != "" </span><span class="cov8" title="1">{
                return z.Issuer
        }</span>
        <span class="cov8" title="1">if z.Insecure </span><span class="cov8" title="1">{
                return fmt.Sprintf("http://%s", z.Domain)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("https://%s", z.Domain)</span>
}

// NewConfig loads configuration from environment variables
func NewConfig(log *slog.Logger) (*Config, error) <span class="cov8" title="1">{
        cfg := &amp;Config{}
        if err := env.Parse(cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config: %w", err)
        }</span>

        <span class="cov8" title="1">log.Info("configuration loaded",
                slog.String("environment", cfg.Environment),
                slog.Int("port", cfg.ServerPort),
                slog.String("db_host", cfg.Database.Host),
                slog.String("zitadel_domain", cfg.Zitadel.Domain),
        )

        return cfg, nil</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/jackc/pgx/v5/stdlib"
        "github.com/uptrace/bun"
        "github.com/uptrace/bun/dialect/pgdialect"
        "go.uber.org/fx"

        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/pkg/logger"
)

var Module = fx.Module("database",
        fx.Provide(
                NewPgxPool,
                NewBunDB,
                // Provide bun.IDB interface binding for modules that use the interface
                fx.Annotate(
                        func(db *bun.DB) bun.IDB <span class="cov0" title="0">{ return db }</span>,
                        fx.As(new(bun.IDB)),
                ),
        ),
)

// NewPgxPool creates a new pgx connection pool
func NewPgxPool(lc fx.Lifecycle, cfg *config.Config, log *slog.Logger) (*pgxpool.Pool, error) <span class="cov0" title="0">{
        log = log.With(logger.Scope("database"))

        poolConfig, err := pgxpool.ParseConfig(cfg.Database.DSN())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse pgx config: %w", err)
        }</span>

        // Configure pool settings
        <span class="cov0" title="0">poolConfig.MaxConns = int32(cfg.Database.MaxOpenConns)
        poolConfig.MinConns = int32(cfg.Database.MaxIdleConns)
        poolConfig.MaxConnIdleTime = cfg.Database.MaxIdleTime

        // Create pool
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        pool, err := pgxpool.NewWithConfig(ctx, poolConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create pgx pool: %w", err)
        }</span>

        // Verify connection
        <span class="cov0" title="0">if err := pool.Ping(ctx); err != nil </span><span class="cov0" title="0">{
                pool.Close()
                return nil, fmt.Errorf("ping database: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info("database pool created",
                slog.String("host", cfg.Database.Host),
                slog.Int("port", cfg.Database.Port),
                slog.String("database", cfg.Database.Database),
                slog.Int("max_conns", cfg.Database.MaxOpenConns),
        )

        // Register lifecycle hooks
        lc.Append(fx.Hook{
                OnStop: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        log.Info("closing database pool")
                        pool.Close()
                        return nil
                }</span>,
        })

        <span class="cov0" title="0">return pool, nil</span>
}

// NewBunDB creates a Bun ORM instance wrapping the pgx pool
func NewBunDB(lc fx.Lifecycle, pool *pgxpool.Pool, cfg *config.Config, log *slog.Logger) (*bun.DB, error) <span class="cov0" title="0">{
        log = log.With(logger.Scope("bun"))

        // Convert pgx pool to database/sql compatible connection
        sqldb := stdlib.OpenDBFromPool(pool)

        // Create Bun DB with PostgreSQL dialect
        db := bun.NewDB(sqldb, pgdialect.New())

        // Add query logging hook if debug enabled
        if cfg.Database.QueryDebug </span><span class="cov0" title="0">{
                db.AddQueryHook(&amp;queryLoggingHook{log: log})
        }</span>

        <span class="cov0" title="0">log.Info("bun database initialized")

        // Register lifecycle hooks
        lc.Append(fx.Hook{
                OnStop: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        log.Info("closing bun database")
                        return db.Close()
                }</span>,
        })

        <span class="cov0" title="0">return db, nil</span>
}

// queryLoggingHook implements bun.QueryHook for query logging
type queryLoggingHook struct {
        log *slog.Logger
}

func (h *queryLoggingHook) BeforeQuery(ctx context.Context, event *bun.QueryEvent) context.Context <span class="cov0" title="0">{
        return ctx
}</span>

func (h *queryLoggingHook) AfterQuery(ctx context.Context, event *bun.QueryEvent) <span class="cov0" title="0">{
        duration := time.Since(event.StartTime)

        if event.Err != nil &amp;&amp; event.Err != sql.ErrNoRows </span><span class="cov0" title="0">{
                h.log.Error("query error",
                        slog.String("query", event.Query),
                        slog.Duration("duration", duration),
                        logger.Error(event.Err),
                )
                return
        }</span>

        // Log slow queries as warnings
        <span class="cov0" title="0">if duration &gt; 3*time.Second </span><span class="cov0" title="0">{
                h.log.Warn("slow query",
                        slog.String("query", event.Query),
                        slog.Duration("duration", duration),
                )
                return
        }</span>

        // Debug log all queries
        <span class="cov0" title="0">h.log.Debug("query",
                slog.String("query", event.Query),
                slog.Duration("duration", duration),
        )</span>
}

// SetRLSContext sets the RLS context variables for the current connection
// This must be called within a transaction to be effective
func SetRLSContext(ctx context.Context, db bun.IDB, projectID string) error <span class="cov8" title="1">{
        if projectID == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Set the project ID for RLS policies
        <span class="cov8" title="1">_, err := db.ExecContext(ctx, "SET app.current_project_id = ?", projectID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("set RLS context: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SafeTx wraps a bun.Tx to make Rollback safe to call after Commit.
//
// In PostgreSQL with savepoints (nested transactions), calling ROLLBACK TO SAVEPOINT
// after RELEASE SAVEPOINT causes an error that aborts the outer transaction.
// This wrapper tracks whether Commit was called and makes Rollback a no-op afterwards.
//
// Usage:
//
//        tx, err := BeginSafeTx(ctx, db)
//        if err != nil {
//            return err
//        }
//        defer tx.Rollback() // Safe to call even after Commit
//
//        // ... do work ...
//
//        return tx.Commit()
type SafeTx struct {
        bun.Tx
        committed bool
}

// BeginSafeTx starts a new transaction and returns a SafeTx wrapper.
func BeginSafeTx(ctx context.Context, db bun.IDB) (*SafeTx, error) <span class="cov8" title="1">{
        tx, err := db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;SafeTx{Tx: tx}, nil</span>
}

// Commit commits the transaction and marks it as committed.
func (tx *SafeTx) Commit() error <span class="cov8" title="1">{
        if tx.committed </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">err := tx.Tx.Commit()
        if err == nil </span><span class="cov8" title="1">{
                tx.committed = true
        }</span>
        <span class="cov8" title="1">return err</span>
}

// Rollback rolls back the transaction only if it hasn't been committed.
// This is safe to call in a defer statement even after Commit.
func (tx *SafeTx) Rollback() error <span class="cov8" title="1">{
        if tx.committed </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return tx.Tx.Rollback()</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">// Package jobs provides a PostgreSQL-backed job queue implementation.
//
// This follows the same pattern as the NestJS BaseJobQueueService:
// - Idempotent enqueue (won't create duplicate active jobs)
// - Atomic dequeue with FOR UPDATE SKIP LOCKED
// - Exponential backoff for retries
// - Stale job recovery
// - Queue statistics
package jobs

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "math"
        "time"

        "github.com/uptrace/bun"
)

// JobStatus represents the state of a job
type JobStatus string

const (
        StatusPending    JobStatus = "pending"
        StatusProcessing JobStatus = "processing"
        StatusCompleted  JobStatus = "completed"
        StatusFailed     JobStatus = "failed"
        StatusSent       JobStatus = "sent" // For email jobs specifically
)

// QueueConfig contains configuration for a job queue
type QueueConfig struct {
        // TableName is the fully qualified table name (e.g., "kb.email_jobs")
        TableName string
        // EntityIDColumn is the column name for the entity ID (e.g., "object_id")
        EntityIDColumn string
        // MaxAttempts is the maximum number of retry attempts (0 = unlimited)
        MaxAttempts int
        // BaseRetryDelaySec is the base delay in seconds for retries (default: 60)
        BaseRetryDelaySec int
        // MaxRetryDelaySec is the maximum retry delay in seconds (default: 3600)
        MaxRetryDelaySec int
        // BatchSize is the default number of jobs to dequeue at once (default: 10)
        BatchSize int
}

// DefaultQueueConfig returns a QueueConfig with sensible defaults
func DefaultQueueConfig(tableName, entityIDColumn string) QueueConfig <span class="cov8" title="1">{
        return QueueConfig{
                TableName:         tableName,
                EntityIDColumn:    entityIDColumn,
                MaxAttempts:       0, // unlimited
                BaseRetryDelaySec: 60,
                MaxRetryDelaySec:  3600,
                BatchSize:         10,
        }
}</span>

// Queue provides base job queue operations using PostgreSQL.
// It uses FOR UPDATE SKIP LOCKED for concurrent worker safety.
type Queue struct {
        db     bun.IDB
        config QueueConfig
        log    *slog.Logger
}

// NewQueue creates a new job queue with the given configuration
func NewQueue(db bun.IDB, config QueueConfig, log *slog.Logger) *Queue <span class="cov0" title="0">{
        // Apply defaults
        if config.BaseRetryDelaySec == 0 </span><span class="cov0" title="0">{
                config.BaseRetryDelaySec = 60
        }</span>
        <span class="cov0" title="0">if config.MaxRetryDelaySec == 0 </span><span class="cov0" title="0">{
                config.MaxRetryDelaySec = 3600
        }</span>
        <span class="cov0" title="0">if config.BatchSize == 0 </span><span class="cov0" title="0">{
                config.BatchSize = 10
        }</span>

        <span class="cov0" title="0">return &amp;Queue{
                db:     db,
                config: config,
                log:    log,
        }</span>
}

// DequeueResult contains the IDs of dequeued jobs
type DequeueResult struct {
        IDs []string
}

// Dequeue atomically claims jobs for processing.
//
// Uses PostgreSQL's FOR UPDATE SKIP LOCKED for concurrent workers.
// This is the key pattern that allows multiple workers to safely process jobs
// without conflicts.
//
// SQL Pattern:
//
//        WITH cte AS (
//          SELECT id FROM table
//          WHERE status='pending' AND scheduled_at &lt;= now()
//          ORDER BY priority DESC, scheduled_at ASC
//          FOR UPDATE SKIP LOCKED
//          LIMIT $1
//        )
//        UPDATE table SET status='processing', started_at=now()
//        FROM cte WHERE table.id = cte.id
//        RETURNING id
func (q *Queue) Dequeue(ctx context.Context, batchSize int) ([]string, error) <span class="cov0" title="0">{
        if batchSize &lt;= 0 </span><span class="cov0" title="0">{
                batchSize = q.config.BatchSize
        }</span>

        // This is strategic SQL that cannot be expressed with Bun's query builder
        <span class="cov0" title="0">query := fmt.Sprintf(`
                WITH cte AS (
                        SELECT id FROM %s
                        WHERE status='pending' AND (scheduled_at IS NULL OR scheduled_at &lt;= now())
                        ORDER BY priority DESC, scheduled_at ASC
                        FOR UPDATE SKIP LOCKED
                        LIMIT $1
                )
                UPDATE %s j 
                SET status='processing', started_at=now(), updated_at=now()
                FROM cte WHERE j.id = cte.id
                RETURNING j.id`,
                q.config.TableName, q.config.TableName)

        var ids []string
        _, err := q.db.NewRaw(query, batchSize).Exec(ctx, &amp;ids)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("dequeue failed: %w", err)
        }</span>

        <span class="cov0" title="0">return ids, nil</span>
}

// MarkCompleted marks a job as completed
func (q *Queue) MarkCompleted(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := fmt.Sprintf(`
                UPDATE %s 
                SET status = 'completed', 
                        completed_at = now(), 
                        updated_at = now()
                WHERE id = $1`,
                q.config.TableName)

        _, err := q.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mark completed failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MarkSent marks a job as sent (for email jobs)
func (q *Queue) MarkSent(ctx context.Context, id string) error <span class="cov0" title="0">{
        query := fmt.Sprintf(`
                UPDATE %s 
                SET status = 'sent', 
                        processed_at = now(), 
                        updated_at = now()
                WHERE id = $1`,
                q.config.TableName)

        _, err := q.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mark sent failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// MarkFailed marks a job as failed and schedules for retry with exponential backoff.
// If maxAttempts is configured and reached, the job is permanently marked as failed.
func (q *Queue) MarkFailed(ctx context.Context, id string, attemptCount int, errMsg string) error <span class="cov0" title="0">{
        attempt := attemptCount + 1

        // Check if we've exceeded max attempts
        if q.config.MaxAttempts &gt; 0 &amp;&amp; attempt &gt;= q.config.MaxAttempts </span><span class="cov0" title="0">{
                query := fmt.Sprintf(`
                        UPDATE %s 
                        SET status = 'failed',
                                attempt_count = $2,
                                last_error = $3,
                                updated_at = now()
                        WHERE id = $1`,
                        q.config.TableName)

                _, err := q.db.ExecContext(ctx, query, id, attempt, truncateError(errMsg))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("mark failed (permanent) failed: %w", err)
                }</span>

                <span class="cov0" title="0">q.log.Warn("job permanently failed after max attempts",
                        slog.String("job_id", id),
                        slog.Int("attempts", attempt),
                        slog.String("error", errMsg))

                return nil</span>
        }

        // Calculate exponential backoff: baseDelay * attempt^2, capped at maxRetryDelaySec
        <span class="cov0" title="0">delay := math.Min(
                float64(q.config.MaxRetryDelaySec),
                float64(q.config.BaseRetryDelaySec)*float64(attempt)*float64(attempt),
        )

        query := fmt.Sprintf(`
                UPDATE %s 
                SET status = 'pending',
                        attempt_count = $2,
                        last_error = $3,
                        scheduled_at = now() + ($4 || ' seconds')::interval,
                        updated_at = now()
                WHERE id = $1`,
                q.config.TableName)

        _, err := q.db.ExecContext(ctx, query, id, attempt, truncateError(errMsg), fmt.Sprintf("%d", int(delay)))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("mark failed (retry) failed: %w", err)
        }</span>

        <span class="cov0" title="0">q.log.Debug("job scheduled for retry",
                slog.String("job_id", id),
                slog.Int("attempt", attempt),
                slog.Duration("delay", time.Duration(delay)*time.Second))

        return nil</span>
}

// RecoverStaleJobs recovers jobs stuck in 'processing' status.
// This can happen when the server restarts while jobs are being processed.
// Returns the number of jobs recovered.
func (q *Queue) RecoverStaleJobs(ctx context.Context, staleThresholdMinutes int) (int, error) <span class="cov0" title="0">{
        if staleThresholdMinutes &lt;= 0 </span><span class="cov0" title="0">{
                staleThresholdMinutes = 10
        }</span>

        <span class="cov0" title="0">query := fmt.Sprintf(`
                UPDATE %s 
                SET status = 'pending',
                        started_at = NULL,
                        scheduled_at = now(),
                        updated_at = now()
                WHERE status = 'processing'
                        AND started_at &lt; now() - ($1 || ' minutes')::interval`,
                q.config.TableName)

        result, err := q.db.ExecContext(ctx, query, fmt.Sprintf("%d", staleThresholdMinutes))
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("recover stale jobs failed: %w", err)
        }</span>

        <span class="cov0" title="0">count, _ := result.RowsAffected()

        if count &gt; 0 </span><span class="cov0" title="0">{
                q.log.Warn("recovered stale jobs",
                        slog.Int64("count", count),
                        slog.Int("threshold_minutes", staleThresholdMinutes))
        }</span>

        <span class="cov0" title="0">return int(count), nil</span>
}

// Stats represents queue statistics
type Stats struct {
        Pending    int64 `json:"pending"`
        Processing int64 `json:"processing"`
        Completed  int64 `json:"completed"`
        Failed     int64 `json:"failed"`
}

// GetStats returns queue statistics
func (q *Queue) GetStats(ctx context.Context) (*Stats, error) <span class="cov0" title="0">{
        query := fmt.Sprintf(`
                SELECT 
                        COUNT(*) FILTER (WHERE status = 'pending') as pending,
                        COUNT(*) FILTER (WHERE status = 'processing') as processing,
                        COUNT(*) FILTER (WHERE status = 'completed' OR status = 'sent') as completed,
                        COUNT(*) FILTER (WHERE status = 'failed') as failed
                FROM %s`,
                q.config.TableName)

        stats := &amp;Stats{}
        err := q.db.QueryRowContext(ctx, query).Scan(&amp;stats.Pending, &amp;stats.Processing, &amp;stats.Completed, &amp;stats.Failed)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("get stats failed: %w", err)
        }</span>

        <span class="cov0" title="0">return stats, nil</span>
}

// GetJobByID retrieves a job by its ID. Returns nil if not found.
// The result is scanned into the provided destination.
func (q *Queue) GetJobByID(ctx context.Context, id string, dest interface{}) error <span class="cov0" title="0">{
        query := fmt.Sprintf(`SELECT * FROM %s WHERE id = $1`, q.config.TableName)
        err := q.db.NewRaw(query, id).Scan(ctx, dest)
        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}

// truncateError truncates an error message to 500 characters
func truncateError(msg string) string <span class="cov8" title="1">{
        if len(msg) &gt; 500 </span><span class="cov8" title="1">{
                return msg[:500]
        }</span>
        <span class="cov8" title="1">return msg</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package jobs

import (
        "context"
        "log/slog"
        "sync"
        "time"
)

// WorkerConfig contains configuration for a background worker
type WorkerConfig struct {
        // Name is a descriptive name for the worker (for logging)
        Name string
        // PollInterval is how often to poll for new jobs (default: 5s)
        PollInterval time.Duration
        // BatchSize is the number of jobs to dequeue per poll (default: 10)
        BatchSize int
        // StaleThresholdMinutes is how long a job can be in 'processing' before
        // being considered stale and recovered (default: 10)
        StaleThresholdMinutes int
        // RecoverStaleOnStart determines if stale jobs should be recovered on startup
        RecoverStaleOnStart bool
}

// DefaultWorkerConfig returns a WorkerConfig with sensible defaults
func DefaultWorkerConfig(name string) WorkerConfig <span class="cov8" title="1">{
        return WorkerConfig{
                Name:                  name,
                PollInterval:          5 * time.Second,
                BatchSize:             10,
                StaleThresholdMinutes: 10,
                RecoverStaleOnStart:   true,
        }
}</span>

// Worker is a background worker that processes jobs from a queue.
// It follows the same pattern as NestJS workers:
// - Polling-based with configurable interval
// - Graceful shutdown waiting for current batch
// - Stale job recovery on startup
// - Metrics tracking
type Worker struct {
        config     WorkerConfig
        log        *slog.Logger
        process    func(ctx context.Context) error
        stopCh     chan struct{}
        stoppedCh  chan struct{}
        running    bool
        mu         sync.Mutex
        wg         sync.WaitGroup

        // Metrics
        processedCount int64
        successCount   int64
        failureCount   int64
        metricsMu      sync.RWMutex
}

// NewWorker creates a new background worker
func NewWorker(config WorkerConfig, log *slog.Logger, process func(ctx context.Context) error) *Worker <span class="cov0" title="0">{
        // Apply defaults
        if config.PollInterval == 0 </span><span class="cov0" title="0">{
                config.PollInterval = 5 * time.Second
        }</span>
        <span class="cov0" title="0">if config.BatchSize == 0 </span><span class="cov0" title="0">{
                config.BatchSize = 10
        }</span>
        <span class="cov0" title="0">if config.StaleThresholdMinutes == 0 </span><span class="cov0" title="0">{
                config.StaleThresholdMinutes = 10
        }</span>

        <span class="cov0" title="0">return &amp;Worker{
                config:    config,
                log:       log.With(slog.String("worker", config.Name)),
                process:   process,
                stopCh:    make(chan struct{}),
                stoppedCh: make(chan struct{}),
        }</span>
}

// Start begins the worker's polling loop
func (w *Worker) Start(ctx context.Context) error <span class="cov0" title="0">{
        w.mu.Lock()
        if w.running </span><span class="cov0" title="0">{
                w.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">w.running = true
        w.stopCh = make(chan struct{})
        w.stoppedCh = make(chan struct{})
        w.mu.Unlock()

        w.log.Info("worker starting",
                slog.Duration("poll_interval", w.config.PollInterval),
                slog.Int("batch_size", w.config.BatchSize))

        w.wg.Add(1)
        go w.run(ctx)

        return nil</span>
}

// Stop gracefully stops the worker, waiting for current batch to complete
func (w *Worker) Stop(ctx context.Context) error <span class="cov0" title="0">{
        w.mu.Lock()
        if !w.running </span><span class="cov0" title="0">{
                w.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">w.running = false
        close(w.stopCh)
        w.mu.Unlock()

        w.log.Debug("waiting for worker to stop...")

        // Wait for worker to stop or context to be cancelled
        select </span>{
        case &lt;-w.stoppedCh:<span class="cov0" title="0">
                w.log.Info("worker stopped gracefully")</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                w.log.Warn("worker stop timeout, forcing shutdown")</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// run is the main worker loop
func (w *Worker) run(ctx context.Context) <span class="cov0" title="0">{
        defer w.wg.Done()
        defer close(w.stoppedCh)

        ticker := time.NewTicker(w.config.PollInterval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-w.stopCh:<span class="cov0" title="0">
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := w.processBatch(ctx); err != nil </span><span class="cov0" title="0">{
                                w.log.Warn("process batch failed", slog.String("error", err.Error()))
                        }</span>
                }
        }
}

// processBatch processes a single batch of jobs
func (w *Worker) processBatch(ctx context.Context) error <span class="cov0" title="0">{
        // Check if we should stop
        select </span>{
        case &lt;-w.stopCh:<span class="cov0" title="0">
                return nil</span>
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov0" title="0"></span>
        }

        <span class="cov0" title="0">return w.process(ctx)</span>
}

// Metrics returns current worker metrics
func (w *Worker) Metrics() WorkerMetrics <span class="cov8" title="1">{
        w.metricsMu.RLock()
        defer w.metricsMu.RUnlock()

        return WorkerMetrics{
                Processed: w.processedCount,
                Succeeded: w.successCount,
                Failed:    w.failureCount,
        }
}</span>

// IncrementProcessed increments the processed counter
func (w *Worker) IncrementProcessed() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.metricsMu.Unlock()
}</span>

// IncrementSuccess increments both processed and success counters
func (w *Worker) IncrementSuccess() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.successCount++
        w.metricsMu.Unlock()
}</span>

// IncrementFailure increments both processed and failure counters
func (w *Worker) IncrementFailure() <span class="cov8" title="1">{
        w.metricsMu.Lock()
        w.processedCount++
        w.failureCount++
        w.metricsMu.Unlock()
}</span>

// IsRunning returns whether the worker is currently running
func (w *Worker) IsRunning() bool <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        return w.running
}</span>

// WorkerMetrics contains worker metrics
type WorkerMetrics struct {
        Processed int64 `json:"processed"`
        Succeeded int64 `json:"succeeded"`
        Failed    int64 `json:"failed"`
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package storage

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "os"
        "regexp"
        "strings"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/google/uuid"
        "go.uber.org/fx"

        "github.com/emergent/emergent-core/pkg/logger"
)

var Module = fx.Module("storage",
        fx.Provide(NewConfig),
        fx.Provide(NewService),
)

// Config holds storage configuration
type Config struct {
        Endpoint        string
        AccessKey       string
        SecretKey       string
        Region          string
        BucketDocuments string
        BucketTemp      string
}

// Enabled returns true if storage is properly configured
func (c *Config) Enabled() bool <span class="cov8" title="1">{
        return c.Endpoint != "" &amp;&amp; c.AccessKey != "" &amp;&amp; c.SecretKey != ""
}</span>

// NewConfig creates storage config from environment variables
func NewConfig() *Config <span class="cov8" title="1">{
        region := os.Getenv("STORAGE_REGION")
        if region == "" </span><span class="cov0" title="0">{
                region = "us-east-1"
        }</span>

        <span class="cov8" title="1">bucketDocs := os.Getenv("STORAGE_BUCKET_DOCUMENTS")
        if bucketDocs == "" </span><span class="cov0" title="0">{
                bucketDocs = "documents"
        }</span>

        <span class="cov8" title="1">bucketTemp := os.Getenv("STORAGE_BUCKET_TEMP")
        if bucketTemp == "" </span><span class="cov0" title="0">{
                bucketTemp = "document-temp"
        }</span>

        <span class="cov8" title="1">return &amp;Config{
                Endpoint:        os.Getenv("STORAGE_ENDPOINT"),
                AccessKey:       os.Getenv("STORAGE_ACCESS_KEY"),
                SecretKey:       os.Getenv("STORAGE_SECRET_KEY"),
                Region:          region,
                BucketDocuments: bucketDocs,
                BucketTemp:      bucketTemp,
        }</span>
}

// Service provides S3-compatible storage operations
type Service struct {
        client          *s3.Client
        cfg             *Config
        log             *slog.Logger
        bucketDocuments string
}

// UploadOptions configures an upload operation
type UploadOptions struct {
        ContentType        string
        ContentDisposition string
        Metadata           map[string]string
}

// UploadResult contains information about an uploaded object
type UploadResult struct {
        Key         string
        Bucket      string
        ETag        string
        Size        int64
        ContentType string
        StorageURL  string
}

// DocumentUploadOptions extends UploadOptions with document-specific fields
type DocumentUploadOptions struct {
        OrgID     string
        ProjectID string
        Filename  string
        UploadOptions
}

// NewService creates a new storage service
func NewService(cfg *Config, log *slog.Logger) (*Service, error) <span class="cov8" title="1">{
        if !cfg.Enabled() </span><span class="cov0" title="0">{
                log.Warn("storage service disabled - no configuration provided")
                return &amp;Service{
                        cfg: cfg,
                        log: log.With(logger.Scope("storage")),
                }, nil
        }</span>

        // Create custom endpoint resolver for MinIO
        <span class="cov8" title="1">customResolver := aws.EndpointResolverWithOptionsFunc(
                func(service, region string, options ...interface{}) (aws.Endpoint, error) </span><span class="cov0" title="0">{
                        return aws.Endpoint{
                                URL:               cfg.Endpoint,
                                HostnameImmutable: true,
                                SigningRegion:     cfg.Region,
                        }, nil
                }</span>,
        )

        // Load AWS config with custom credentials and endpoint
        <span class="cov8" title="1">awsCfg, err := config.LoadDefaultConfig(context.Background(),
                config.WithRegion(cfg.Region),
                config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(
                        cfg.AccessKey,
                        cfg.SecretKey,
                        "",
                )),
                config.WithEndpointResolverWithOptions(customResolver),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load AWS config: %w", err)
        }</span>

        // Create S3 client with path-style addressing (required for MinIO)
        <span class="cov8" title="1">client := s3.NewFromConfig(awsCfg, func(o *s3.Options) </span><span class="cov8" title="1">{
                o.UsePathStyle = true
        }</span>)

        <span class="cov8" title="1">log.Info("storage service initialized",
                slog.String("endpoint", cfg.Endpoint),
                slog.String("bucket", cfg.BucketDocuments),
        )

        return &amp;Service{
                client:          client,
                cfg:             cfg,
                log:             log.With(logger.Scope("storage")),
                bucketDocuments: cfg.BucketDocuments,
        }, nil</span>
}

// Enabled returns true if the storage service is properly configured
func (s *Service) Enabled() bool <span class="cov8" title="1">{
        return s.client != nil
}</span>

// Upload uploads data to the specified key in the documents bucket
func (s *Service) Upload(ctx context.Context, key string, data io.Reader, size int64, opts UploadOptions) (*UploadResult, error) <span class="cov0" title="0">{
        if !s.Enabled() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("storage service not enabled")
        }</span>

        <span class="cov0" title="0">input := &amp;s3.PutObjectInput{
                Bucket:        aws.String(s.bucketDocuments),
                Key:           aws.String(key),
                Body:          data,
                ContentLength: aws.Int64(size),
        }

        if opts.ContentType != "" </span><span class="cov0" title="0">{
                input.ContentType = aws.String(opts.ContentType)
        }</span>
        <span class="cov0" title="0">if opts.ContentDisposition != "" </span><span class="cov0" title="0">{
                input.ContentDisposition = aws.String(opts.ContentDisposition)
        }</span>
        <span class="cov0" title="0">if len(opts.Metadata) &gt; 0 </span><span class="cov0" title="0">{
                input.Metadata = opts.Metadata
        }</span>

        <span class="cov0" title="0">result, err := s.client.PutObject(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to upload object",
                        slog.String("key", key),
                        logger.Error(err),
                )
                return nil, fmt.Errorf("upload failed: %w", err)
        }</span>

        <span class="cov0" title="0">etag := ""
        if result.ETag != nil </span><span class="cov0" title="0">{
                etag = strings.Trim(*result.ETag, "\"")
        }</span>

        <span class="cov0" title="0">s.log.Debug("object uploaded",
                slog.String("key", key),
                slog.String("bucket", s.bucketDocuments),
                slog.Int64("size", size),
        )

        return &amp;UploadResult{
                Key:         key,
                Bucket:      s.bucketDocuments,
                ETag:        etag,
                Size:        size,
                ContentType: opts.ContentType,
                StorageURL:  fmt.Sprintf("%s/%s", s.bucketDocuments, key),
        }, nil</span>
}

// UploadDocument uploads a document with project/org namespacing
func (s *Service) UploadDocument(ctx context.Context, data io.Reader, size int64, opts DocumentUploadOptions) (*UploadResult, error) <span class="cov0" title="0">{
        // Generate storage key: {projectId}/{orgId}/{uuid}-{sanitized_filename}
        key := GenerateDocumentKey(opts.ProjectID, opts.OrgID, opts.Filename)

        // Set content disposition for download
        uploadOpts := opts.UploadOptions
        if uploadOpts.ContentDisposition == "" &amp;&amp; opts.Filename != "" </span><span class="cov0" title="0">{
                uploadOpts.ContentDisposition = fmt.Sprintf(`attachment; filename="%s"`, opts.Filename)
        }</span>

        <span class="cov0" title="0">return s.Upload(ctx, key, data, size, uploadOpts)</span>
}

// Download retrieves an object from storage
func (s *Service) Download(ctx context.Context, key string) (io.ReadCloser, error) <span class="cov0" title="0">{
        if !s.Enabled() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("storage service not enabled")
        }</span>

        <span class="cov0" title="0">result, err := s.client.GetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(s.bucketDocuments),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to download object",
                        slog.String("key", key),
                        logger.Error(err),
                )
                return nil, fmt.Errorf("download failed: %w", err)
        }</span>

        <span class="cov0" title="0">return result.Body, nil</span>
}

// Delete removes an object from storage
func (s *Service) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        if !s.Enabled() </span><span class="cov0" title="0">{
                return fmt.Errorf("storage service not enabled")
        }</span>

        <span class="cov0" title="0">_, err := s.client.DeleteObject(ctx, &amp;s3.DeleteObjectInput{
                Bucket: aws.String(s.bucketDocuments),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                s.log.Error("failed to delete object",
                        slog.String("key", key),
                        logger.Error(err),
                )
                return fmt.Errorf("delete failed: %w", err)
        }</span>

        <span class="cov0" title="0">s.log.Debug("object deleted", slog.String("key", key))
        return nil</span>
}

// Exists checks if an object exists in storage
func (s *Service) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        if !s.Enabled() </span><span class="cov0" title="0">{
                return false, fmt.Errorf("storage service not enabled")
        }</span>

        <span class="cov0" title="0">_, err := s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(s.bucketDocuments),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                // Check if it's a "not found" error
                errStr := err.Error()
                if strings.Contains(errStr, "NotFound") || strings.Contains(errStr, "404") || strings.Contains(errStr, "NoSuchKey") </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("head object failed: %w", err)</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

// GenerateDocumentKey creates a storage key for a document
// Format: {projectId}/{orgId}/{uuid}-{sanitized_filename}
func GenerateDocumentKey(projectID, orgID, filename string) string <span class="cov8" title="1">{
        sanitized := SanitizeFilename(filename)
        id := uuid.New().String()
        return fmt.Sprintf("%s/%s/%s-%s", projectID, orgID, id, sanitized)
}</span>

// SanitizeFilename cleans a filename for storage
func SanitizeFilename(filename string) string <span class="cov8" title="1">{
        if filename == "" </span><span class="cov8" title="1">{
                return "unnamed"
        }</span>

        // Replace special characters with underscores
        <span class="cov8" title="1">re := regexp.MustCompile(`[^a-zA-Z0-9._-]`)
        sanitized := re.ReplaceAllString(filename, "_")

        // Collapse multiple underscores
        re = regexp.MustCompile(`_{2,}`)
        sanitized = re.ReplaceAllString(sanitized, "_")

        // Trim leading/trailing underscores
        sanitized = strings.Trim(sanitized, "_")

        // Lowercase
        sanitized = strings.ToLower(sanitized)

        // Limit length
        if len(sanitized) &gt; 200 </span><span class="cov8" title="1">{
                sanitized = sanitized[:200]
        }</span>

        <span class="cov8" title="1">if sanitized == "" </span><span class="cov8" title="1">{
                return "unnamed"
        }</span>

        <span class="cov8" title="1">return sanitized</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package testutil

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "strings"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/auth"
)

// TestUser represents a test user fixture
type TestUser struct {
        ID            string
        ZitadelUserID string
        Email         string
        FirstName     string
        LastName      string
        Scopes        []string
}

// TestTokenConfig maps a test token to its user configuration.
// This is the single source of truth for test token -&gt; user mappings.
type TestTokenConfig struct {
        Token  string   // The token string used in Authorization header
        Sub    string   // The zitadel_user_id (subject) this token maps to
        Scopes []string // Scopes granted to this token
}

// Predefined test users - these are created in the database by SetupTestFixtures.
// The ZitadelUserID must match the Sub field in TestTokenConfigs for the mapping to work.
var (
        // AdminUser - a user with admin privileges, used by e2e-test-user token
        AdminUser = TestUser{
                ID:            "00000000-0000-0000-0000-000000000001",
                ZitadelUserID: "test-admin-user",
                Email:         "admin@test.local",
                FirstName:     "Test",
                LastName:      "Admin",
                Scopes:        auth.GetAllScopes(),
        }

        // RegularUser - a standard user with basic scopes (no token maps to this by default)
        RegularUser = TestUser{
                ID:            "00000000-0000-0000-0000-000000000002",
                ZitadelUserID: "test-regular-user",
                Email:         "user@test.local",
                FirstName:     "Test",
                LastName:      "User",
                Scopes:        []string{"documents:read", "project:read", "search:read"},
        }

        // NoScopeUser - matches middleware "no-scope" test token
        NoScopeUser = TestUser{
                ID:            "00000000-0000-0000-0000-000000000003",
                ZitadelUserID: "test-user-no-scope",
                Email:         "noscope@test.local",
                FirstName:     "No",
                LastName:      "Scope",
                Scopes:        []string{},
        }

        // WithScopeUser - matches middleware "with-scope" test token
        WithScopeUser = TestUser{
                ID:            "00000000-0000-0000-0000-000000000004",
                ZitadelUserID: "test-user-with-scope",
                Email:         "withscope@test.local",
                FirstName:     "With",
                LastName:      "Scope",
                Scopes:        []string{"documents:read", "documents:write", "project:read"},
        }

        // AllScopesUser - matches middleware "all-scopes" test token
        AllScopesUser = TestUser{
                ID:            "00000000-0000-0000-0000-000000000005",
                ZitadelUserID: "test-user-all-scopes",
                Email:         "allscopes@test.local",
                FirstName:     "All",
                LastName:      "Scopes",
                Scopes:        auth.GetAllScopes(),
        }

        // GraphReadUser - matches middleware "graph-read" test token
        GraphReadUser = TestUser{
                ID:            "00000000-0000-0000-0000-000000000006",
                ZitadelUserID: "test-user-graph-read",
                Email:         "graphread@test.local",
                FirstName:     "Graph",
                LastName:      "Reader",
                Scopes:        []string{"graph:read", "graph:search:read"},
        }

        // ReadOnlyUser - matches middleware "read-only" test token (no write/delete permissions)
        ReadOnlyUser = TestUser{
                ID:            "00000000-0000-0000-0000-000000000007",
                ZitadelUserID: "test-user-read-only",
                Email:         "readonly@test.local",
                FirstName:     "Read",
                LastName:      "Only",
                Scopes:        []string{"documents:read", "project:read", "org:read", "chunks:read", "search:read", "graph:read"},
        }
)

// TestTokenConfigs defines all test tokens and their mappings.
// This should match the testTokens map in pkg/auth/middleware.go.
//
// Token naming convention:
//   - Simple tokens: "no-scope", "with-scope", "all-scopes", "graph-read"
//   - E2E tokens: "e2e-test-user", "e2e-query-token" (mapped to AdminUser)
var TestTokenConfigs = []TestTokenConfig{
        {Token: "no-scope", Sub: "test-user-no-scope", Scopes: []string{}},
        {Token: "with-scope", Sub: "test-user-with-scope", Scopes: []string{"documents:read", "documents:write", "project:read"}},
        {Token: "graph-read", Sub: "test-user-graph-read", Scopes: []string{"graph:read", "graph:search:read"}},
        {Token: "all-scopes", Sub: "test-user-all-scopes", Scopes: auth.GetAllScopes()},
        {Token: "e2e-test-user", Sub: "test-admin-user", Scopes: auth.GetAllScopes()},
        {Token: "e2e-query-token", Sub: "test-admin-user", Scopes: auth.GetAllScopes()},
}

// GetTestTokenConfig returns the config for a given token, or nil if not found
func GetTestTokenConfig(token string) *TestTokenConfig <span class="cov0" title="0">{
        for _, cfg := range TestTokenConfigs </span><span class="cov0" title="0">{
                if cfg.Token == token </span><span class="cov0" title="0">{
                        return &amp;cfg
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// GetUserByZitadelID returns the TestUser that matches the given zitadel_user_id
func GetUserByZitadelID(zitadelUserID string) *TestUser <span class="cov0" title="0">{
        users := []TestUser{AdminUser, RegularUser, NoScopeUser, WithScopeUser, AllScopesUser, GraphReadUser}
        for _, u := range users </span><span class="cov0" title="0">{
                if u.ZitadelUserID == zitadelUserID </span><span class="cov0" title="0">{
                        return &amp;u
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// CreateTestUser inserts a test user into the database
func CreateTestUser(ctx context.Context, db bun.IDB, user TestUser) error <span class="cov8" title="1">{
        // Insert user profile
        _, err := db.NewRaw(`
                INSERT INTO core.user_profiles (id, zitadel_user_id, first_name, last_name, created_at, updated_at)
                VALUES (?, ?, ?, ?, NOW(), NOW())
                ON CONFLICT (zitadel_user_id) DO UPDATE SET
                        first_name = EXCLUDED.first_name,
                        last_name = EXCLUDED.last_name,
                        updated_at = NOW()
        `, user.ID, user.ZitadelUserID, user.FirstName, user.LastName).Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Insert email if provided
        <span class="cov8" title="1">if user.Email != "" </span><span class="cov8" title="1">{
                _, err = db.NewRaw(`
                        INSERT INTO core.user_emails (user_id, email, verified, created_at)
                        VALUES (?, ?, true, NOW())
                        ON CONFLICT (email) DO NOTHING
                `, user.ID, user.Email).Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CreateTestAPIToken creates an API token for a test user
func CreateTestAPIToken(ctx context.Context, db bun.IDB, userID string, token string, scopes []string, projectID string) error <span class="cov8" title="1">{
        // Hash the token with SHA256 (64 hex chars fits varchar(64))
        hash := sha256.Sum256([]byte(token))
        tokenHash := hex.EncodeToString(hash[:])
        tokenPrefix := token[:min(12, len(token))]

        // Convert Go []string to PostgreSQL array literal format: {elem1,elem2,...}
        pgArray := "{" + strings.Join(scopes, ",") + "}"

        _, err := db.NewRaw(`
                INSERT INTO core.api_tokens (user_id, project_id, name, token_hash, token_prefix, scopes, created_at)
                VALUES (?, ?, 'test-token', ?, ?, ?::text[], NOW())
        `, userID, projectID, tokenHash, tokenPrefix, pgArray).Exec(ctx)

        return err
}</span>

// CreateExpiredAPIToken creates an expired API token for testing
// Note: The actual schema doesn't have expires_at, so we create a revoked token instead
func CreateExpiredAPIToken(ctx context.Context, db bun.IDB, userID string, token string, projectID string) error <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(token))
        tokenHash := hex.EncodeToString(hash[:])
        tokenPrefix := token[:min(12, len(token))]

        // Simulate expired by setting revoked_at in the past
        _, err := db.NewRaw(`
                INSERT INTO core.api_tokens (user_id, project_id, name, token_hash, token_prefix, scopes, created_at, revoked_at)
                VALUES (?, ?, 'expired-token', ?, ?, '{}', NOW(), NOW() - INTERVAL '1 hour')
        `, userID, projectID, tokenHash, tokenPrefix).Exec(ctx)

        return err
}</span>

// CreateDeletedAPIToken creates a soft-deleted (revoked) API token for testing
func CreateDeletedAPIToken(ctx context.Context, db bun.IDB, userID string, token string, projectID string) error <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(token))
        tokenHash := hex.EncodeToString(hash[:])
        tokenPrefix := token[:min(12, len(token))]

        _, err := db.NewRaw(`
                INSERT INTO core.api_tokens (user_id, project_id, name, token_hash, token_prefix, scopes, created_at, revoked_at)
                VALUES (?, ?, 'deleted-token', ?, ?, '{}', NOW(), NOW())
        `, userID, projectID, tokenHash, tokenPrefix).Exec(ctx)

        return err
}</span>

// CacheIntrospectionResult caches a token introspection result
func CacheIntrospectionResult(ctx context.Context, db bun.IDB, token string, sub string, email string, scopes []string, expiresIn time.Duration) error <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(token))
        tokenHash := hex.EncodeToString(hash[:])

        scopeStr := ""
        for i, s := range scopes </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov0" title="0">{
                        scopeStr += " "
                }</span>
                <span class="cov8" title="1">scopeStr += s</span>
        }

        <span class="cov8" title="1">data := map[string]any{
                "sub":   sub,
                "email": email,
                "scope": scopeStr,
        }

        _, err := db.NewRaw(`
                INSERT INTO kb.auth_introspection_cache (token_hash, introspection_data, expires_at)
                VALUES (?, ?, ?)
                ON CONFLICT (token_hash) DO UPDATE SET
                        introspection_data = EXCLUDED.introspection_data,
                        expires_at = EXCLUDED.expires_at
        `, tokenHash, data, time.Now().Add(expiresIn)).Exec(ctx)

        return err</span>
}

// SetupTestFixtures creates all standard test fixtures
func SetupTestFixtures(ctx context.Context, db bun.IDB) error <span class="cov8" title="1">{
        // Create test users - include all predefined users that match middleware test tokens
        users := []TestUser{AdminUser, RegularUser, NoScopeUser, WithScopeUser, AllScopesUser, GraphReadUser, ReadOnlyUser}
        for _, user := range users </span><span class="cov8" title="1">{
                if err := CreateTestUser(ctx, db, user); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// AuthHeader returns an Authorization header value for a token
func AuthHeader(token string) string <span class="cov0" title="0">{
        return "Bearer " + token
}</span>

// TestProject represents a test project fixture
type TestProject struct {
        ID     string
        Name   string
        OrgID  string
}

// DefaultTestProject is a standard test project
var DefaultTestProject = TestProject{
        ID:    "00000000-0000-0000-0000-000000000100",
        Name:  "Test Project",
        OrgID: "00000000-0000-0000-0000-000000000200",
}

// CreateTestProject creates a test project in the database
func CreateTestProject(ctx context.Context, db bun.IDB, project TestProject, ownerID string) error <span class="cov8" title="1">{
        // First ensure the organization exists
        _, err := db.NewRaw(`
                INSERT INTO kb.orgs (id, name, created_at, updated_at)
                VALUES (?, 'Test Organization', NOW(), NOW())
                ON CONFLICT (id) DO NOTHING
        `, project.OrgID).Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create the project
        <span class="cov8" title="1">_, err = db.NewRaw(`
                INSERT INTO kb.projects (id, name, organization_id, created_at, updated_at)
                VALUES (?, ?, ?, NOW(), NOW())
                ON CONFLICT (id) DO UPDATE SET
                        name = EXCLUDED.name,
                        updated_at = NOW()
        `, project.ID, project.Name, project.OrgID).Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// CreateTestOrganization creates a test organization in the database
func CreateTestOrganization(ctx context.Context, db bun.IDB, id, name string) error <span class="cov8" title="1">{
        _, err := db.NewRaw(`
                INSERT INTO kb.orgs (id, name, created_at, updated_at)
                VALUES (?, ?, NOW(), NOW())
                ON CONFLICT (id) DO UPDATE SET
                        name = EXCLUDED.name,
                        updated_at = NOW()
        `, id, name).Exec(ctx)
        return err
}</span>

// TestDocument represents a test document fixture
type TestDocument struct {
        ID                      string
        ProjectID               string
        Filename                *string
        SourceURL               *string
        MimeType                *string
        Content                 *string
        SourceType              *string
        DataSourceIntegrationID *string
        ParentDocumentID        *string
}

// CreateTestDocument creates a test document in the database
func CreateTestDocument(ctx context.Context, db bun.IDB, doc TestDocument) error <span class="cov8" title="1">{
        // source_type defaults to 'upload' if not provided
        sourceType := "upload"
        if doc.SourceType != nil </span><span class="cov8" title="1">{
                sourceType = *doc.SourceType
        }</span>

        <span class="cov8" title="1">_, err := db.NewRaw(`
                INSERT INTO kb.documents (
                        id, project_id, filename, source_url, mime_type, content,
                        source_type, data_source_integration_id, parent_document_id,
                        created_at, updated_at
                )
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, NOW(), NOW())
                ON CONFLICT (id) DO UPDATE SET
                        filename = EXCLUDED.filename,
                        updated_at = NOW()
        `, doc.ID, doc.ProjectID, doc.Filename, doc.SourceURL, doc.MimeType,
                doc.Content, sourceType, doc.DataSourceIntegrationID, doc.ParentDocumentID).Exec(ctx)

        return err</span>
}

// CreateTestDocumentWithTimestamp creates a test document with a specific timestamp
func CreateTestDocumentWithTimestamp(ctx context.Context, db bun.IDB, doc TestDocument, createdAt time.Time) error <span class="cov8" title="1">{
        // source_type defaults to 'upload' if not provided
        sourceType := "upload"
        if doc.SourceType != nil </span><span class="cov0" title="0">{
                sourceType = *doc.SourceType
        }</span>

        <span class="cov8" title="1">_, err := db.NewRaw(`
                INSERT INTO kb.documents (
                        id, project_id, filename, source_url, mime_type, content,
                        source_type, data_source_integration_id, parent_document_id,
                        created_at, updated_at
                )
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ON CONFLICT (id) DO UPDATE SET
                        filename = EXCLUDED.filename,
                        updated_at = NOW()
        `, doc.ID, doc.ProjectID, doc.Filename, doc.SourceURL, doc.MimeType,
                doc.Content, sourceType, doc.DataSourceIntegrationID, doc.ParentDocumentID, createdAt, createdAt).Exec(ctx)

        return err</span>
}

// DeleteTestDocument deletes a test document (hard delete, no soft delete column exists)
func DeleteTestDocument(ctx context.Context, db bun.IDB, documentID string) error <span class="cov0" title="0">{
        _, err := db.NewRaw(`
                DELETE FROM kb.documents WHERE id = ?
        `, documentID).Exec(ctx)
        return err
}</span>

// StringPtr is a helper to create a pointer to a string
func StringPtr(s string) *string <span class="cov8" title="1">{
        return &amp;s
}</span>

// CreateTestProjectMembership creates a project membership for a user
func CreateTestProjectMembership(ctx context.Context, db bun.IDB, projectID, userID, role string) error <span class="cov8" title="1">{
        _, err := db.NewRaw(`
                INSERT INTO kb.project_memberships (project_id, user_id, role, created_at)
                VALUES (?, ?, ?, NOW())
                ON CONFLICT (project_id, user_id) DO UPDATE SET
                        role = EXCLUDED.role
        `, projectID, userID, role).Exec(ctx)
        return err
}</span>

// CreateTestOrgMembership creates an organization membership for a user
func CreateTestOrgMembership(ctx context.Context, db bun.IDB, orgID, userID, role string) error <span class="cov0" title="0">{
        _, err := db.NewRaw(`
                INSERT INTO kb.organization_memberships (organization_id, user_id, role, created_at)
                VALUES (?, ?, ?, NOW())
                ON CONFLICT (organization_id, user_id) DO UPDATE SET
                        role = EXCLUDED.role
        `, orgID, userID, role).Exec(ctx)
        return err
}</span>
</pre>
		
		<pre class="file" id="file108" style="display: none">package testutil

import (
        "context"
        _ "embed"
        "fmt"
        "log/slog"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/jackc/pgx/v5/pgxpool"
        "github.com/jackc/pgx/v5/stdlib"
        "github.com/uptrace/bun"
        "github.com/uptrace/bun/dialect/pgdialect"

        "github.com/emergent/emergent-core/internal/config"
)

//go:embed schema.sql
var schemaSQL string

const templateDBName = "go_test_template"

var (
        templateOnce sync.Once
        templateErr  error
)

// TestDB holds test database resources
type TestDB struct {
        Config  *config.Config
        Pool    *pgxpool.Pool
        DB      *bun.DB
        Name    string
        cleanup func()

        // Transaction support for per-test isolation
        tx     bun.Tx
        hasTx  bool
}

// Close releases test database resources
func (t *TestDB) Close() <span class="cov8" title="1">{
        if t.cleanup != nil </span><span class="cov8" title="1">{
                t.cleanup()
        }</span>
}

// GetDB returns the current database connection.
// If a transaction is active, returns the transaction; otherwise returns the base DB.
func (t *TestDB) GetDB() bun.IDB <span class="cov8" title="1">{
        if t.hasTx </span><span class="cov8" title="1">{
                return t.tx
        }</span>
        <span class="cov8" title="1">return t.DB</span>
}

// BeginTestTx starts a new transaction for test isolation.
// All database operations should use GetDB() which will return this transaction.
func (t *TestDB) BeginTestTx(ctx context.Context) error <span class="cov8" title="1">{
        if t.hasTx </span><span class="cov0" title="0">{
                return fmt.Errorf("transaction already started")
        }</span>
        <span class="cov8" title="1">tx, err := t.DB.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("begin transaction: %w", err)
        }</span>
        <span class="cov8" title="1">t.tx = tx
        t.hasTx = true
        return nil</span>
}

// RollbackTestTx rolls back the current transaction, discarding all changes.
// This provides fast test cleanup without TRUNCATE.
func (t *TestDB) RollbackTestTx() error <span class="cov8" title="1">{
        if !t.hasTx </span><span class="cov0" title="0">{
                return nil // No transaction to rollback
        }</span>
        <span class="cov8" title="1">err := t.tx.Rollback()
        t.hasTx = false
        return err</span>
}

// HasTx returns true if a transaction is currently active.
func (t *TestDB) HasTx() bool <span class="cov0" title="0">{
        return t.hasTx
}</span>

// SetupTestDB creates an isolated test database for Go e2e tests.
// It uses a template database pattern for maximum speed:
//   - First call: Creates template DB with schema (~1s)
//   - Subsequent calls: CREATE DATABASE ... TEMPLATE (~50ms)
//
// Requirements:
//   - PostgreSQL must be running
//   - The base database (from POSTGRES_DB) must exist
//
// The test database is automatically dropped when Close() is called.
func SetupTestDB(ctx context.Context, suffix string) (*TestDB, error) <span class="cov8" title="1">{
        log := slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelWarn}))

        // Load base config from environment
        baseCfg, err := config.NewConfig(log)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("load config: %w", err)
        }</span>

        // Ensure template database exists (only done once per test run)
        <span class="cov8" title="1">templateOnce.Do(func() </span><span class="cov8" title="1">{
                templateErr = ensureTemplateDB(ctx, baseCfg, log)
        }</span>)
        <span class="cov8" title="1">if templateErr != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ensure template db: %w", templateErr)
        }</span>

        // Create unique database name with go_test prefix
        <span class="cov8" title="1">testDBName := fmt.Sprintf("go_test_%s_%d", suffix, time.Now().UnixNano())

        // Connect to postgres database to create test database from template
        adminCfg := *baseCfg
        adminCfg.Database.Database = "postgres"

        adminPool, err := createPool(ctx, &amp;adminCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("connect to postgres: %w", err)
        }</span>

        // Create test database from template (very fast - just copies file pointers)
        <span class="cov8" title="1">_, err = adminPool.Exec(ctx, fmt.Sprintf("CREATE DATABASE %s TEMPLATE %s", testDBName, templateDBName))
        if err != nil </span><span class="cov0" title="0">{
                adminPool.Close()
                return nil, fmt.Errorf("create test db from template: %w", err)
        }</span>
        <span class="cov8" title="1">adminPool.Close()

        log.Info("created test database from template", slog.String("name", testDBName))

        // Update config to use test database
        testCfg := *baseCfg
        testCfg.Database.Database = testDBName

        // Connect to test database
        testPool, err := createPool(ctx, &amp;testCfg)
        if err != nil </span><span class="cov0" title="0">{
                dropTestDB(ctx, baseCfg, testDBName)
                return nil, fmt.Errorf("connect to test db: %w", err)
        }</span>

        // Create Bun DB
        <span class="cov8" title="1">sqldb := stdlib.OpenDBFromPool(testPool)
        bunDB := bun.NewDB(sqldb, pgdialect.New())

        // Cleanup function
        cleanup := func() </span><span class="cov8" title="1">{
                bunDB.Close()
                testPool.Close()
                dropTestDB(context.Background(), baseCfg, testDBName)
                log.Info("dropped test database", slog.String("name", testDBName))
        }</span>

        <span class="cov8" title="1">return &amp;TestDB{
                Config:  &amp;testCfg,
                Pool:    testPool,
                DB:      bunDB,
                Name:    testDBName,
                cleanup: cleanup,
        }, nil</span>
}

// ensureTemplateDB creates the template database with schema if it doesn't exist.
// This is called once per test run via sync.Once.
func ensureTemplateDB(ctx context.Context, baseCfg *config.Config, log *slog.Logger) error <span class="cov8" title="1">{
        adminCfg := *baseCfg
        adminCfg.Database.Database = "postgres"

        adminPool, err := createPool(ctx, &amp;adminCfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connect to postgres: %w", err)
        }</span>
        <span class="cov8" title="1">defer adminPool.Close()

        // Check if template already exists
        var exists bool
        err = adminPool.QueryRow(ctx, "SELECT EXISTS(SELECT 1 FROM pg_database WHERE datname = $1)", templateDBName).Scan(&amp;exists)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("check template exists: %w", err)
        }</span>

        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                log.Info("template database already exists", slog.String("name", templateDBName))
                return nil
        }</span>

        <span class="cov0" title="0">log.Info("creating template database", slog.String("name", templateDBName))

        // Create template database
        _, err = adminPool.Exec(ctx, fmt.Sprintf("CREATE DATABASE %s", templateDBName))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create template db: %w", err)
        }</span>

        // Connect to template database
        <span class="cov0" title="0">templateCfg := *baseCfg
        templateCfg.Database.Database = templateDBName
        templatePool, err := createPool(ctx, &amp;templateCfg)
        if err != nil </span><span class="cov0" title="0">{
                dropTestDB(ctx, baseCfg, templateDBName)
                return fmt.Errorf("connect to template db: %w", err)
        }</span>
        <span class="cov0" title="0">defer templatePool.Close()

        // Create required extensions
        extensions := []string{"pgcrypto", `"uuid-ossp"`, "vector"}
        for _, ext := range extensions </span><span class="cov0" title="0">{
                _, err = templatePool.Exec(ctx, fmt.Sprintf("CREATE EXTENSION IF NOT EXISTS %s", ext))
                if err != nil </span><span class="cov0" title="0">{
                        dropTestDB(ctx, baseCfg, templateDBName)
                        return fmt.Errorf("create extension %s: %w", ext, err)
                }</span>
        }

        // Apply schema
        <span class="cov0" title="0">_, err = templatePool.Exec(ctx, schemaSQL)
        if err != nil </span><span class="cov0" title="0">{
                dropTestDB(ctx, baseCfg, templateDBName)
                return fmt.Errorf("apply schema: %w", err)
        }</span>

        <span class="cov0" title="0">log.Info("template database created with schema", slog.String("name", templateDBName))
        return nil</span>
}

// createPool creates a pgx connection pool
func createPool(ctx context.Context, cfg *config.Config) (*pgxpool.Pool, error) <span class="cov8" title="1">{
        poolConfig, err := pgxpool.ParseConfig(cfg.Database.DSN())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">poolConfig.MaxConns = 5
        return pgxpool.NewWithConfig(ctx, poolConfig)</span>
}

// dropTestDB drops a test database
func dropTestDB(ctx context.Context, baseCfg *config.Config, dbName string) <span class="cov8" title="1">{
        // Connect to postgres database (not app database) to drop
        adminCfg := *baseCfg
        adminCfg.Database.Database = "postgres"

        pool, err := createPool(ctx, &amp;adminCfg)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer pool.Close()

        // Terminate all connections to the test database
        _, _ = pool.Exec(ctx, fmt.Sprintf(`
                SELECT pg_terminate_backend(pid) 
                FROM pg_stat_activity 
                WHERE datname = '%s' AND pid &lt;&gt; pg_backend_pid()
        `, dbName))

        // Drop the database
        _, _ = pool.Exec(ctx, fmt.Sprintf("DROP DATABASE IF EXISTS %s", dbName))</span>
}

// TruncateTables truncates all tables in the test database.
// Use this between tests to reset state without recreating the database.
// Note: When using transaction rollback pattern, this is typically not needed.
func TruncateTables(ctx context.Context, db bun.IDB) error <span class="cov8" title="1">{
        // Get all tables from kb and core schemas using raw SQL
        type tableInfo struct {
                Schema string `bun:"schemaname"`
                Table  string `bun:"tablename"`
        }
        var tables []tableInfo

        err := db.NewRaw(`
                SELECT schemaname, tablename 
                FROM pg_tables 
                WHERE schemaname IN ('kb', 'core') 
                AND tablename != 'migrations'
        `).Scan(ctx, &amp;tables)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("list tables: %w", err)
        }</span>

        <span class="cov8" title="1">if len(tables) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Build single TRUNCATE statement for all tables (much faster than individual truncates)
        <span class="cov8" title="1">var tableNames []string
        for _, t := range tables </span><span class="cov8" title="1">{
                tableNames = append(tableNames, fmt.Sprintf("%s.%s", t.Schema, t.Table))
        }</span>

        // Disable triggers and truncate all tables in one statement
        <span class="cov8" title="1">_, _ = db.NewRaw("SET session_replication_role = 'replica'").Exec(ctx)
        defer db.NewRaw("SET session_replication_role = 'origin'").Exec(ctx)

        // Single TRUNCATE for all tables is much faster than 60 individual truncates
        truncateSQL := fmt.Sprintf("TRUNCATE TABLE %s CASCADE", strings.Join(tableNames, ", "))
        _, err = db.NewRaw(truncateSQL).Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("truncate tables: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DropTemplateDB drops the template database. Call this at the end of a test run
// if you want to force schema refresh on next run.
func DropTemplateDB(ctx context.Context) error <span class="cov0" title="0">{
        log := slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelWarn}))
        baseCfg, err := config.NewConfig(log)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("load config: %w", err)
        }</span>
        <span class="cov0" title="0">dropTestDB(ctx, baseCfg, templateDBName)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package testutil

import (
        "encoding/json"
        "io"
        "log/slog"
        "net/http"
        "net/http/httptest"
        "os"
        "strings"

        "github.com/labstack/echo/v4"
        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/domain/apitoken"
        "github.com/emergent/emergent-core/domain/chat"
        "github.com/emergent/emergent-core/domain/chunks"
        "github.com/emergent/emergent-core/domain/documents"
        "github.com/emergent/emergent-core/domain/graph"
        "github.com/emergent/emergent-core/domain/health"
        "github.com/emergent/emergent-core/domain/mcp"
        "github.com/emergent/emergent-core/domain/orgs"
        "github.com/emergent/emergent-core/domain/projects"
        "github.com/emergent/emergent-core/domain/search"
        "github.com/emergent/emergent-core/domain/userprofile"
        "github.com/emergent/emergent-core/domain/users"
        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/internal/storage"
        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/auth"
        "github.com/emergent/emergent-core/pkg/embeddings"
)

// TestServer wraps an Echo instance for testing
type TestServer struct {
        Echo           *echo.Echo
        TestDB         *TestDB
        DB             bun.IDB
        Config         *config.Config
        Log            *slog.Logger
        AuthMiddleware *auth.Middleware
}

// NewTestServer creates a test server with all routes registered.
func NewTestServer(testDB *TestDB) *TestServer <span class="cov8" title="1">{
        return newTestServerWithDB(testDB, testDB.GetDB())
}</span>

// newTestServerWithDB creates a test server with a specific DB connection
func newTestServerWithDB(testDB *TestDB, db bun.IDB) *TestServer <span class="cov8" title="1">{
        log := slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelWarn}))

        // Create Echo instance
        e := echo.New()
        e.HideBanner = true
        e.HidePort = true

        // Use custom error handler to properly handle apperror.Error types
        e.HTTPErrorHandler = apperror.HTTPErrorHandler(log)

        // Create auth components
        userSvc := auth.NewUserProfileService(db, log)
        authMiddleware := auth.NewMiddleware(db, testDB.Config, log, userSvc)

        // Register health routes (public)
        healthHandler := health.NewHandler(testDB.Pool, testDB.Config)
        e.GET("/health", healthHandler.Health)
        e.GET("/healthz", healthHandler.Healthz)
        e.GET("/ready", healthHandler.Ready)
        e.GET("/debug", healthHandler.Debug)

        // Register protected test routes for auth testing
        protected := e.Group("/api/v2/test")
        protected.Use(authMiddleware.RequireAuth())

        // Simple endpoint that returns user info (for testing auth)
        protected.GET("/me", func(c echo.Context) error </span><span class="cov8" title="1">{
                user := auth.GetUser(c)
                if user == nil </span><span class="cov0" title="0">{
                        return echo.NewHTTPError(http.StatusUnauthorized, "No user in context")
                }</span>
                <span class="cov8" title="1">return c.JSON(http.StatusOK, map[string]any{
                        "id":        user.ID,
                        "sub":       user.Sub,
                        "email":     user.Email,
                        "scopes":    user.Scopes,
                        "projectId": user.ProjectID,
                        "orgId":     user.OrgID,
                })</span>
        })

        // Endpoint requiring specific scopes
        <span class="cov8" title="1">scopedGroup := e.Group("/api/v2/test/scoped")
        scopedGroup.Use(authMiddleware.RequireAuth())
        scopedGroup.Use(authMiddleware.RequireScopes("documents:read"))
        scopedGroup.GET("", func(c echo.Context) error </span><span class="cov8" title="1">{
                return c.JSON(http.StatusOK, map[string]any{"message": "You have documents:read scope"})
        }</span>)

        // Endpoint requiring project ID
        <span class="cov8" title="1">projectGroup := e.Group("/api/v2/test/project")
        projectGroup.Use(authMiddleware.RequireAuth())
        projectGroup.Use(authMiddleware.RequireProjectID())
        projectGroup.GET("", func(c echo.Context) error </span><span class="cov8" title="1">{
                user := auth.GetUser(c)
                return c.JSON(http.StatusOK, map[string]any{
                        "message":   "Project ID required endpoint",
                        "projectId": user.ProjectID,
                })
        }</span>)

        // Register documents routes
        <span class="cov8" title="1">docsRepo := documents.NewRepository(db, log)
        docsSvc := documents.NewService(docsRepo, log)
        docsHandler := documents.NewHandler(docsSvc)
        // Create storage service (will be disabled in tests since no env vars set)
        storageCfg := storage.NewConfig()
        storageSvc, _ := storage.NewService(storageCfg, log)
        uploadHandler := documents.NewUploadHandler(docsSvc, storageSvc)
        documents.RegisterRoutes(e, docsHandler, uploadHandler, authMiddleware)

        // Register orgs routes
        orgsRepo := orgs.NewRepository(db, log)
        orgsSvc := orgs.NewService(orgsRepo, log)
        orgsHandler := orgs.NewHandler(orgsSvc)
        orgs.RegisterRoutes(e, orgsHandler, authMiddleware)

        // Register projects routes
        projectsRepo := projects.NewRepository(db, log)
        projectsSvc := projects.NewService(projectsRepo, log)
        projectsHandler := projects.NewHandler(projectsSvc)
        projects.RegisterRoutes(e, projectsHandler, authMiddleware)

        // Register users routes
        usersRepo := users.NewRepository(db, log)
        usersSvc := users.NewService(usersRepo, log)
        usersHandler := users.NewHandler(usersSvc)
        users.RegisterRoutes(e, usersHandler, authMiddleware)

        // Register userprofile routes
        userProfileRepo := userprofile.NewRepository(db, log)
        userProfileSvc := userprofile.NewService(userProfileRepo, log)
        userProfileHandler := userprofile.NewHandler(userProfileSvc)
        userprofile.RegisterRoutes(e, userProfileHandler, authMiddleware)

        // Register apitoken routes
        apitokenRepo := apitoken.NewRepository(db, log)
        apitokenSvc := apitoken.NewService(apitokenRepo, log)
        apitokenHandler := apitoken.NewHandler(apitokenSvc)
        apitoken.RegisterRoutes(e, apitokenHandler, authMiddleware)

        // Register graph routes
        graphRepo := graph.NewRepository(db, log)
        graphSvc := graph.NewService(graphRepo, log)
        graphHandler := graph.NewHandler(graphSvc)
        graph.RegisterRoutes(e, graphHandler, authMiddleware)

        // Register chunks routes
        chunksRepo := chunks.NewRepository(db, log)
        chunksSvc := chunks.NewService(chunksRepo, log)
        chunksHandler := chunks.NewHandler(chunksSvc)
        chunks.RegisterRoutes(e, chunksHandler, authMiddleware)

        // Register search routes
        searchRepo := search.NewRepository(db, log)
        embeddingsSvc := embeddings.NewNoopService(log) // Use noop service for tests
        searchSvc := search.NewService(searchRepo, graphSvc, embeddingsSvc, log)
        searchHandler := search.NewHandler(searchSvc)
        search.RegisterRoutes(e, searchHandler, authMiddleware)

        // Register chat routes
        chatRepo := chat.NewRepository(db, log)
        chatSvc := chat.NewService(chatRepo, log)
        chatHandler := chat.NewHandler(chatSvc, nil) // nil LLM client for tests
        chat.RegisterRoutes(e, chatHandler, authMiddleware)

        // Register MCP routes
        mcpSvc := mcp.NewService(db, log)
        mcpHandler := mcp.NewHandler(mcpSvc, log)
        mcpSSEHandler := mcp.NewSSEHandler(mcpSvc, log)
        mcp.RegisterRoutes(e, mcpHandler, mcpSSEHandler, authMiddleware)

        return &amp;TestServer{
                Echo:           e,
                TestDB:         testDB,
                DB:             db,
                Config:         testDB.Config,
                Log:            log,
                AuthMiddleware: authMiddleware,
        }</span>
}

// Request performs an HTTP request against the test server
func (s *TestServer) Request(method, path string, opts ...RequestOption) *httptest.ResponseRecorder <span class="cov8" title="1">{
        req := httptest.NewRequest(method, path, nil)
        
        // Apply options
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(req)
        }</span>

        <span class="cov8" title="1">rec := httptest.NewRecorder()
        s.Echo.ServeHTTP(rec, req)
        return rec</span>
}

// GET performs a GET request
func (s *TestServer) GET(path string, opts ...RequestOption) *httptest.ResponseRecorder <span class="cov8" title="1">{
        return s.Request(http.MethodGet, path, opts...)
}</span>

// POST performs a POST request
func (s *TestServer) POST(path string, opts ...RequestOption) *httptest.ResponseRecorder <span class="cov8" title="1">{
        return s.Request(http.MethodPost, path, opts...)
}</span>

// PUT performs a PUT request
func (s *TestServer) PUT(path string, opts ...RequestOption) *httptest.ResponseRecorder <span class="cov8" title="1">{
        return s.Request(http.MethodPut, path, opts...)
}</span>

// DELETE performs a DELETE request
func (s *TestServer) DELETE(path string, opts ...RequestOption) *httptest.ResponseRecorder <span class="cov8" title="1">{
        return s.Request(http.MethodDelete, path, opts...)
}</span>

// PATCH performs a PATCH request
func (s *TestServer) PATCH(path string, opts ...RequestOption) *httptest.ResponseRecorder <span class="cov8" title="1">{
        return s.Request(http.MethodPatch, path, opts...)
}</span>

// RequestOption modifies an HTTP request
type RequestOption func(*http.Request)

// WithHeader adds a header to the request
func WithHeader(key, value string) RequestOption <span class="cov8" title="1">{
        return func(r *http.Request) </span><span class="cov8" title="1">{
                r.Header.Set(key, value)
        }</span>
}

// WithAuth adds an Authorization header
func WithAuth(token string) RequestOption <span class="cov8" title="1">{
        return WithHeader("Authorization", "Bearer "+token)
}</span>

// WithProjectID adds an X-Project-ID header
func WithProjectID(projectID string) RequestOption <span class="cov8" title="1">{
        return WithHeader("X-Project-ID", projectID)
}</span>

// WithOrgID adds an X-Org-ID header
func WithOrgID(orgID string) RequestOption <span class="cov8" title="1">{
        return WithHeader("X-Org-ID", orgID)
}</span>

// WithJSON adds Content-Type: application/json header
func WithJSON() RequestOption <span class="cov8" title="1">{
        return WithHeader("Content-Type", "application/json")
}</span>

// WithBody adds a request body
func WithBody(body string) RequestOption <span class="cov8" title="1">{
        return func(r *http.Request) </span><span class="cov8" title="1">{
                r.Body = io.NopCloser(strings.NewReader(body))
                r.ContentLength = int64(len(body))
        }</span>
}

// WithAPIToken adds an Authorization header without Bearer prefix (for API tokens)
func WithAPIToken(token string) RequestOption <span class="cov0" title="0">{
        return WithHeader("Authorization", "Bearer "+token)
}</span>

// WithRawAuth adds a raw Authorization header value
func WithRawAuth(value string) RequestOption <span class="cov8" title="1">{
        return WithHeader("Authorization", value)
}</span>

// WithJSONBody sets Content-Type to application/json and marshals the body to JSON
func WithJSONBody(body any) RequestOption <span class="cov8" title="1">{
        return func(r *http.Request) </span><span class="cov8" title="1">{
                data, err := json.Marshal(body)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">r.Header.Set("Content-Type", "application/json")
                r.Body = io.NopCloser(strings.NewReader(string(data)))
                r.ContentLength = int64(len(data))</span>
        }
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package testutil

import (
        "context"

        "github.com/google/uuid"
        "github.com/stretchr/testify/suite"
        "github.com/uptrace/bun"
)

// BaseSuite provides common test infrastructure with automatic fixture setup.
// Embed this in your test suite to get:
//   - Automatic database setup/teardown per suite
//   - Per-test transaction isolation with rollback (fast cleanup)
//   - Common test fixtures (users, org, project)
//
// Usage:
//
//        type MySuite struct {
//            testutil.BaseSuite
//        }
//
//        func (s *MySuite) TestSomething() {
//            // s.Server, s.ProjectID, s.OrgID are available
//            rec := s.Server.GET("/api/v2/something", testutil.WithAuth("e2e-test-user"))
//        }
type BaseSuite struct {
        suite.Suite
        TestDB    *TestDB
        Server    *TestServer
        Ctx       context.Context
        ProjectID string
        OrgID     string

        // dbSuffix is used to create unique database names
        dbSuffix string
}

// SetDBSuffix sets the database name suffix. Call this in your suite's SetupSuite
// before calling BaseSuite.SetupSuite.
func (s *BaseSuite) SetDBSuffix(suffix string) <span class="cov8" title="1">{
        s.dbSuffix = suffix
}</span>

// SetupSuite creates the test database and server.
// If you override this, call s.BaseSuite.SetupSuite() first.
func (s *BaseSuite) SetupSuite() <span class="cov8" title="1">{
        s.Ctx = context.Background()

        suffix := s.dbSuffix
        if suffix == "" </span><span class="cov0" title="0">{
                suffix = "test"
        }</span>

        // Create isolated test database
        <span class="cov8" title="1">testDB, err := SetupTestDB(s.Ctx, suffix)
        s.Require().NoError(err, "Failed to setup test database")
        s.TestDB = testDB

        // Create test server with base DB (will be rebuilt per-test with transaction)
        s.Server = NewTestServer(testDB)</span>
}

// TearDownSuite closes the test database.
// If you override this, call s.BaseSuite.TearDownSuite() at the end.
func (s *BaseSuite) TearDownSuite() <span class="cov8" title="1">{
        if s.TestDB != nil </span><span class="cov8" title="1">{
                s.TestDB.Close()
        }</span>
}

// SetupTest starts a transaction and sets up fixtures.
// All changes within a test are automatically rolled back in TearDownTest.
// If you override this, call s.BaseSuite.SetupTest() first.
func (s *BaseSuite) SetupTest() <span class="cov8" title="1">{
        // Start a transaction for test isolation
        err := s.TestDB.BeginTestTx(s.Ctx)
        s.Require().NoError(err, "Failed to begin test transaction")

        // Rebuild server to use the transaction
        db := s.TestDB.GetDB()
        s.Server = newTestServerWithDB(s.TestDB, db)

        // Set up test fixtures (users)
        err = SetupTestFixtures(s.Ctx, s.TestDB.GetDB())
        s.Require().NoError(err)

        // Create default org and project
        s.OrgID = uuid.New().String()
        s.ProjectID = uuid.New().String()

        err = CreateTestOrganization(s.Ctx, s.TestDB.GetDB(), s.OrgID, "Test Org")
        s.Require().NoError(err)

        err = CreateTestProject(s.Ctx, s.TestDB.GetDB(), TestProject{
                ID:    s.ProjectID,
                OrgID: s.OrgID,
                Name:  "Test Project",
        }, AdminUser.ID)
        s.Require().NoError(err)
}</span>

// TearDownTest rolls back the transaction, discarding all test changes.
// This is much faster than TRUNCATE (~0ms vs ~500ms).
// Override this if you need test-specific cleanup.
func (s *BaseSuite) TearDownTest() <span class="cov8" title="1">{
        _ = s.TestDB.RollbackTestTx()
}</span>

// DB returns the current database connection (transaction if active, otherwise base DB).
func (s *BaseSuite) DB() bun.IDB <span class="cov0" title="0">{
        return s.TestDB.GetDB()
}</span>
</pre>
		
		<pre class="file" id="file111" style="display: none">// Package version provides build-time version information.
// The variables are set via ldflags during build.
package version

// These variables are set at build time via -ldflags
var (
        // Version is the semantic version (e.g., "1.0.0")
        Version = "dev"

        // GitCommit is the short git commit hash
        GitCommit = "unknown"

        // BuildTime is the build timestamp in RFC3339 format
        BuildTime = "unknown"
)

// Info returns all version information as a struct
func Info() VersionInfo <span class="cov0" title="0">{
        return VersionInfo{
                Version:   Version,
                GitCommit: GitCommit,
                BuildTime: BuildTime,
        }
}</span>

// VersionInfo holds all version-related information
type VersionInfo struct {
        Version   string `json:"version"`
        GitCommit string `json:"git_commit"`
        BuildTime string `json:"build_time"`
}
</pre>
		
		<pre class="file" id="file112" style="display: none">// Package adk provides Google ADK-Go integration for agent workflows.
package adk

import (
        "context"
        "fmt"
        "log/slog"

        "go.uber.org/fx"
        "google.golang.org/adk/model"
        "google.golang.org/adk/model/gemini"
        "google.golang.org/genai"

        "github.com/emergent/emergent-core/internal/config"
)

// Module provides the ADK ModelFactory as an fx module
var Module = fx.Module("adk",
        fx.Provide(provideModelFactory),
)

// provideModelFactory creates a ModelFactory from the main config
func provideModelFactory(cfg *config.Config, log *slog.Logger) *ModelFactory <span class="cov8" title="1">{
        return NewModelFactory(&amp;cfg.LLM, log)
}</span>

// ModelFactory creates ADK-compatible LLM models from configuration.
type ModelFactory struct {
        cfg *config.LLMConfig
        log *slog.Logger
}

// NewModelFactory creates a new ModelFactory with the given configuration.
func NewModelFactory(cfg *config.LLMConfig, log *slog.Logger) *ModelFactory <span class="cov8" title="1">{
        return &amp;ModelFactory{
                cfg: cfg,
                log: log,
        }
}</span>

// CreateModel creates an ADK-compatible Gemini model for Vertex AI.
//
// The model uses Vertex AI backend with the configured GCP project and location.
// If the configuration is missing required fields, an error is returned.
func (f *ModelFactory) CreateModel(ctx context.Context) (model.LLM, error) <span class="cov8" title="1">{
        return f.CreateModelWithName(ctx, f.cfg.Model)
}</span>

// CreateModelWithName creates an ADK-compatible Gemini model with a specific model name.
//
// This allows overriding the default model for specific use cases (e.g., using
// a different model for extraction vs verification).
func (f *ModelFactory) CreateModelWithName(ctx context.Context, modelName string) (model.LLM, error) <span class="cov8" title="1">{
        if f.cfg.GCPProjectID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("GCP project ID is required for Vertex AI")
        }</span>
        <span class="cov8" title="1">if f.cfg.VertexAILocation == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Vertex AI location is required")
        }</span>
        <span class="cov8" title="1">if modelName == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("model name is required")
        }</span>

        // Configure for Vertex AI backend
        <span class="cov0" title="0">clientCfg := &amp;genai.ClientConfig{
                Backend:  genai.BackendVertexAI,
                Project:  f.cfg.GCPProjectID,
                Location: f.cfg.VertexAILocation,
        }

        f.log.Debug("creating ADK Gemini model",
                slog.String("model", modelName),
                slog.String("project", f.cfg.GCPProjectID),
                slog.String("location", f.cfg.VertexAILocation),
        )

        llm, err := gemini.NewModel(ctx, modelName, clientCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create Gemini model: %w", err)
        }</span>

        <span class="cov0" title="0">return llm, nil</span>
}

// DefaultGenerateConfig returns a default GenerateContentConfig for extraction tasks.
//
// The config uses low temperature for deterministic JSON extraction output.
func (f *ModelFactory) DefaultGenerateConfig() *genai.GenerateContentConfig <span class="cov8" title="1">{
        return &amp;genai.GenerateContentConfig{
                Temperature:     ptrFloat32(float32(f.cfg.Temperature)),
                MaxOutputTokens: int32(f.cfg.MaxOutputTokens),
        }
}</span>

// ExtractionGenerateConfig returns a GenerateContentConfig optimized for entity extraction.
//
// Uses temperature=0 for deterministic structured output.
func (f *ModelFactory) ExtractionGenerateConfig() *genai.GenerateContentConfig <span class="cov8" title="1">{
        return &amp;genai.GenerateContentConfig{
                Temperature:     ptrFloat32(0.0),
                MaxOutputTokens: int32(f.cfg.MaxOutputTokens),
        }
}</span>

// IsEnabled returns true if the LLM configuration is valid for creating models.
func (f *ModelFactory) IsEnabled() bool <span class="cov8" title="1">{
        return f.cfg.IsEnabled()
}</span>

// ModelName returns the configured default model name.
func (f *ModelFactory) ModelName() string <span class="cov8" title="1">{
        return f.cfg.Model
}</span>

// Helper function for pointer values
func ptrFloat32(v float32) *float32 <span class="cov8" title="1">{
        return &amp;v
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package apperror

import (
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
)

// Error represents an application error with HTTP status and error code
type Error struct {
        HTTPStatus int
        Code       string
        Message    string
        Internal   error
        Details    map[string]any
}

// Error implements the error interface
func (e *Error) Error() string <span class="cov8" title="1">{
        if e.Internal != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: %s (%v)", e.Code, e.Message, e.Internal)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s: %s", e.Code, e.Message)</span>
}

// Unwrap returns the internal error
func (e *Error) Unwrap() error <span class="cov8" title="1">{
        return e.Internal
}</span>

// ToEchoError converts the app error to an echo.HTTPError for proper handling
func (e *Error) ToEchoError() *echo.HTTPError <span class="cov8" title="1">{
        errBody := map[string]any{
                "code":    e.Code,
                "message": e.Message,
        }
        if len(e.Details) &gt; 0 </span><span class="cov8" title="1">{
                errBody["details"] = e.Details
        }</span>
        <span class="cov8" title="1">return echo.NewHTTPError(e.HTTPStatus, map[string]any{
                "error": errBody,
        })</span>
}

// WithInternal returns a copy of the error with an internal error attached
func (e *Error) WithInternal(err error) *Error <span class="cov8" title="1">{
        return &amp;Error{
                HTTPStatus: e.HTTPStatus,
                Code:       e.Code,
                Message:    e.Message,
                Internal:   err,
        }
}</span>

// WithMessage returns a copy of the error with a custom message
func (e *Error) WithMessage(message string) *Error <span class="cov8" title="1">{
        return &amp;Error{
                HTTPStatus: e.HTTPStatus,
                Code:       e.Code,
                Message:    message,
                Internal:   e.Internal,
                Details:    e.Details,
        }
}</span>

// WithDetails returns a copy of the error with details attached
func (e *Error) WithDetails(details map[string]any) *Error <span class="cov8" title="1">{
        return &amp;Error{
                HTTPStatus: e.HTTPStatus,
                Code:       e.Code,
                Message:    e.Message,
                Internal:   e.Internal,
                Details:    details,
        }
}</span>

// New creates a new application error
func New(status int, code, message string) *Error <span class="cov8" title="1">{
        return &amp;Error{
                HTTPStatus: status,
                Code:       code,
                Message:    message,
        }
}</span>

// Common error definitions
var (
        // Authentication errors
        ErrUnauthorized  = New(http.StatusUnauthorized, "unauthorized", "Authentication required")
        ErrInvalidToken  = New(http.StatusUnauthorized, "invalid_token", "Invalid or expired token")
        ErrTokenExpired  = New(http.StatusUnauthorized, "token_expired", "Token has expired")
        ErrMissingToken  = New(http.StatusUnauthorized, "missing_token", "Missing authorization token")

        // Authorization errors
        ErrForbidden     = New(http.StatusForbidden, "forbidden", "Access denied")
        ErrInsufficientPermissions = New(http.StatusForbidden, "insufficient_permissions", "Insufficient permissions")

        // Resource errors
        ErrNotFound      = New(http.StatusNotFound, "not_found", "Resource not found")
        ErrUserNotFound  = New(http.StatusNotFound, "user_not_found", "User not found")
        ErrProjectNotFound = New(http.StatusNotFound, "project_not_found", "Project not found")

        // Validation errors
        ErrBadRequest    = New(http.StatusBadRequest, "bad_request", "Invalid request")
        ErrValidation    = New(http.StatusUnprocessableEntity, "validation_error", "Validation failed")

        // Server errors
        ErrInternal      = New(http.StatusInternalServerError, "internal_error", "An internal error occurred")
        ErrDatabase      = New(http.StatusInternalServerError, "database_error", "Database operation failed")
)

// ToHTTPError converts an app error to an HTTP-friendly format
func ToHTTPError(err error) (int, map[string]any) <span class="cov8" title="1">{
        if appErr, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                errBody := map[string]any{
                        "code":    appErr.Code,
                        "message": appErr.Message,
                }
                if len(appErr.Details) &gt; 0 </span><span class="cov8" title="1">{
                        errBody["details"] = appErr.Details
                }</span>
                <span class="cov8" title="1">return appErr.HTTPStatus, map[string]any{
                        "error": errBody,
                }</span>
        }

        // Default to internal server error for unknown errors
        <span class="cov8" title="1">return http.StatusInternalServerError, map[string]any{
                "error": map[string]any{
                        "code":    "internal_error",
                        "message": "An internal error occurred",
                },
        }</span>
}

// NewBadRequest creates a bad request error with a custom message
func NewBadRequest(message string) *Error <span class="cov8" title="1">{
        return ErrBadRequest.WithMessage(message)
}</span>

// NewNotFound creates a not found error for a resource type and ID
func NewNotFound(resourceType, id string) *Error <span class="cov8" title="1">{
        return ErrNotFound.WithMessage(fmt.Sprintf("%s '%s' not found", resourceType, id))
}</span>

// NewInternal creates an internal error with a message and optional wrapped error
func NewInternal(message string, err error) *Error <span class="cov8" title="1">{
        return &amp;Error{
                HTTPStatus: http.StatusInternalServerError,
                Code:       "internal_error",
                Message:    message,
                Internal:   err,
        }
}</span>

// NewForbidden creates a forbidden error with a custom message
func NewForbidden(message string) *Error <span class="cov8" title="1">{
        return ErrForbidden.WithMessage(message)
}</span>
</pre>
		
		<pre class="file" id="file114" style="display: none">package apperror

import (
        "log/slog"
        "net/http"

        "github.com/labstack/echo/v4"
)

// HTTPErrorHandler returns an Echo error handler that formats errors to match NestJS format.
// This is the canonical error handler used by both production and test servers.
func HTTPErrorHandler(log *slog.Logger) echo.HTTPErrorHandler <span class="cov8" title="1">{
        return func(err error, c echo.Context) </span><span class="cov8" title="1">{
                if c.Response().Committed </span><span class="cov8" title="1">{
                        return
                }</span>

                // Default error response
                <span class="cov8" title="1">code := http.StatusInternalServerError
                errorObj := map[string]any{
                        "code":    "internal_error",
                        "message": "An internal error occurred",
                }

                // Handle our custom app errors first
                if appErr, ok := err.(*Error); ok </span><span class="cov8" title="1">{
                        code = appErr.HTTPStatus
                        errorObj["code"] = appErr.Code
                        errorObj["message"] = appErr.Message
                }</span> else<span class="cov8" title="1"> if he, ok := err.(*echo.HTTPError); ok </span><span class="cov8" title="1">{
                        // Handle Echo HTTP errors
                        code = he.Code

                        // Check if the message is a structured error map (e.g., from RequireScopes)
                        if msgMap, ok := he.Message.(map[string]any); ok </span><span class="cov8" title="1">{
                                if errInner, ok := msgMap["error"].(map[string]any); ok </span><span class="cov8" title="1">{
                                        // Copy all fields from the inner error object
                                        for k, v := range errInner </span><span class="cov8" title="1">{
                                                errorObj[k] = v
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> if msg, ok := he.Message.(string); ok </span><span class="cov8" title="1">{
                                errorObj["message"] = msg
                                // Map HTTP status to error code
                                switch code </span>{
                                case http.StatusUnauthorized:<span class="cov8" title="1">
                                        errorObj["code"] = "unauthorized"</span>
                                case http.StatusForbidden:<span class="cov8" title="1">
                                        errorObj["code"] = "forbidden"</span>
                                case http.StatusNotFound:<span class="cov8" title="1">
                                        errorObj["code"] = "not_found"</span>
                                case http.StatusBadRequest:<span class="cov8" title="1">
                                        errorObj["code"] = "bad_request"</span>
                                case http.StatusConflict:<span class="cov8" title="1">
                                        errorObj["code"] = "conflict"</span>
                                case http.StatusUnprocessableEntity:<span class="cov8" title="1">
                                        errorObj["code"] = "validation_error"</span>
                                }
                        }
                }

                // Log error (5xx errors get logged at error level)
                <span class="cov8" title="1">if code &gt;= 500 </span><span class="cov8" title="1">{
                        log.Error("request error",
                                slog.Int("status", code),
                                slog.String("error", err.Error()),
                        )
                }</span>

                // Format response to match NestJS error format
                <span class="cov8" title="1">response := map[string]any{
                        "error": errorObj,
                }

                // Send error response
                if c.Request().Method == http.MethodHead </span><span class="cov8" title="1">{
                        c.NoContent(code)
                }</span> else<span class="cov8" title="1"> {
                        c.JSON(code, response)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file115" style="display: none">package auth

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "errors"
        "log/slog"
        "net/http"
        "strings"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/pkg/apperror"
        "github.com/emergent/emergent-core/pkg/logger"
)

// AuthUser represents an authenticated user
type AuthUser struct {
        // Internal UUID primary key from user_profiles.id
        ID string `json:"id"`

        // External auth provider ID (e.g., Zitadel subject) from user_profiles.zitadel_user_id
        Sub string `json:"sub"`

        // User's email address
        Email string `json:"email,omitempty"`

        // Granted scopes from token
        Scopes []string `json:"scopes,omitempty"`

        // Project ID from X-Project-ID header
        ProjectID string `json:"projectId,omitempty"`

        // Organization ID from X-Org-ID header
        OrgID string `json:"orgId,omitempty"`

        // API token project ID (if authenticated via API token)
        APITokenProjectID string `json:"apiTokenProjectId,omitempty"`

        // API token ID (if authenticated via API token)
        APITokenID string `json:"apiTokenId,omitempty"`
}

// ContextKey for storing auth user in context
type contextKey string

const (
        UserContextKey    contextKey = "auth_user"
        ProjectContextKey contextKey = "project_context"
)

// GetUser retrieves the authenticated user from the Echo context
func GetUser(c echo.Context) *AuthUser <span class="cov8" title="1">{
        if user, ok := c.Get(string(UserContextKey)).(*AuthUser); ok </span><span class="cov8" title="1">{
                return user
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetProjectID extracts and parses the project ID from the auth user context.
// Returns ErrUnauthorized if no user, or ErrBadRequest if no project ID.
func GetProjectID(c echo.Context) (string, error) <span class="cov8" title="1">{
        user := GetUser(c)
        if user == nil </span><span class="cov0" title="0">{
                return "", apperror.ErrUnauthorized
        }</span>

        // First check API token project ID (automatically set for API token auth)
        <span class="cov8" title="1">if user.APITokenProjectID != "" </span><span class="cov0" title="0">{
                return user.APITokenProjectID, nil
        }</span>

        // Then check X-Project-ID header
        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov0" title="0">{
                return "", apperror.ErrBadRequest.WithMessage("x-project-id header required")
        }</span>

        <span class="cov8" title="1">return user.ProjectID, nil</span>
}

// Middleware handles authentication for routes
type Middleware struct {
        db         bun.IDB
        cfg        *config.Config
        log        *slog.Logger
        userSvc    *UserProfileService
        zitadelSvc *ZitadelService
        debugToken string
}

// NewMiddleware creates a new auth middleware
func NewMiddleware(db bun.IDB, cfg *config.Config, log *slog.Logger, userSvc *UserProfileService) *Middleware <span class="cov8" title="1">{
        m := &amp;Middleware{
                db:         db,
                cfg:        cfg,
                log:        log.With(logger.Scope("auth")),
                userSvc:    userSvc,
                zitadelSvc: NewZitadelService(db, cfg, log),
        }

        // Set up debug token for development
        if cfg.Debug &amp;&amp; cfg.Zitadel.DebugToken != "" </span><span class="cov0" title="0">{
                m.debugToken = "Bearer " + cfg.Zitadel.DebugToken
        }</span>

        <span class="cov8" title="1">return m</span>
}

// RequireAuth returns middleware that requires authentication
func (m *Middleware) RequireAuth() echo.MiddlewareFunc <span class="cov8" title="1">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        user, err := m.authenticate(c)
                        if err != nil </span><span class="cov8" title="1">{
                                m.log.Warn("authentication failed", logger.Error(err))
                                return m.authError(c, err)
                        }</span>

                        // Extract project context from headers
                        <span class="cov8" title="1">user.ProjectID = c.Request().Header.Get("X-Project-ID")
                        user.OrgID = c.Request().Header.Get("X-Org-ID")

                        // Store user in context
                        c.Set(string(UserContextKey), user)

                        return next(c)</span>
                }
        }
}

// RequireProjectID returns middleware that requires X-Project-ID header
func (m *Middleware) RequireProjectID() echo.MiddlewareFunc <span class="cov8" title="1">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        user := GetUser(c)
                        if user == nil </span><span class="cov0" title="0">{
                                return apperror.ErrUnauthorized
                        }</span>

                        <span class="cov8" title="1">if user.ProjectID == "" </span><span class="cov8" title="1">{
                                return echo.NewHTTPError(http.StatusBadRequest, map[string]any{
                                        "error": map[string]any{
                                                "code":    "bad_request",
                                                "message": "x-project-id header required",
                                        },
                                })
                        }</span>

                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}

// RequireScopes returns middleware that requires specific scopes
func (m *Middleware) RequireScopes(scopes ...string) echo.MiddlewareFunc <span class="cov8" title="1">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov8" title="1">{
                return func(c echo.Context) error </span><span class="cov8" title="1">{
                        user := GetUser(c)
                        if user == nil </span><span class="cov0" title="0">{
                                return apperror.ErrUnauthorized
                        }</span>

                        // Check if user has all required scopes
                        <span class="cov8" title="1">userScopes := make(map[string]bool)
                        for _, s := range user.Scopes </span><span class="cov8" title="1">{
                                userScopes[s] = true
                        }</span>

                        <span class="cov8" title="1">missing := []string{}
                        for _, required := range scopes </span><span class="cov8" title="1">{
                                if !userScopes[required] </span><span class="cov8" title="1">{
                                        missing = append(missing, required)
                                }</span>
                        }

                        <span class="cov8" title="1">if len(missing) &gt; 0 </span><span class="cov8" title="1">{
                                return echo.NewHTTPError(http.StatusForbidden, map[string]any{
                                        "error": map[string]any{
                                                "code":    "forbidden",
                                                "message": "Insufficient permissions",
                                                "details": map[string]any{
                                                        "missing": missing,
                                                },
                                        },
                                })
                        }</span>

                        <span class="cov8" title="1">return next(c)</span>
                }
        }
}

// authenticate extracts and validates the token from the request
func (m *Middleware) authenticate(c echo.Context) (*AuthUser, error) <span class="cov8" title="1">{
        // Extract token from Authorization header or query param
        token := m.extractToken(c.Request())
        if token == "" </span><span class="cov8" title="1">{
                return nil, apperror.ErrMissingToken
        }</span>

        // Validate token and get user
        <span class="cov8" title="1">return m.validateToken(c.Request().Context(), token)</span>
}

// extractToken extracts the bearer token from request
func (m *Middleware) extractToken(r *http.Request) string <span class="cov8" title="1">{
        // Check Authorization header first
        auth := r.Header.Get("Authorization")
        if auth != "" </span><span class="cov8" title="1">{
                if strings.HasPrefix(auth, "Bearer ") </span><span class="cov8" title="1">{
                        return strings.TrimPrefix(auth, "Bearer ")
                }</span>
        }

        // Fall back to query parameter (for SSE endpoints)
        <span class="cov8" title="1">if token := r.URL.Query().Get("token"); token != "" </span><span class="cov8" title="1">{
                return token
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// validateToken validates the token and returns the authenticated user
func (m *Middleware) validateToken(ctx context.Context, token string) (*AuthUser, error) <span class="cov8" title="1">{
        // 1. Check for API token (emt_ prefix)
        if strings.HasPrefix(token, "emt_") </span><span class="cov8" title="1">{
                return m.validateAPIToken(ctx, token)
        }</span>

        // 2. Check for static test tokens (development only)
        <span class="cov8" title="1">if m.cfg.Debug || m.cfg.Environment != "production" </span><span class="cov8" title="1">{
                if user := m.checkTestToken(ctx, token); user != nil </span><span class="cov8" title="1">{
                        return user, nil
                }</span>
        }

        // 3. Check introspection cache
        <span class="cov8" title="1">cached, err := m.getCachedIntrospection(ctx, token)
        if err == nil &amp;&amp; cached != nil </span><span class="cov8" title="1">{
                return m.ensureUserProfile(ctx, cached)
        }</span>

        // 4. Zitadel introspection (if not disabled)
        <span class="cov8" title="1">if !m.cfg.Zitadel.DisableIntrospection </span><span class="cov8" title="1">{
                introspection, err := m.introspectToken(ctx, token)
                if err == nil &amp;&amp; introspection != nil </span><span class="cov0" title="0">{
                        // Cache the introspection result
                        _ = m.cacheIntrospection(ctx, token, introspection)
                        return m.ensureUserProfile(ctx, introspection)
                }</span>
        }

        // 5. Local JWT verification as fallback
        <span class="cov8" title="1">claims, err := m.verifyJWT(ctx, token)
        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.ErrInvalidToken.WithInternal(err)
        }</span>

        <span class="cov0" title="0">return m.ensureUserProfile(ctx, claims)</span>
}

// TokenClaims represents parsed token claims
type TokenClaims struct {
        Sub       string    // Subject (user ID)
        Email     string    // Email address
        Scopes    []string  // Token scopes
        ExpiresAt time.Time // Token expiration
}

// validateAPIToken validates an API token (emt_* prefix)
func (m *Middleware) validateAPIToken(ctx context.Context, token string) (*AuthUser, error) <span class="cov8" title="1">{
        // Hash the token for lookup (SHA256 = 64 hex chars fits varchar(64))
        hash := sha256.Sum256([]byte(token))
        tokenHash := hex.EncodeToString(hash[:])

        // Query the api_tokens table
        var result struct {
                ID        string   `bun:"id"`
                UserID    string   `bun:"user_id"`
                ProjectID string   `bun:"project_id"`
                Scopes    []string `bun:"scopes,array"`
        }

        err := m.db.NewSelect().
                TableExpr("core.api_tokens").
                Column("id", "user_id", "project_id", "scopes").
                Where("token_hash = ?", tokenHash).
                Where("revoked_at IS NULL").
                Scan(ctx, &amp;result)

        if err != nil </span><span class="cov8" title="1">{
                return nil, apperror.ErrInvalidToken.WithInternal(err)
        }</span>

        // Get user profile
        <span class="cov8" title="1">user, err := m.userSvc.GetByID(ctx, result.UserID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrInvalidToken.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return &amp;AuthUser{
                ID:                user.ID,
                Sub:               user.ZitadelUserID,
                Email:             user.Email,
                Scopes:            result.Scopes,
                APITokenProjectID: result.ProjectID,
                APITokenID:        result.ID,
        }, nil</span>
}

// checkTestToken checks for static test tokens (development only)
// Test token mappings must match testutil.TestTokenConfigs for consistency.
func (m *Middleware) checkTestToken(ctx context.Context, token string) *AuthUser <span class="cov8" title="1">{
        // Test token patterns - keep in sync with testutil.TestTokenConfigs
        testTokens := map[string]struct {
                sub    string
                scopes []string
        }{
                // Simple tokens
                "no-scope":   {sub: "test-user-no-scope", scopes: []string{}},
                "with-scope": {sub: "test-user-with-scope", scopes: []string{"documents:read", "documents:write", "project:read"}},
                "read-only":  {sub: "test-user-read-only", scopes: []string{"documents:read", "project:read", "org:read", "chunks:read", "search:read", "graph:read"}},
                "graph-read": {sub: "test-user-graph-read", scopes: []string{"graph:read", "graph:search:read"}},
                "all-scopes": {sub: "test-user-all-scopes", scopes: GetAllScopes()},
                // E2E tokens - map to AdminUser fixture for predictable test user IDs
                "e2e-test-user":   {sub: "test-admin-user", scopes: GetAllScopes()},
                "e2e-query-token": {sub: "test-admin-user", scopes: GetAllScopes()},
        }

        // Check if token is in the known test tokens map
        if config, ok := testTokens[token]; ok </span><span class="cov8" title="1">{
                user, err := m.userSvc.EnsureProfile(ctx, config.sub, nil)
                if err != nil </span><span class="cov0" title="0">{
                        m.log.Error("failed to ensure test user profile", logger.Error(err))
                        return nil
                }</span>

                <span class="cov8" title="1">return &amp;AuthUser{
                        ID:     user.ID,
                        Sub:    config.sub,
                        Scopes: config.scopes,
                }</span>
        }

        // Check for dynamic e2e-* pattern (tokens not in the map above)
        // These create ad-hoc user profiles using the token as the subject ID
        <span class="cov8" title="1">if strings.HasPrefix(token, "e2e-") </span><span class="cov0" title="0">{
                user, err := m.userSvc.EnsureProfile(ctx, token, nil)
                if err != nil </span><span class="cov0" title="0">{
                        m.log.Error("failed to ensure dynamic e2e user profile", logger.Error(err))
                        return nil
                }</span>

                <span class="cov0" title="0">return &amp;AuthUser{
                        ID:     user.ID,
                        Sub:    token,
                        Scopes: GetAllScopes(),
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// ensureUserProfile ensures the user has a profile and returns AuthUser
func (m *Middleware) ensureUserProfile(ctx context.Context, claims *TokenClaims) (*AuthUser, error) <span class="cov8" title="1">{
        profile := &amp;UserProfileInfo{
                Email: claims.Email,
        }

        user, err := m.userSvc.EnsureProfile(ctx, claims.Sub, profile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, apperror.ErrInternal.WithInternal(err)
        }</span>

        <span class="cov8" title="1">return &amp;AuthUser{
                ID:     user.ID,
                Sub:    claims.Sub,
                Email:  claims.Email,
                Scopes: claims.Scopes,
        }, nil</span>
}

// getCachedIntrospection retrieves cached introspection result
func (m *Middleware) getCachedIntrospection(ctx context.Context, token string) (*TokenClaims, error) <span class="cov8" title="1">{
        hash := sha256.Sum256([]byte(token))
        tokenHash := hex.EncodeToString(hash[:])

        var result struct {
                IntrospectionData map[string]any `bun:"introspection_data,type:jsonb"`
                ExpiresAt         time.Time      `bun:"expires_at"`
        }

        err := m.db.NewSelect().
                TableExpr("kb.auth_introspection_cache").
                Column("introspection_data", "expires_at").
                Where("token_hash = ?", tokenHash).
                Where("expires_at &gt; NOW()").
                Scan(ctx, &amp;result)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Parse cached data into TokenClaims
        <span class="cov8" title="1">claims := &amp;TokenClaims{}
        if sub, ok := result.IntrospectionData["sub"].(string); ok </span><span class="cov8" title="1">{
                claims.Sub = sub
        }</span>
        <span class="cov8" title="1">if email, ok := result.IntrospectionData["email"].(string); ok </span><span class="cov8" title="1">{
                claims.Email = email
        }</span>
        <span class="cov8" title="1">if scope, ok := result.IntrospectionData["scope"].(string); ok </span><span class="cov8" title="1">{
                claims.Scopes = strings.Split(scope, " ")
        }</span>
        <span class="cov8" title="1">claims.ExpiresAt = result.ExpiresAt

        return claims, nil</span>
}

// cacheIntrospection stores introspection result in cache
func (m *Middleware) cacheIntrospection(ctx context.Context, token string, claims *TokenClaims) error <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(token))
        tokenHash := hex.EncodeToString(hash[:])

        // Calculate TTL (use token expiration or config TTL, whichever is sooner)
        ttl := m.cfg.Zitadel.IntrospectCacheTTL
        tokenTTL := time.Until(claims.ExpiresAt)
        if tokenTTL &gt; 0 &amp;&amp; tokenTTL &lt; ttl </span><span class="cov0" title="0">{
                ttl = tokenTTL
        }</span>

        <span class="cov0" title="0">expiresAt := time.Now().Add(ttl)

        data := map[string]any{
                "sub":   claims.Sub,
                "email": claims.Email,
                "scope": strings.Join(claims.Scopes, " "),
        }

        _, err := m.db.NewInsert().
                TableExpr("kb.auth_introspection_cache").
                Model(&amp;struct {
                        TokenHash         string         `bun:"token_hash"`
                        IntrospectionData map[string]any `bun:"introspection_data,type:jsonb"`
                        ExpiresAt         time.Time      `bun:"expires_at"`
                }{
                        TokenHash:         tokenHash,
                        IntrospectionData: data,
                        ExpiresAt:         expiresAt,
                }).
                On("CONFLICT (token_hash) DO UPDATE").
                Set("introspection_data = EXCLUDED.introspection_data").
                Set("expires_at = EXCLUDED.expires_at").
                Exec(ctx)

        return err</span>
}

// introspectToken calls Zitadel to introspect the token
func (m *Middleware) introspectToken(ctx context.Context, token string) (*TokenClaims, error) <span class="cov8" title="1">{
        result, err := m.zitadelSvc.Introspect(ctx, token)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // nil result means introspection is disabled or unavailable
        <span class="cov0" title="0">if result == nil </span><span class="cov0" title="0">{
                return nil, errors.New("introspection unavailable")
        }</span>

        // Inactive token
        <span class="cov0" title="0">if !result.Active </span><span class="cov0" title="0">{
                return nil, errors.New("token is inactive")
        }</span>

        <span class="cov0" title="0">return &amp;TokenClaims{
                Sub:       result.Sub,
                Email:     result.Email,
                Scopes:    ParseScopes(result.Scope),
                ExpiresAt: time.Unix(result.Exp, 0),
        }, nil</span>
}

// verifyJWT verifies the token using local JWKS
func (m *Middleware) verifyJWT(ctx context.Context, token string) (*TokenClaims, error) <span class="cov8" title="1">{
        // For now, JWT verification is not implemented
        // The primary auth flow uses:
        // 1. Test tokens (development)
        // 2. API tokens (emt_* prefix)
        // 3. Cached introspection results
        // 4. Live introspection (if enabled)
        //
        // JWT verification would be a fallback using JWKS:
        // - Fetch JWKS from {issuer}/.well-known/jwks.json
        // - Verify token signature
        // - Validate claims (iss, aud, exp)
        //
        // This requires go-jose library and JWKS caching.
        // TODO: Implement if introspection is insufficient
        return nil, errors.New("JWT verification not implemented - enable introspection or use test tokens")
}</span>

// authError returns a formatted authentication error
func (m *Middleware) authError(c echo.Context, err error) error <span class="cov8" title="1">{
        status, body := apperror.ToHTTPError(err)
        return c.JSON(status, body)
}</span>

// GetAllScopes returns all available scopes (for test tokens)
func GetAllScopes() []string <span class="cov8" title="1">{
        return []string{
                "org:read",
                "org:project:create",
                "org:project:delete",
                "org:invite:create",
                "project:read",
                "project:invite:create",
                "documents:read",
                "documents:write",
                "documents:delete",
                "ingest:write",
                "search:read",
                "chunks:read",
                "chunks:write",
                "chat:use",
                "chat:admin",
                "graph:read",
                "graph:write",
                "graph:search:read",
                "graph:search:debug",
                "notifications:read",
                "notifications:write",
                "extraction:read",
                "extraction:write",
                "schema:read",
                "data:read",
                "data:write",
                "mcp:admin",
                "user-activity:read",
                "user-activity:write",
                "tasks:read",
                "tasks:write",
        }
}</span>
</pre>
		
		<pre class="file" id="file116" style="display: none">package auth

import (
        "context"
        "database/sql"
        "errors"
        "log/slog"
        "strings"
        "time"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/logger"
)

// UserProfile represents a user profile from the database
type UserProfile struct {
        bun.BaseModel  `bun:"table:core.user_profiles"`
        ID             string     `bun:"id,pk,type:uuid"`
        ZitadelUserID  string     `bun:"zitadel_user_id"`
        FirstName      *string    `bun:"first_name"`
        LastName       *string    `bun:"last_name"`
        DisplayName    *string    `bun:"display_name"`
        Email          string     `bun:"-"` // Fetched separately from user_emails
        CreatedAt      time.Time  `bun:"created_at"`
        UpdatedAt      time.Time  `bun:"updated_at"`
        DeletedAt      *time.Time `bun:"deleted_at"`
        DeletedBy      *string    `bun:"deleted_by"`
}

// UserProfileInfo contains optional profile information for upsert
type UserProfileInfo struct {
        FirstName   string
        LastName    string
        DisplayName string
        Email       string
}

// UserProfileService handles user profile operations
type UserProfileService struct {
        db  bun.IDB
        log *slog.Logger
}

// NewUserProfileService creates a new user profile service
func NewUserProfileService(db bun.IDB, log *slog.Logger) *UserProfileService <span class="cov8" title="1">{
        return &amp;UserProfileService{
                db:  db,
                log: log.With(logger.Scope("user-profile")),
        }
}</span>

// GetByID retrieves a user profile by internal ID
func (s *UserProfileService) GetByID(ctx context.Context, id string) (*UserProfile, error) <span class="cov8" title="1">{
        var profile UserProfile
        err := s.db.NewSelect().
                TableExpr("core.user_profiles").
                Column("id", "zitadel_user_id", "first_name", "last_name", "display_name", "created_at", "updated_at", "deleted_at", "deleted_by").
                Where("id = ?", id).
                Where("deleted_at IS NULL").
                Scan(ctx, &amp;profile)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, errors.New("user not found")
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Fetch email
        <span class="cov8" title="1">profile.Email, _ = s.getEmail(ctx, profile.ID)

        return &amp;profile, nil</span>
}

// GetByZitadelUserID retrieves a user profile by Zitadel user ID
func (s *UserProfileService) GetByZitadelUserID(ctx context.Context, zitadelUserID string) (*UserProfile, error) <span class="cov8" title="1">{
        var profile UserProfile
        err := s.db.NewSelect().
                TableExpr("core.user_profiles").
                Column("id", "zitadel_user_id", "first_name", "last_name", "display_name", "created_at", "updated_at", "deleted_at", "deleted_by").
                Where("zitadel_user_id = ?", zitadelUserID).
                Where("deleted_at IS NULL").
                Scan(ctx, &amp;profile)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, nil // Not found, not an error
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // Fetch email
        <span class="cov8" title="1">profile.Email, _ = s.getEmail(ctx, profile.ID)

        return &amp;profile, nil</span>
}

// EnsureProfile ensures a user profile exists for the given subject ID
// This matches the NestJS upsertBase behavior
func (s *UserProfileService) EnsureProfile(ctx context.Context, subjectID string, info *UserProfileInfo) (*UserProfile, error) <span class="cov8" title="1">{
        // 1. Check for active (non-deleted) user profile
        profile, err := s.GetByZitadelUserID(ctx, subjectID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if profile != nil </span><span class="cov8" title="1">{
                // Profile exists and is active, sync email if provided
                if info != nil &amp;&amp; info.Email != "" </span><span class="cov8" title="1">{
                        _ = s.syncEmail(ctx, profile.ID, info.Email)
                }</span>
                <span class="cov8" title="1">return profile, nil</span>
        }

        // 2. Check for soft-deleted profile to reactivate
        <span class="cov0" title="0">var deletedProfile UserProfile
        err = s.db.NewSelect().
                TableExpr("core.user_profiles").
                Column("id", "zitadel_user_id", "first_name", "last_name", "display_name", "created_at", "updated_at", "deleted_at", "deleted_by").
                Where("zitadel_user_id = ?", subjectID).
                Where("deleted_at IS NOT NULL").
                Scan(ctx, &amp;deletedProfile)

        if err == nil &amp;&amp; deletedProfile.ID != "" </span><span class="cov0" title="0">{
                // Reactivate the profile
                s.log.Info("reactivating soft-deleted user profile",
                        slog.String("profile_id", deletedProfile.ID),
                        slog.String("zitadel_user_id", subjectID),
                )

                _, err = s.db.NewUpdate().
                        TableExpr("core.user_profiles").
                        Set("deleted_at = NULL").
                        Set("deleted_by = NULL").
                        Set("welcome_email_sent_at = NULL").
                        Set("updated_at = NOW()").
                        Where("id = ?", deletedProfile.ID).
                        Exec(ctx)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">deletedProfile.DeletedAt = nil
                deletedProfile.DeletedBy = nil

                // Sync email if provided
                if info != nil &amp;&amp; info.Email != "" </span><span class="cov0" title="0">{
                        _ = s.syncEmail(ctx, deletedProfile.ID, info.Email)
                        deletedProfile.Email = info.Email
                }</span>

                <span class="cov0" title="0">return &amp;deletedProfile, nil</span>
        }

        // 3. Create new profile (with conflict handling for race conditions)
        <span class="cov0" title="0">s.log.Info("creating new user profile",
                slog.String("zitadel_user_id", subjectID),
        )

        newProfile := &amp;UserProfile{
                ZitadelUserID: subjectID,
        }

        if info != nil </span><span class="cov0" title="0">{
                if info.FirstName != "" </span><span class="cov0" title="0">{
                        newProfile.FirstName = &amp;info.FirstName
                }</span>
                <span class="cov0" title="0">if info.LastName != "" </span><span class="cov0" title="0">{
                        newProfile.LastName = &amp;info.LastName
                }</span>
                <span class="cov0" title="0">if info.DisplayName != "" </span><span class="cov0" title="0">{
                        newProfile.DisplayName = &amp;info.DisplayName
                }</span>
        }

        <span class="cov0" title="0">_, err = s.db.NewInsert().
                TableExpr("core.user_profiles").
                Model(newProfile).
                ExcludeColumn("id"). // Let database generate UUID
                On("CONFLICT (zitadel_user_id) DO UPDATE").
                Set("updated_at = NOW()").
                Returning("id, created_at, updated_at").
                Exec(ctx)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sync email if provided
        <span class="cov0" title="0">if info != nil &amp;&amp; info.Email != "" </span><span class="cov0" title="0">{
                _ = s.syncEmail(ctx, newProfile.ID, info.Email)
                newProfile.Email = info.Email
        }</span>

        <span class="cov0" title="0">return newProfile, nil</span>
}

// getEmail retrieves the verified email for a user
func (s *UserProfileService) getEmail(ctx context.Context, userID string) (string, error) <span class="cov8" title="1">{
        var email string
        err := s.db.NewSelect().
                TableExpr("core.user_emails").
                Column("email").
                Where("user_id = ?", userID).
                Where("verified = true").
                Limit(1).
                Scan(ctx, &amp;email)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return email, nil</span>
}

// syncEmail syncs the user's email to the user_emails table
func (s *UserProfileService) syncEmail(ctx context.Context, userID, email string) error <span class="cov8" title="1">{
        if email == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        // Normalize email
        <span class="cov8" title="1">email = strings.TrimSpace(strings.ToLower(email))

        // Check if email already exists for this user
        var existingID string
        err := s.db.NewSelect().
                TableExpr("core.user_emails").
                Column("id").
                Where("user_id = ?", userID).
                Where("email = ?", email).
                Scan(ctx, &amp;existingID)

        if err == nil &amp;&amp; existingID != "" </span><span class="cov8" title="1">{
                // Email already exists
                return nil
        }</span>

        // Insert new email (unique constraint is on email only, not user_id+email)
        <span class="cov0" title="0">_, err = s.db.NewInsert().
                TableExpr("core.user_emails").
                Model(&amp;struct {
                        UserID   string `bun:"user_id,type:uuid"`
                        Email    string `bun:"email"`
                        Verified bool   `bun:"verified"`
                }{
                        UserID:   userID,
                        Email:    email,
                        Verified: true,
                }).
                On("CONFLICT (email) DO NOTHING").
                Exec(ctx)

        return err</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package auth

import (
        "context"
        "crypto/sha512"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "log/slog"
        "strings"
        "sync"
        "time"

        "github.com/uptrace/bun"
        "github.com/zitadel/oidc/v3/pkg/client"
        "github.com/zitadel/oidc/v3/pkg/client/rs"

        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/pkg/logger"
)

// ZitadelService handles token introspection with Zitadel
type ZitadelService struct {
        db  bun.IDB
        cfg *config.Config
        log *slog.Logger

        // Resource server for introspection (lazy initialized)
        resourceServer rs.ResourceServer
        rsOnce         sync.Once
        rsErr          error

        // Circuit breaker state
        lastFailureTime time.Time
        failureMu       sync.RWMutex

        // Request coalescing - prevent thundering herd
        inflight   map[string]*inflightRequest
        inflightMu sync.Mutex
}

// inflightRequest tracks an in-progress introspection
type inflightRequest struct {
        done   chan struct{}
        result *IntrospectionResult
        err    error
}

// IntrospectionResult holds the parsed introspection response
type IntrospectionResult struct {
        Active   bool      `json:"active"`
        Sub      string    `json:"sub"`
        Email    string    `json:"email"`
        Scope    string    `json:"scope"`    // Space-separated scopes
        Exp      int64     `json:"exp"`      // Expiration timestamp (Unix)
        ClientID string    `json:"client_id"`
        Username string    `json:"username"`
        Name     string    `json:"name"`
        
        // Zitadel-specific claims
        Claims map[string]any `json:"-"` // All claims for role extraction
}

const (
        circuitBreakerCooldown = 30 * time.Second
)

// NewZitadelService creates a new Zitadel introspection service
func NewZitadelService(db bun.IDB, cfg *config.Config, log *slog.Logger) *ZitadelService <span class="cov8" title="1">{
        return &amp;ZitadelService{
                db:       db,
                cfg:      cfg,
                log:      log.With(logger.Scope("zitadel")),
                inflight: make(map[string]*inflightRequest),
        }
}</span>

// Introspect validates a token and returns its claims
// Returns nil, nil if introspection is disabled or unavailable (caller should fall back to other methods)
func (z *ZitadelService) Introspect(ctx context.Context, token string) (*IntrospectionResult, error) <span class="cov8" title="1">{
        // Check if introspection is disabled
        if z.cfg.Zitadel.DisableIntrospection </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        // Check if we have client credentials configured
        <span class="cov8" title="1">if z.cfg.Zitadel.ClientJWT == "" &amp;&amp; z.cfg.Zitadel.ClientJWTPath == "" </span><span class="cov0" title="0">{
                z.log.Debug("no Zitadel client JWT configured, skipping introspection")
                return nil, nil
        }</span>

        // Check circuit breaker
        <span class="cov8" title="1">z.failureMu.RLock()
        if time.Since(z.lastFailureTime) &lt; circuitBreakerCooldown </span><span class="cov0" title="0">{
                z.failureMu.RUnlock()
                z.log.Debug("circuit breaker open, skipping introspection")
                return nil, nil
        }</span>
        <span class="cov8" title="1">z.failureMu.RUnlock()

        // Check PostgreSQL cache first
        cached, err := z.getCached(ctx, token)
        if err == nil &amp;&amp; cached != nil </span><span class="cov0" title="0">{
                z.log.Debug("introspection cache hit")
                return cached, nil
        }</span>

        // Request coalescing - check if there's already a request in flight
        <span class="cov8" title="1">tokenHash := z.hashToken(token)
        z.inflightMu.Lock()
        if req, exists := z.inflight[tokenHash]; exists </span><span class="cov0" title="0">{
                z.inflightMu.Unlock()
                // Wait for existing request
                &lt;-req.done
                return req.result, req.err
        }</span>

        // Create new inflight request
        <span class="cov8" title="1">req := &amp;inflightRequest{done: make(chan struct{})}
        z.inflight[tokenHash] = req
        z.inflightMu.Unlock()

        // Perform introspection
        result, err := z.doIntrospect(ctx, token)

        // Store result and notify waiters
        req.result = result
        req.err = err
        close(req.done)

        // Clean up inflight map
        z.inflightMu.Lock()
        delete(z.inflight, tokenHash)
        z.inflightMu.Unlock()

        return result, err</span>
}

// doIntrospect performs the actual introspection call
func (z *ZitadelService) doIntrospect(ctx context.Context, token string) (*IntrospectionResult, error) <span class="cov8" title="1">{
        // Initialize resource server (lazy, once)
        z.rsOnce.Do(func() </span><span class="cov8" title="1">{
                z.resourceServer, z.rsErr = z.createResourceServer(ctx)
        }</span>)

        <span class="cov8" title="1">if z.rsErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("resource server init failed: %w", z.rsErr)
        }</span>

        // Call Zitadel introspection endpoint
        <span class="cov0" title="0">resp, err := rs.Introspect[*introspectionResponse](ctx, z.resourceServer, token)
        if err != nil </span><span class="cov0" title="0">{
                // Trip circuit breaker on server errors
                z.tripCircuitBreaker()
                return nil, fmt.Errorf("introspection failed: %w", err)
        }</span>

        <span class="cov0" title="0">if resp == nil || !resp.Active </span><span class="cov0" title="0">{
                // Token is inactive - cache this briefly to avoid repeated calls
                result := &amp;IntrospectionResult{Active: false}
                _ = z.cacheResult(ctx, token, result, 1*time.Minute)
                return result, nil
        }</span>

        // Convert response to our result type
        <span class="cov0" title="0">result := &amp;IntrospectionResult{
                Active:   resp.Active,
                Sub:      resp.Subject,
                Email:    resp.GetEmail(),
                Scope:    resp.Scope,
                Exp:      resp.Expiration.AsTime().Unix(),
                ClientID: resp.ClientID,
                Username: resp.GetPreferredUsername(),
                Name:     resp.GetName(),
                Claims:   resp.Claims,
        }

        // Cache the result
        ttl := z.cfg.Zitadel.IntrospectCacheTTL
        tokenTTL := time.Until(resp.Expiration.AsTime())
        if tokenTTL &gt; 0 &amp;&amp; tokenTTL &lt; ttl </span><span class="cov0" title="0">{
                ttl = tokenTTL
        }</span>
        <span class="cov0" title="0">if ttl &gt; 0 </span><span class="cov0" title="0">{
                _ = z.cacheResult(ctx, token, result, ttl)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// createResourceServer initializes the OIDC resource server for introspection
func (z *ZitadelService) createResourceServer(ctx context.Context) (rs.ResourceServer, error) <span class="cov8" title="1">{
        // Load key file
        var keyFile *client.KeyFile
        var err error

        if z.cfg.Zitadel.ClientJWT != "" </span><span class="cov8" title="1">{
                keyFile, err = client.ConfigFromKeyFileData([]byte(z.cfg.Zitadel.ClientJWT))
        }</span> else<span class="cov0" title="0"> if z.cfg.Zitadel.ClientJWTPath != "" </span><span class="cov0" title="0">{
                keyFile, err = client.ConfigFromKeyFile(z.cfg.Zitadel.ClientJWTPath)
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("no Zitadel client JWT configured")
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("parse key file: %w", err)
        }</span>

        <span class="cov0" title="0">issuer := z.cfg.Zitadel.GetIssuer()
        z.log.Info("initializing Zitadel resource server",
                slog.String("issuer", issuer),
                slog.String("client_id", keyFile.ClientID),
        )

        return rs.NewResourceServerJWTProfile(ctx, issuer, keyFile.ClientID, keyFile.KeyID, []byte(keyFile.Key))</span>
}

// introspectionResponse wraps the OIDC introspection response
type introspectionResponse struct {
        Active     bool   `json:"active"`
        Scope      string `json:"scope"`
        ClientID   string `json:"client_id"`
        TokenType  string `json:"token_type"`
        Expiration Time   `json:"exp"`
        IssuedAt   Time   `json:"iat"`
        NotBefore  Time   `json:"nbf"`
        Subject    string `json:"sub"`
        Audience   any    `json:"aud"`
        Issuer     string `json:"iss"`
        JWTID      string `json:"jti"`
        
        // Standard OIDC claims
        Email             string `json:"email"`
        EmailVerified     bool   `json:"email_verified"`
        Name              string `json:"name"`
        PreferredUsername string `json:"preferred_username"`
        GivenName         string `json:"given_name"`
        FamilyName        string `json:"family_name"`
        
        // All claims for extension
        Claims map[string]any `json:"-"`
}

// Implement required interface methods
func (r *introspectionResponse) IsActive() bool            <span class="cov8" title="1">{ return r.Active }</span>
func (r *introspectionResponse) SetActive(active bool)     <span class="cov8" title="1">{ r.Active = active }</span>
func (r *introspectionResponse) GetEmail() string          <span class="cov8" title="1">{ return r.Email }</span>
func (r *introspectionResponse) GetPreferredUsername() string <span class="cov8" title="1">{ return r.PreferredUsername }</span>
func (r *introspectionResponse) GetName() string           <span class="cov8" title="1">{ return r.Name }</span>

// Time wraps time.Time for JSON unmarshaling from Unix timestamp
type Time struct {
        time.Time
}

func (t *Time) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var timestamp int64
        if err := json.Unmarshal(data, &amp;timestamp); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">t.Time = time.Unix(timestamp, 0)
        return nil</span>
}

func (t Time) AsTime() time.Time <span class="cov8" title="1">{
        return t.Time
}</span>

// getCached retrieves a cached introspection result from PostgreSQL
func (z *ZitadelService) getCached(ctx context.Context, token string) (*IntrospectionResult, error) <span class="cov8" title="1">{
        tokenHash := z.hashToken(token)

        var result struct {
                Data      json.RawMessage `bun:"introspection_data"`
                ExpiresAt time.Time       `bun:"expires_at"`
        }

        err := z.db.NewSelect().
                TableExpr("kb.auth_introspection_cache").
                Column("introspection_data", "expires_at").
                Where("token_hash = ?", tokenHash).
                Where("expires_at &gt; NOW()").
                Scan(ctx, &amp;result)

        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var cached IntrospectionResult
        if err := json.Unmarshal(result.Data, &amp;cached); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cached, nil</span>
}

// cacheResult stores an introspection result in PostgreSQL
func (z *ZitadelService) cacheResult(ctx context.Context, token string, result *IntrospectionResult, ttl time.Duration) error <span class="cov0" title="0">{
        tokenHash := z.hashToken(token)
        expiresAt := time.Now().Add(ttl)

        data, err := json.Marshal(result)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = z.db.NewInsert().
                TableExpr("kb.auth_introspection_cache").
                Model(&amp;struct {
                        TokenHash         string          `bun:"token_hash"`
                        IntrospectionData json.RawMessage `bun:"introspection_data,type:jsonb"`
                        ExpiresAt         time.Time       `bun:"expires_at"`
                }{
                        TokenHash:         tokenHash,
                        IntrospectionData: data,
                        ExpiresAt:         expiresAt,
                }).
                On("CONFLICT (token_hash) DO UPDATE").
                Set("introspection_data = EXCLUDED.introspection_data").
                Set("expires_at = EXCLUDED.expires_at").
                Exec(ctx)

        return err</span>
}

// hashToken creates a SHA-512 hash of the token for cache lookup
func (z *ZitadelService) hashToken(token string) string <span class="cov8" title="1">{
        hash := sha512.Sum512([]byte(token))
        return hex.EncodeToString(hash[:])
}</span>

// tripCircuitBreaker marks a failure to prevent repeated calls
func (z *ZitadelService) tripCircuitBreaker() <span class="cov0" title="0">{
        z.failureMu.Lock()
        z.lastFailureTime = time.Now()
        z.failureMu.Unlock()
        z.log.Warn("circuit breaker tripped due to introspection failure")
}</span>

// ParseScopes extracts scopes from space-separated string
func ParseScopes(scope string) []string <span class="cov8" title="1">{
        if scope == "" </span><span class="cov8" title="1">{
                return []string{}
        }</span>
        <span class="cov8" title="1">return strings.Split(scope, " ")</span>
}
</pre>
		
		<pre class="file" id="file118" style="display: none">// Package embeddings provides embedding generation functionality.
package embeddings

import (
        "context"
)

// EmbeddingDimension is the default embedding dimension for text-embedding-004
const EmbeddingDimension = 768

// Client provides embedding generation functionality
type Client interface {
        // EmbedQuery generates an embedding vector for the given query text
        EmbedQuery(ctx context.Context, query string) ([]float32, error)

        // EmbedDocuments generates embedding vectors for the given documents
        EmbedDocuments(ctx context.Context, documents []string) ([][]float32, error)
}

// NoopClient is a no-op implementation that returns nil embeddings
// Used when embeddings are disabled
type NoopClient struct{}

// NewNoopClient creates a new NoopClient
func NewNoopClient() *NoopClient <span class="cov8" title="1">{
        return &amp;NoopClient{}
}</span>

// EmbedQuery returns nil, nil (no embedding available)
func (c *NoopClient) EmbedQuery(ctx context.Context, query string) ([]float32, error) <span class="cov8" title="1">{
        return nil, nil
}</span>

// EmbedDocuments returns nil, nil (no embeddings available)
func (c *NoopClient) EmbedDocuments(ctx context.Context, documents []string) ([][]float32, error) <span class="cov8" title="1">{
        return nil, nil
}</span>
</pre>
		
		<pre class="file" id="file119" style="display: none">// Package embeddings provides embedding generation functionality.
package embeddings

import (
        "context"
        "log/slog"

        "go.uber.org/fx"

        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/pkg/embeddings/vertex"
)

// NewNoopService creates a service with a noop client (for testing)
func NewNoopService(log *slog.Logger) *Service <span class="cov8" title="1">{
        return &amp;Service{
                client:  NewNoopClient(),
                log:     log,
                enabled: false,
        }
}</span>

// Module provides the embeddings fx.Module
var Module = fx.Module("embeddings",
        fx.Provide(NewService),
)

// Service provides embedding generation with automatic client selection
type Service struct {
        client  Client
        log     *slog.Logger
        enabled bool
}

// NewService creates a new embeddings service
func NewService(lc fx.Lifecycle, cfg *config.Config, log *slog.Logger) *Service <span class="cov0" title="0">{
        embCfg := cfg.Embeddings

        if !embCfg.IsEnabled() </span><span class="cov0" title="0">{
                log.Info("embeddings service disabled - no configuration provided")
                return &amp;Service{
                        client:  NewNoopClient(),
                        log:     log,
                        enabled: false,
                }
        }</span>

        <span class="cov0" title="0">svc := &amp;Service{
                client:  NewNoopClient(), // Will be replaced on start
                log:     log,
                enabled: false,
        }

        // Initialize client on startup
        lc.Append(fx.Hook{
                OnStart: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        if embCfg.UseVertexAI() </span><span class="cov0" title="0">{
                                log.Info("initializing Vertex AI embeddings client",
                                        slog.String("project", embCfg.GCPProjectID),
                                        slog.String("location", embCfg.VertexAILocation),
                                        slog.String("model", embCfg.Model),
                                )

                                client, err := vertex.NewClient(ctx, vertex.Config{
                                        ProjectID: embCfg.GCPProjectID,
                                        Location:  embCfg.VertexAILocation,
                                        Model:     embCfg.Model,
                                }, vertex.WithLogger(log))
                                if err != nil </span><span class="cov0" title="0">{
                                        log.Error("failed to initialize Vertex AI client", slog.String("error", err.Error()))
                                        // Keep noop client
                                        return nil // Don't fail startup
                                }</span>
                                <span class="cov0" title="0">svc.client = client
                                svc.enabled = true
                                log.Info("Vertex AI embeddings client initialized")</span>
                        } else<span class="cov0" title="0"> if embCfg.GoogleAPIKey != "" </span><span class="cov0" title="0">{
                                // TODO: Add Generative AI client for development
                                log.Warn("Generative AI embeddings not implemented, using noop client")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                },
        })

        <span class="cov0" title="0">return svc</span>
}

// IsEnabled returns true if embeddings are available
func (s *Service) IsEnabled() bool <span class="cov8" title="1">{
        return s.enabled
}</span>

// EmbedQuery generates an embedding for a single query
func (s *Service) EmbedQuery(ctx context.Context, query string) ([]float32, error) <span class="cov8" title="1">{
        return s.client.EmbedQuery(ctx, query)
}</span>

// EmbedDocuments generates embeddings for multiple documents
func (s *Service) EmbedDocuments(ctx context.Context, documents []string) ([][]float32, error) <span class="cov8" title="1">{
        return s.client.EmbedDocuments(ctx, documents)
}</span>

// EmbedQueryWithUsage generates an embedding with usage data (if supported by client)
func (s *Service) EmbedQueryWithUsage(ctx context.Context, query string) (*vertex.EmbedResult, error) <span class="cov0" title="0">{
        if c, ok := s.client.(*vertex.Client); ok </span><span class="cov0" title="0">{
                return c.EmbedQueryWithUsage(ctx, query)
        }</span>
        // Fallback for clients without usage support
        <span class="cov0" title="0">embedding, err := s.client.EmbedQuery(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;vertex.EmbedResult{Embedding: embedding}, nil</span>
}

// EmbedDocumentsWithUsage generates embeddings with usage data (if supported by client)
func (s *Service) EmbedDocumentsWithUsage(ctx context.Context, documents []string) (*vertex.BatchEmbedResult, error) <span class="cov0" title="0">{
        if c, ok := s.client.(*vertex.Client); ok </span><span class="cov0" title="0">{
                return c.EmbedDocumentsWithUsage(ctx, documents)
        }</span>
        // Fallback for clients without usage support
        <span class="cov0" title="0">embeddings, err := s.client.EmbedDocuments(ctx, documents)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;vertex.BatchEmbedResult{Embeddings: embeddings}, nil</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">// Package vertex provides a Google Vertex AI embeddings client.
package vertex

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "math"
        "net/http"
        "time"

        "golang.org/x/oauth2/google"
)

const (
        // DefaultModel is the default embedding model
        DefaultModel = "text-embedding-004"

        // DefaultDimension is the embedding dimension for text-embedding-004
        DefaultDimension = 768

        // DefaultMaxRetries is the default number of retries
        DefaultMaxRetries = 3

        // DefaultBaseDelay is the base delay for exponential backoff
        DefaultBaseDelay = 100 * time.Millisecond

        // DefaultMaxDelay is the maximum delay for exponential backoff
        DefaultMaxDelay = 10 * time.Second

        // DefaultTimeout is the default HTTP timeout
        DefaultTimeout = 30 * time.Second

        // DefaultBatchSize is the maximum batch size per request
        DefaultBatchSize = 100
)

// Config holds the configuration for the Vertex AI client
type Config struct {
        ProjectID string
        Location  string
        Model     string
        Timeout   time.Duration
}

// Client is a Vertex AI embeddings client
type Client struct {
        projectID  string
        location   string
        model      string
        httpClient *http.Client
        tokenSrc   *google.Credentials
        log        *slog.Logger

        // Retry configuration
        maxRetries int
        baseDelay  time.Duration
        maxDelay   time.Duration
}

// ClientOption configures the Client
type ClientOption func(*Client)

// WithMaxRetries sets the maximum number of retries
func WithMaxRetries(n int) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.maxRetries = n
        }</span>
}

// WithBaseDelay sets the base delay for exponential backoff
func WithBaseDelay(d time.Duration) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.baseDelay = d
        }</span>
}

// WithMaxDelay sets the maximum delay for exponential backoff
func WithMaxDelay(d time.Duration) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.maxDelay = d
        }</span>
}

// WithLogger sets the logger
func WithLogger(log *slog.Logger) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.log = log
        }</span>
}

// NewClient creates a new Vertex AI embeddings client
func NewClient(ctx context.Context, cfg Config, opts ...ClientOption) (*Client, error) <span class="cov0" title="0">{
        if cfg.ProjectID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project ID is required")
        }</span>
        <span class="cov0" title="0">if cfg.Location == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("location is required")
        }</span>
        <span class="cov0" title="0">if cfg.Model == "" </span><span class="cov0" title="0">{
                cfg.Model = DefaultModel
        }</span>
        <span class="cov0" title="0">if cfg.Timeout == 0 </span><span class="cov0" title="0">{
                cfg.Timeout = DefaultTimeout
        }</span>

        // Get default credentials
        <span class="cov0" title="0">creds, err := google.FindDefaultCredentials(ctx, "https://www.googleapis.com/auth/cloud-platform")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find default credentials: %w", err)
        }</span>

        <span class="cov0" title="0">c := &amp;Client{
                projectID: cfg.ProjectID,
                location:  cfg.Location,
                model:     cfg.Model,
                httpClient: &amp;http.Client{
                        Timeout: cfg.Timeout,
                },
                tokenSrc:   creds,
                log:        slog.Default(),
                maxRetries: DefaultMaxRetries,
                baseDelay:  DefaultBaseDelay,
                maxDelay:   DefaultMaxDelay,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(c)
        }</span>

        <span class="cov0" title="0">return c, nil</span>
}

// predictRequest is the request body for the predict API
type predictRequest struct {
        Instances []instance `json:"instances"`
}

type instance struct {
        Content  string `json:"content"`
        TaskType string `json:"task_type"`
}

// predictResponse is the response from the predict API
type predictResponse struct {
        Predictions []prediction `json:"predictions"`
}

type prediction struct {
        Embeddings embeddingResult `json:"embeddings"`
}

type embeddingResult struct {
        Values     []float32      `json:"values"`
        Statistics embeddingStats `json:"statistics"`
}

type embeddingStats struct {
        TokenCount int `json:"token_count"`
}

// EmbedResult contains the embedding result with usage data
type EmbedResult struct {
        Embedding []float32
        Usage     *Usage
}

// BatchEmbedResult contains batch embedding results with usage data
type BatchEmbedResult struct {
        Embeddings [][]float32
        Usage      *Usage
}

// Usage contains token usage information
type Usage struct {
        PromptTokens int
        TotalTokens  int
}

// EmbedQuery generates an embedding for a single query
func (c *Client) EmbedQuery(ctx context.Context, query string) ([]float32, error) <span class="cov0" title="0">{
        result, err := c.EmbedQueryWithUsage(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result.Embedding, nil</span>
}

// EmbedQueryWithUsage generates an embedding for a single query with usage data
func (c *Client) EmbedQueryWithUsage(ctx context.Context, query string) (*EmbedResult, error) <span class="cov0" title="0">{
        result, err := c.EmbedDocumentsWithUsage(ctx, []string{query})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(result.Embeddings) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no embedding returned")
        }</span>
        <span class="cov0" title="0">return &amp;EmbedResult{
                Embedding: result.Embeddings[0],
                Usage:     result.Usage,
        }, nil</span>
}

// EmbedDocuments generates embeddings for multiple documents
func (c *Client) EmbedDocuments(ctx context.Context, documents []string) ([][]float32, error) <span class="cov0" title="0">{
        result, err := c.EmbedDocumentsWithUsage(ctx, documents)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return result.Embeddings, nil</span>
}

// EmbedDocumentsWithUsage generates embeddings for multiple documents with usage data
func (c *Client) EmbedDocumentsWithUsage(ctx context.Context, documents []string) (*BatchEmbedResult, error) <span class="cov0" title="0">{
        if len(documents) == 0 </span><span class="cov0" title="0">{
                return &amp;BatchEmbedResult{
                        Embeddings: [][]float32{},
                        Usage:      &amp;Usage{},
                }, nil
        }</span>

        // Process in batches
        <span class="cov0" title="0">var allEmbeddings [][]float32
        var totalTokens int

        for i := 0; i &lt; len(documents); i += DefaultBatchSize </span><span class="cov0" title="0">{
                end := i + DefaultBatchSize
                if end &gt; len(documents) </span><span class="cov0" title="0">{
                        end = len(documents)
                }</span>
                <span class="cov0" title="0">batch := documents[i:end]

                embs, tokens, err := c.embedBatch(ctx, batch)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to embed batch %d-%d: %w", i, end, err)
                }</span>

                <span class="cov0" title="0">allEmbeddings = append(allEmbeddings, embs...)
                totalTokens += tokens</span>
        }

        <span class="cov0" title="0">return &amp;BatchEmbedResult{
                Embeddings: allEmbeddings,
                Usage: &amp;Usage{
                        PromptTokens: totalTokens,
                        TotalTokens:  totalTokens,
                },
        }, nil</span>
}

// embedBatch embeds a single batch of documents
func (c *Client) embedBatch(ctx context.Context, documents []string) ([][]float32, int, error) <span class="cov0" title="0">{
        url := fmt.Sprintf(
                "https://%s-aiplatform.googleapis.com/v1/projects/%s/locations/%s/publishers/google/models/%s:predict",
                c.location, c.projectID, c.location, c.model,
        )

        // Build request
        instances := make([]instance, len(documents))
        for i, doc := range documents </span><span class="cov0" title="0">{
                instances[i] = instance{
                        Content:  doc,
                        TaskType: "RETRIEVAL_DOCUMENT",
                }
        }</span>

        <span class="cov0" title="0">reqBody := predictRequest{Instances: instances}
        reqBytes, err := json.Marshal(reqBody)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // Execute with retries
        <span class="cov0" title="0">var resp *predictResponse
        var lastErr error

        for attempt := 0; attempt &lt;= c.maxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        delay := c.calculateBackoff(attempt)
                        c.log.Debug("retrying embedding request",
                                slog.Int("attempt", attempt),
                                slog.Duration("delay", delay),
                        )
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return nil, 0, ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                        }
                }

                <span class="cov0" title="0">resp, lastErr = c.doRequest(ctx, url, reqBytes)
                if lastErr == nil </span><span class="cov0" title="0">{
                        break</span>
                }

                // Don't retry on context cancellation
                <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return nil, 0, ctx.Err()
                }</span>

                <span class="cov0" title="0">c.log.Warn("embedding request failed",
                        slog.Int("attempt", attempt),
                        slog.String("error", lastErr.Error()),
                )</span>
        }

        <span class="cov0" title="0">if lastErr != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("all retries exhausted: %w", lastErr)
        }</span>

        // Extract embeddings and token counts
        <span class="cov0" title="0">embeddings := make([][]float32, len(resp.Predictions))
        totalTokens := 0

        for i, pred := range resp.Predictions </span><span class="cov0" title="0">{
                embeddings[i] = pred.Embeddings.Values
                totalTokens += pred.Embeddings.Statistics.TokenCount
        }</span>

        <span class="cov0" title="0">return embeddings, totalTokens, nil</span>
}

// doRequest executes a single HTTP request
func (c *Client) doRequest(ctx context.Context, url string, body []byte) (*predictResponse, error) <span class="cov0" title="0">{
        // Get access token
        token, err := c.tokenSrc.TokenSource.Token()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get access token: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+token.AccessToken)
        req.Header.Set("Content-Type", "application/json")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>

        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                // Check if retryable
                if resp.StatusCode == http.StatusTooManyRequests ||
                        resp.StatusCode == http.StatusServiceUnavailable ||
                        resp.StatusCode &gt;= 500 </span><span class="cov0" title="0">{
                        return nil, &amp;retryableError{
                                statusCode: resp.StatusCode,
                                body:       string(respBody),
                        }
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("API error %d: %s", resp.StatusCode, string(respBody))</span>
        }

        <span class="cov0" title="0">var result predictResponse
        if err := json.Unmarshal(respBody, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal response: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;result, nil</span>
}

// calculateBackoff calculates the backoff delay for a given attempt
func (c *Client) calculateBackoff(attempt int) time.Duration <span class="cov8" title="1">{
        delay := float64(c.baseDelay) * math.Pow(2, float64(attempt-1))
        if delay &gt; float64(c.maxDelay) </span><span class="cov8" title="1">{
                delay = float64(c.maxDelay)
        }</span>
        <span class="cov8" title="1">return time.Duration(delay)</span>
}

// retryableError is an error that can be retried
type retryableError struct {
        statusCode int
        body       string
}

func (e *retryableError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("retryable API error %d: %s", e.statusCode, e.body)
}</span>
</pre>
		
		<pre class="file" id="file121" style="display: none">// Package encryption provides encryption and decryption for sensitive data
// using PostgreSQL pgcrypto extension.
//
// This matches the NestJS EncryptionService implementation which uses
// pgp_sym_encrypt/pgp_sym_decrypt functions.
package encryption

import (
        "context"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "os"

        "github.com/uptrace/bun"

        "github.com/emergent/emergent-core/pkg/logger"
)

// Common errors
var (
        ErrKeyNotConfigured = errors.New("encryption key not configured")
        ErrDecryptionFailed = errors.New("failed to decrypt data")
)

// Service provides encryption and decryption using PostgreSQL pgcrypto.
// It uses pgp_sym_encrypt/pgp_sym_decrypt for AES-256 encryption.
type Service struct {
        db  *bun.DB
        log *slog.Logger
        key string
}

// NewService creates a new encryption service.
// It reads the encryption key from INTEGRATION_ENCRYPTION_KEY environment variable.
func NewService(db *bun.DB, log *slog.Logger) *Service <span class="cov0" title="0">{
        key := os.Getenv("INTEGRATION_ENCRYPTION_KEY")
        svc := &amp;Service{
                db:  db,
                log: log.With(logger.Scope("encryption")),
                key: key,
        }

        // Validate encryption key
        env := os.Getenv("GO_ENV")
        if key == "" </span><span class="cov0" title="0">{
                if env == "production" </span><span class="cov0" title="0">{
                        svc.log.Error("INTEGRATION_ENCRYPTION_KEY is required in production")
                }</span> else<span class="cov0" title="0"> if env != "test" </span><span class="cov0" title="0">{
                        svc.log.Warn("INTEGRATION_ENCRYPTION_KEY not set - credentials will NOT be encrypted")
                }</span>
        } else<span class="cov0" title="0"> if len(key) &lt; 32 </span><span class="cov0" title="0">{
                if env == "production" </span><span class="cov0" title="0">{
                        svc.log.Error("INTEGRATION_ENCRYPTION_KEY is too short for AES-256",
                                slog.Int("length", len(key)))
                }</span> else<span class="cov0" title="0"> {
                        svc.log.Warn("INTEGRATION_ENCRYPTION_KEY is short for AES-256",
                                slog.Int("length", len(key)))
                }</span>
        }

        <span class="cov0" title="0">return svc</span>
}

// IsConfigured returns true if encryption is properly configured
func (s *Service) IsConfigured() bool <span class="cov8" title="1">{
        return s.key != "" &amp;&amp; len(s.key) &gt;= 32
}</span>

// Encrypt encrypts a map of settings using PostgreSQL pgcrypto.
// Returns base64-encoded encrypted data.
func (s *Service) Encrypt(ctx context.Context, settings map[string]interface{}) (string, error) <span class="cov0" title="0">{
        if s.key == "" </span><span class="cov0" title="0">{
                s.log.Warn("Encryption key not set - storing as plain JSON (INSECURE)")
                data, err := json.Marshal(settings)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to marshal settings: %w", err)
                }</span>
                <span class="cov0" title="0">return string(data), nil</span>
        }

        <span class="cov0" title="0">settingsJSON, err := json.Marshal(settings)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal settings: %w", err)
        }</span>

        <span class="cov0" title="0">var encrypted string
        err = s.db.NewRaw(`
                SELECT encode(
                        pgp_sym_encrypt(?::text, ?::text),
                        'base64'
                ) as encrypted
        `, string(settingsJSON), s.key).Scan(ctx, &amp;encrypted)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to encrypt: %w", err)
        }</span>

        <span class="cov0" title="0">return encrypted, nil</span>
}

// Decrypt decrypts encrypted settings using PostgreSQL pgcrypto.
// Supports base64-encoded encrypted data from pgp_sym_encrypt.
func (s *Service) Decrypt(ctx context.Context, encryptedData string) (map[string]interface{}, error) <span class="cov0" title="0">{
        if encryptedData == "" </span><span class="cov0" title="0">{
                return make(map[string]interface{}), nil
        }</span>

        <span class="cov0" title="0">if s.key == "" </span><span class="cov0" title="0">{
                // No encryption key - data is stored as plain JSON
                s.log.Debug("Decrypting without key - assuming plain JSON")
                var settings map[string]interface{}
                if err := json.Unmarshal([]byte(encryptedData), &amp;settings); err != nil </span><span class="cov0" title="0">{
                        s.log.Warn("Failed to parse unencrypted settings as JSON",
                                slog.String("error", err.Error()))
                        return make(map[string]interface{}), nil
                }</span>
                <span class="cov0" title="0">return settings, nil</span>
        }

        // Try pgp_sym_decrypt first (new method)
        <span class="cov0" title="0">var decrypted string
        err := s.db.NewRaw(`
                SELECT pgp_sym_decrypt(decode(?, 'base64'), ?::text) as decrypted
        `, encryptedData, s.key).Scan(ctx, &amp;decrypted)

        if err != nil </span><span class="cov0" title="0">{
                // Try legacy decrypt method for backwards compatibility
                s.log.Warn("pgp_sym_decrypt failed, trying legacy method",
                        slog.String("error", err.Error()))

                err = s.db.NewRaw(`
                        SELECT convert_from(
                                decrypt(decode(?, 'base64'), digest(?, 'sha256'), 'aes-cbc'),
                                'utf-8'
                        ) as decrypted
                `, encryptedData, s.key).Scan(ctx, &amp;decrypted)

                if err != nil </span><span class="cov0" title="0">{
                        s.log.Error("Failed to decrypt with both methods",
                                slog.String("error", err.Error()))
                        return nil, ErrDecryptionFailed
                }</span>
                <span class="cov0" title="0">s.log.Debug("Successfully decrypted using legacy method")</span>
        }

        <span class="cov0" title="0">var settings map[string]interface{}
        if err := json.Unmarshal([]byte(decrypted), &amp;settings); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal decrypted settings: %w", err)
        }</span>

        <span class="cov0" title="0">return settings, nil</span>
}

// DecryptBytes decrypts encrypted settings stored as bytes/bytea.
// This handles the case where PostgreSQL returns BYTEA directly.
func (s *Service) DecryptBytes(ctx context.Context, data []byte) (map[string]interface{}, error) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return make(map[string]interface{}), nil
        }</span>

        // Convert to string and use standard decrypt
        <span class="cov0" title="0">return s.Decrypt(ctx, string(data))</span>
}

// EncryptJSON encrypts any JSON-serializable value
func (s *Service) EncryptJSON(ctx context.Context, value interface{}) (string, error) <span class="cov0" title="0">{
        settings := make(map[string]interface{})
        
        // If value is already a map, use it directly
        if m, ok := value.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                settings = m
        }</span> else<span class="cov0" title="0"> {
                // Otherwise, wrap it
                settings["value"] = value
        }</span>
        
        <span class="cov0" title="0">return s.Encrypt(ctx, settings)</span>
}

// Module provides the fx module for the encryption service
func Module() interface{} <span class="cov8" title="1">{
        return NewService
}</span>

// Ensure Service implements a decrypter interface
type Decrypter interface {
        Decrypt(ctx context.Context, encryptedData string) (map[string]interface{}, error)
        IsConfigured() bool
}

var _ Decrypter = (*Service)(nil)

// NullService is a no-op encryption service for testing
type NullService struct{}

// NewNullService creates a null encryption service
func NewNullService() *NullService <span class="cov8" title="1">{
        return &amp;NullService{}
}</span>

// Encrypt returns the settings as JSON (no encryption)
func (n *NullService) Encrypt(ctx context.Context, settings map[string]interface{}) (string, error) <span class="cov8" title="1">{
        data, err := json.Marshal(settings)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(data), nil</span>
}

// Decrypt parses JSON settings (no decryption)
func (n *NullService) Decrypt(ctx context.Context, data string) (map[string]interface{}, error) <span class="cov8" title="1">{
        if data == "" </span><span class="cov8" title="1">{
                return make(map[string]interface{}), nil
        }</span>
        <span class="cov8" title="1">var settings map[string]interface{}
        if err := json.Unmarshal([]byte(data), &amp;settings); err != nil </span><span class="cov8" title="1">{
                return make(map[string]interface{}), nil
        }</span>
        <span class="cov8" title="1">return settings, nil</span>
}

// IsConfigured always returns false for NullService
func (n *NullService) IsConfigured() bool <span class="cov8" title="1">{
        return false
}</span>

// Ensure NullService implements Decrypter
var _ Decrypter = (*NullService)(nil)

// TransactionDecrypt decrypts within an existing transaction
func (s *Service) TransactionDecrypt(ctx context.Context, tx bun.Tx, encryptedData string) (map[string]interface{}, error) <span class="cov0" title="0">{
        if encryptedData == "" </span><span class="cov0" title="0">{
                return make(map[string]interface{}), nil
        }</span>

        <span class="cov0" title="0">if s.key == "" </span><span class="cov0" title="0">{
                var settings map[string]interface{}
                if err := json.Unmarshal([]byte(encryptedData), &amp;settings); err != nil </span><span class="cov0" title="0">{
                        return make(map[string]interface{}), nil
                }</span>
                <span class="cov0" title="0">return settings, nil</span>
        }

        <span class="cov0" title="0">var decrypted string
        err := tx.NewRaw(`
                SELECT pgp_sym_decrypt(decode(?, 'base64'), ?::text) as decrypted
        `, encryptedData, s.key).Scan(ctx, &amp;decrypted)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return make(map[string]interface{}), nil
                }</span>
                <span class="cov0" title="0">return nil, ErrDecryptionFailed</span>
        }

        <span class="cov0" title="0">var settings map[string]interface{}
        if err := json.Unmarshal([]byte(decrypted), &amp;settings); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal decrypted settings: %w", err)
        }</span>

        <span class="cov0" title="0">return settings, nil</span>
}
</pre>
		
		<pre class="file" id="file122" style="display: none">// Package kreuzberg provides an HTTP client for the Kreuzberg document extraction service.
//
// Kreuzberg is a document parsing service that extracts text, tables, and images
// from various document formats (PDF, DOCX, images with OCR, etc.).
// See: https://github.com/Goldziher/kreuzberg
package kreuzberg

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "mime/multipart"
        "net/http"
        "path/filepath"
        "strings"
        "time"

        "github.com/emergent/emergent-core/internal/config"
        "github.com/emergent/emergent-core/pkg/logger"
        "go.uber.org/fx"
)

// Module provides the Kreuzberg client as an fx module
var Module = fx.Module("kreuzberg",
        fx.Provide(NewClient),
)

// Client is an HTTP client for the Kreuzberg document extraction service
type Client struct {
        httpClient *http.Client
        baseURL    string
        timeout    time.Duration
        enabled    bool
        log        *slog.Logger
}

// NewClient creates a new Kreuzberg client
func NewClient(cfg *config.Config, log *slog.Logger) *Client <span class="cov0" title="0">{
        return &amp;Client{
                httpClient: &amp;http.Client{
                        Timeout: cfg.Kreuzberg.Timeout(),
                },
                baseURL: cfg.Kreuzberg.ServiceURL,
                timeout: cfg.Kreuzberg.Timeout(),
                enabled: cfg.Kreuzberg.Enabled,
                log:     log.With(logger.Scope("kreuzberg")),
        }
}</span>

// IsEnabled returns true if Kreuzberg service is enabled
func (c *Client) IsEnabled() bool <span class="cov0" title="0">{
        return c.enabled
}</span>

// ExtractResult is the response from Kreuzberg document extraction
type ExtractResult struct {
        // Content is the extracted text content from the document
        Content string `json:"content"`

        // Metadata contains document metadata extracted during parsing
        Metadata *ExtractMetadata `json:"metadata,omitempty"`

        // Tables extracted from the document
        Tables []ExtractedTable `json:"tables,omitempty"`

        // Images extracted from the document
        Images []ExtractedImage `json:"images,omitempty"`
}

// ExtractMetadata contains document metadata
type ExtractMetadata struct {
        PageCount        *int   `json:"page_count,omitempty"`
        Title            string `json:"title,omitempty"`
        Author           string `json:"author,omitempty"`
        CreationDate     string `json:"creation_date,omitempty"`
        ModificationDate string `json:"modification_date,omitempty"`
        Producer         string `json:"producer,omitempty"`
}

// ExtractedTable represents a table extracted from a document
type ExtractedTable struct {
        Page int        `json:"page,omitempty"`
        Data [][]string `json:"data"`
}

// ExtractedImage represents an image extracted from a document
type ExtractedImage struct {
        Page     int    `json:"page,omitempty"`
        Data     string `json:"data"`      // Base64-encoded image data
        MimeType string `json:"mime_type"` // e.g., 'image/png', 'image/jpeg'
}

// ExtractOptions contains options for extraction requests
type ExtractOptions struct {
        // TimeoutMs overrides the default timeout for this request
        TimeoutMs int
        // ExtractTables enables table extraction
        ExtractTables bool
        // ExtractImages enables image extraction
        ExtractImages bool
        // OCRLanguage is the language hint for OCR (e.g., "eng", "deu")
        OCRLanguage string
}

// HealthResponse is the health check response from Kreuzberg
type HealthResponse struct {
        Status  string                 `json:"status"` // "healthy" or "unhealthy"
        Version string                 `json:"version,omitempty"`
        Details map[string]interface{} `json:"details,omitempty"`
}

// Error represents a Kreuzberg service error
type Error struct {
        // Message is the human-friendly error message
        Message string
        // Detail is the technical error detail
        Detail string
        // StatusCode is the HTTP status code
        StatusCode int
}

func (e *Error) Error() string <span class="cov8" title="1">{
        if e.Detail != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: %s", e.Message, e.Detail)
        }</span>
        <span class="cov8" title="1">return e.Message</span>
}

// humanFriendlyMessages maps technical errors to user-friendly messages
var humanFriendlyMessages = map[string]string{
        "No txBody found":         "This PowerPoint file contains shapes without text content that cannot be parsed.",
        "Unsupported file format": "This file format is not supported for text extraction.",
        "Invalid PDF":             "This PDF file appears to be corrupted or invalid.",
        "Invalid file":            "This file appears to be corrupted or in an unrecognized format.",
        "Empty content":           "No text content could be extracted from this file.",
        "File too large":          "This file exceeds the maximum size limit for processing.",
        "Processing timeout":      "The file took too long to process.",
        "LibreOffice":             "This file format requires LibreOffice for conversion, which is not available.",
        "libreoffice":             "This file format requires LibreOffice for conversion, which is not available.",
        "soffice not found":       "LibreOffice is not installed. Legacy Office formats require LibreOffice.",
}

// getHumanFriendlyMessage converts technical errors to user-friendly messages
func getHumanFriendlyMessage(technical string, detail string) string <span class="cov8" title="1">{
        for pattern, friendly := range humanFriendlyMessages </span><span class="cov8" title="1">{
                if strings.Contains(technical, pattern) || strings.Contains(detail, pattern) </span><span class="cov8" title="1">{
                        return friendly
                }</span>
        }
        <span class="cov8" title="1">if detail != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s (%s)", technical, detail)
        }</span>
        <span class="cov8" title="1">return technical</span>
}

// ExtractText extracts text and content from a document
func (c *Client) ExtractText(ctx context.Context, content []byte, filename, mimeType string, opts *ExtractOptions) (*ExtractResult, error) <span class="cov0" title="0">{
        if !c.enabled </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Message:    "Kreuzberg document parsing is not enabled",
                        StatusCode: http.StatusServiceUnavailable,
                }
        }</span>

        <span class="cov0" title="0">startTime := time.Now()
        c.log.Debug("extracting text from document",
                slog.String("filename", filename),
                slog.String("mime_type", mimeType),
                slog.Int("size_bytes", len(content)),
        )

        // Determine timeout
        timeout := c.timeout
        if opts != nil &amp;&amp; opts.TimeoutMs &gt; 0 </span><span class="cov0" title="0">{
                timeout = time.Duration(opts.TimeoutMs) * time.Millisecond
        }</span>

        // Create context with timeout
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, timeout)
        defer cancel()

        // Create multipart form data
        var buf bytes.Buffer
        writer := multipart.NewWriter(&amp;buf)

        // NOTE: Kreuzberg expects the field name to be 'files' (plural), not 'file'
        part, err := writer.CreateFormFile("files", filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create form file: %w", err)
        }</span>
        <span class="cov0" title="0">if _, err := part.Write(content); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("write file content: %w", err)
        }</span>

        <span class="cov0" title="0">if err := writer.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("close multipart writer: %w", err)
        }</span>

        // Create request
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, http.MethodPost, c.baseURL+"/extract", &amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create request: %w", err)
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", writer.FormDataContentType())
        req.Header.Set("Accept", "application/json")

        // Send request
        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        return nil, &amp;Error{
                                Message:    fmt.Sprintf("Kreuzberg request timed out for %s", filename),
                                StatusCode: http.StatusRequestTimeout,
                        }
                }</span>
                <span class="cov0" title="0">return nil, &amp;Error{
                        Message:    fmt.Sprintf("Kreuzberg service unavailable at %s", c.baseURL),
                        Detail:     err.Error(),
                        StatusCode: http.StatusServiceUnavailable,
                }</span>
        }
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response body
        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("read response body: %w", err)
        }</span>

        // Handle error responses
        <span class="cov0" title="0">if resp.StatusCode &gt;= 400 </span><span class="cov0" title="0">{
                return nil, c.handleErrorResponse(resp.StatusCode, body, filename)
        }</span>

        // Kreuzberg returns an array of results (one per file uploaded)
        <span class="cov0" title="0">var results []ExtractResult
        if err := json.Unmarshal(body, &amp;results); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(results) == 0 </span><span class="cov0" title="0">{
                return nil, &amp;Error{
                        Message:    "Kreuzberg returned empty results",
                        Detail:     "No extraction results returned from service",
                        StatusCode: http.StatusInternalServerError,
                }
        }</span>

        <span class="cov0" title="0">result := &amp;results[0]
        duration := time.Since(startTime)

        c.log.Info("extraction completed",
                slog.String("filename", filename),
                slog.Int("content_length", len(result.Content)),
                slog.Duration("duration", duration),
        )

        return result, nil</span>
}

// handleErrorResponse converts HTTP error responses to Error
func (c *Client) handleErrorResponse(statusCode int, body []byte, filename string) *Error <span class="cov0" title="0">{
        // Try to parse error response
        var errResp struct {
                Error   string                 `json:"error"`
                Detail  string                 `json:"detail"`
                Message string                 `json:"message"`
                Type    string                 `json:"type"`
                Context map[string]interface{} `json:"context"`
        }

        var message, detail string

        if err := json.Unmarshal(body, &amp;errResp); err == nil </span><span class="cov0" title="0">{
                message = errResp.Error
                if message == "" </span><span class="cov0" title="0">{
                        message = errResp.Message
                }</span>
                <span class="cov0" title="0">detail = errResp.Detail
                if errResp.Type != "" &amp;&amp; detail == "" </span><span class="cov0" title="0">{
                        detail = fmt.Sprintf("Error type: %s", errResp.Type)
                }</span>
        } else<span class="cov0" title="0"> {
                // Plain text error
                message = string(body)
        }</span>

        <span class="cov0" title="0">if message == "" </span><span class="cov0" title="0">{
                message = fmt.Sprintf("Kreuzberg error for %s", filename)
        }</span>

        <span class="cov0" title="0">c.log.Warn("kreuzberg error",
                slog.String("filename", filename),
                slog.Int("status_code", statusCode),
                slog.String("message", message),
                slog.String("detail", detail),
        )

        return &amp;Error{
                Message:    getHumanFriendlyMessage(message, detail),
                Detail:     detail,
                StatusCode: statusCode,
        }</span>
}

// HealthCheck checks the health status of the Kreuzberg service
func (c *Client) HealthCheck(ctx context.Context) (*HealthResponse, error) <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
        defer cancel()

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, c.baseURL+"/health", nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("create health request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                c.log.Warn("kreuzberg health check failed", slog.Any("error", err))
                return &amp;HealthResponse{
                        Status: "unhealthy",
                        Details: map[string]interface{}{
                                "error": err.Error(),
                        },
                }, nil
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        var health HealthResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;health); err != nil </span><span class="cov0" title="0">{
                return &amp;HealthResponse{
                        Status: "unhealthy",
                        Details: map[string]interface{}{
                                "error": "failed to decode health response",
                        },
                }, nil
        }</span>

        <span class="cov0" title="0">return &amp;health, nil</span>
}

// MIME types supported by Kreuzberg for extraction
var KreuzbergSupportedMIMETypes = map[string]bool{
        // Documents
        "application/pdf":  true,
        "application/msword": true,
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": true,
        "application/vnd.oasis.opendocument.text":                                 true,

        // Spreadsheets
        "application/vnd.ms-excel": true,
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": true,
        "application/vnd.ms-excel.sheet.macroEnabled.12":                    true,
        "application/vnd.ms-excel.sheet.binary.macroEnabled.12":             true,
        "application/vnd.oasis.opendocument.spreadsheet":                    true,

        // Presentations
        "application/vnd.ms-powerpoint": true,
        "application/vnd.openxmlformats-officedocument.presentationml.presentation": true,

        // Images (for OCR)
        "image/png":                true,
        "image/jpeg":               true,
        "image/gif":                true,
        "image/bmp":                true,
        "image/tiff":               true,
        "image/webp":               true,
        "image/jp2":                true,
        "image/jpx":                true,
        "image/x-portable-anymap":  true,
        "image/x-portable-bitmap":  true,
        "image/x-portable-graymap": true,
        "image/x-portable-pixmap":  true,

        // Email
        "message/rfc822":              true,
        "application/vnd.ms-outlook": true,

        // Web &amp; Markup
        "text/html":      true,
        "image/svg+xml": true,

        // Rich Text
        "application/rtf": true,

        // Archives
        "application/zip":              true,
        "application/x-tar":            true,
        "application/gzip":             true,
        "application/x-gzip":           true,
        "application/x-7z-compressed": true,
}

// MIME types for plain text that bypass Kreuzberg
var PlainTextMIMETypes = map[string]bool{
        "text/plain":               true,
        "text/markdown":            true,
        "text/csv":                 true,
        "text/tab-separated-values": true,
        "text/xml":                 true,
        "application/json":         true,
        "application/xml":          true,
        "application/x-yaml":       true,
        "text/yaml":                true,
        "application/toml":         true,
}

// Plain text file extensions that bypass Kreuzberg
var PlainTextExtensions = map[string]bool{
        ".txt":      true,
        ".md":       true,
        ".markdown": true,
        ".csv":      true,
        ".tsv":      true,
        ".json":     true,
        ".xml":      true,
        ".yaml":     true,
        ".yml":      true,
        ".toml":     true,
}

// Email MIME types that should use native parser
var EmailMIMETypes = map[string]bool{
        "message/rfc822":              true,
        "application/vnd.ms-outlook": true,
}

// Email file extensions
var EmailExtensions = map[string]bool{
        ".eml": true,
        ".msg": true,
}

// ShouldUseKreuzberg determines if a file should be processed by Kreuzberg
func ShouldUseKreuzberg(mimeType, filename string) bool <span class="cov8" title="1">{
        // Check MIME type first
        if mimeType != "" &amp;&amp; PlainTextMIMETypes[mimeType] </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check file extension as fallback
        <span class="cov8" title="1">if filename != "" </span><span class="cov8" title="1">{
                ext := strings.ToLower(filepath.Ext(filename))
                if PlainTextExtensions[ext] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Default to using Kreuzberg for unknown types
        <span class="cov8" title="1">return true</span>
}

// IsEmailFile checks if a file is an email file that should use native parser
func IsEmailFile(mimeType, filename string) bool <span class="cov8" title="1">{
        // Check MIME type first
        if mimeType != "" &amp;&amp; EmailMIMETypes[mimeType] </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check file extension as fallback
        <span class="cov8" title="1">if filename != "" </span><span class="cov8" title="1">{
                ext := strings.ToLower(filepath.Ext(filename))
                if EmailExtensions[ext] </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// IsKreuzbergSupported checks if a MIME type is supported by Kreuzberg
func IsKreuzbergSupported(mimeType string) bool <span class="cov8" title="1">{
        return KreuzbergSupportedMIMETypes[mimeType]
}</span>
</pre>
		
		<pre class="file" id="file123" style="display: none">// Package vertex provides a Google Vertex AI chat completion client with streaming support.
package vertex

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "log/slog"
        "math"
        "net/http"
        "strings"
        "time"

        "golang.org/x/oauth2/google"
)

const (
        // DefaultModel is the default chat model
        DefaultModel = "gemini-2.5-flash-preview"

        // DefaultMaxRetries is the default number of retries
        DefaultMaxRetries = 3

        // DefaultBaseDelay is the base delay for exponential backoff
        DefaultBaseDelay = 100 * time.Millisecond

        // DefaultMaxDelay is the maximum delay for exponential backoff
        DefaultMaxDelay = 10 * time.Second

        // DefaultTimeout is the default HTTP timeout for streaming requests
        DefaultTimeout = 120 * time.Second

        // DefaultTemperature is the default temperature for generation
        DefaultTemperature = 0.0

        // DefaultMaxOutputTokens is the default max output tokens
        DefaultMaxOutputTokens = 8192
)

// Config holds the configuration for the Vertex AI chat client
type Config struct {
        ProjectID      string
        Location       string
        Model          string
        Timeout        time.Duration
        Temperature    float64
        MaxOutputTokens int
}

// Client is a Vertex AI chat completion client with streaming support
type Client struct {
        projectID       string
        location        string
        model           string
        httpClient      *http.Client
        tokenSrc        *google.Credentials
        log             *slog.Logger
        temperature     float64
        maxOutputTokens int

        // Retry configuration
        maxRetries int
        baseDelay  time.Duration
        maxDelay   time.Duration
}

// ClientOption configures the Client
type ClientOption func(*Client)

// WithMaxRetries sets the maximum number of retries
func WithMaxRetries(n int) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.maxRetries = n
        }</span>
}

// WithBaseDelay sets the base delay for exponential backoff
func WithBaseDelay(d time.Duration) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.baseDelay = d
        }</span>
}

// WithMaxDelay sets the maximum delay for exponential backoff
func WithMaxDelay(d time.Duration) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.maxDelay = d
        }</span>
}

// WithLogger sets the logger
func WithLogger(log *slog.Logger) ClientOption <span class="cov8" title="1">{
        return func(c *Client) </span><span class="cov8" title="1">{
                c.log = log
        }</span>
}

// NewClient creates a new Vertex AI chat completion client
func NewClient(ctx context.Context, cfg Config, opts ...ClientOption) (*Client, error) <span class="cov0" title="0">{
        if cfg.ProjectID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("project ID is required")
        }</span>
        <span class="cov0" title="0">if cfg.Location == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("location is required")
        }</span>
        <span class="cov0" title="0">if cfg.Model == "" </span><span class="cov0" title="0">{
                cfg.Model = DefaultModel
        }</span>
        <span class="cov0" title="0">if cfg.Timeout == 0 </span><span class="cov0" title="0">{
                cfg.Timeout = DefaultTimeout
        }</span>
        <span class="cov0" title="0">if cfg.Temperature == 0 </span><span class="cov0" title="0">{
                cfg.Temperature = DefaultTemperature
        }</span>
        <span class="cov0" title="0">if cfg.MaxOutputTokens == 0 </span><span class="cov0" title="0">{
                cfg.MaxOutputTokens = DefaultMaxOutputTokens
        }</span>

        // Get default credentials
        <span class="cov0" title="0">creds, err := google.FindDefaultCredentials(ctx, "https://www.googleapis.com/auth/cloud-platform")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to find default credentials: %w", err)
        }</span>

        <span class="cov0" title="0">c := &amp;Client{
                projectID: cfg.ProjectID,
                location:  cfg.Location,
                model:     cfg.Model,
                httpClient: &amp;http.Client{
                        Timeout: cfg.Timeout,
                },
                tokenSrc:        creds,
                log:             slog.Default(),
                temperature:     cfg.Temperature,
                maxOutputTokens: cfg.MaxOutputTokens,
                maxRetries:      DefaultMaxRetries,
                baseDelay:       DefaultBaseDelay,
                maxDelay:        DefaultMaxDelay,
        }

        for _, opt := range opts </span><span class="cov0" title="0">{
                opt(c)
        }</span>

        <span class="cov0" title="0">return c, nil</span>
}

// GenerateRequest is the request for content generation
type GenerateRequest struct {
        // Prompt is the user prompt (required)
        Prompt string

        // SystemPrompt is an optional system prompt
        SystemPrompt string

        // Temperature overrides the default temperature (0.0-1.0)
        Temperature *float64

        // MaxOutputTokens overrides the default max tokens
        MaxOutputTokens *int
}

// streamGenerateRequest is the API request body for streamGenerateContent
type streamGenerateRequest struct {
        Contents         []content         `json:"contents"`
        SystemInstruction *content          `json:"systemInstruction,omitempty"`
        GenerationConfig  generationConfig  `json:"generationConfig"`
}

type content struct {
        Role  string `json:"role,omitempty"`
        Parts []part `json:"parts"`
}

type part struct {
        Text string `json:"text"`
}

type generationConfig struct {
        Temperature      float64 `json:"temperature"`
        MaxOutputTokens  int     `json:"maxOutputTokens"`
}

// streamGenerateResponse is the streaming API response
type streamGenerateResponse struct {
        Candidates    []candidate    `json:"candidates"`
        UsageMetadata *usageMetadata `json:"usageMetadata,omitempty"`
}

type candidate struct {
        Content      candidateContent `json:"content"`
        FinishReason string           `json:"finishReason,omitempty"`
        SafetyRatings []safetyRating  `json:"safetyRatings,omitempty"`
}

type candidateContent struct {
        Parts []candidatePart `json:"parts"`
        Role  string          `json:"role"`
}

type candidatePart struct {
        Text string `json:"text"`
}

type safetyRating struct {
        Category    string `json:"category"`
        Probability string `json:"probability"`
}

type usageMetadata struct {
        PromptTokenCount     int `json:"promptTokenCount"`
        CandidatesTokenCount int `json:"candidatesTokenCount"`
        TotalTokenCount      int `json:"totalTokenCount"`
}

// Usage contains token usage information
type Usage struct {
        PromptTokens     int
        CompletionTokens int
        TotalTokens      int
}

// GenerateResult contains the generation result
type GenerateResult struct {
        Content string
        Usage   *Usage
}

// Generate generates content (non-streaming)
func (c *Client) Generate(ctx context.Context, req GenerateRequest) (*GenerateResult, error) <span class="cov0" title="0">{
        var fullContent strings.Builder
        var usage *Usage

        err := c.GenerateStreaming(ctx, req, func(token string) </span><span class="cov0" title="0">{
                fullContent.WriteString(token)
        }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;GenerateResult{
                Content: fullContent.String(),
                Usage:   usage,
        }, nil</span>
}

// GenerateStreaming generates content with streaming, calling onToken for each token
func (c *Client) GenerateStreaming(ctx context.Context, req GenerateRequest, onToken func(string)) error <span class="cov0" title="0">{
        url := fmt.Sprintf(
                "https://%s-aiplatform.googleapis.com/v1/projects/%s/locations/%s/publishers/google/models/%s:streamGenerateContent?alt=sse",
                c.location, c.projectID, c.location, c.model,
        )

        // Build request body
        temperature := c.temperature
        if req.Temperature != nil </span><span class="cov0" title="0">{
                temperature = *req.Temperature
        }</span>
        <span class="cov0" title="0">maxTokens := c.maxOutputTokens
        if req.MaxOutputTokens != nil </span><span class="cov0" title="0">{
                maxTokens = *req.MaxOutputTokens
        }</span>

        <span class="cov0" title="0">apiReq := streamGenerateRequest{
                Contents: []content{
                        {
                                Role:  "user",
                                Parts: []part{{Text: req.Prompt}},
                        },
                },
                GenerationConfig: generationConfig{
                        Temperature:     temperature,
                        MaxOutputTokens: maxTokens,
                },
        }

        // Add system instruction if provided
        if req.SystemPrompt != "" </span><span class="cov0" title="0">{
                apiReq.SystemInstruction = &amp;content{
                        Parts: []part{{Text: req.SystemPrompt}},
                }
        }</span>

        <span class="cov0" title="0">reqBytes, err := json.Marshal(apiReq)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // Execute with retries
        <span class="cov0" title="0">var lastErr error
        for attempt := 0; attempt &lt;= c.maxRetries; attempt++ </span><span class="cov0" title="0">{
                if attempt &gt; 0 </span><span class="cov0" title="0">{
                        delay := c.calculateBackoff(attempt)
                        c.log.Debug("retrying chat request",
                                slog.Int("attempt", attempt),
                                slog.Duration("delay", delay),
                        )
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return ctx.Err()</span>
                        case &lt;-time.After(delay):<span class="cov0" title="0"></span>
                        }
                }

                <span class="cov0" title="0">lastErr = c.doStreamRequest(ctx, url, reqBytes, onToken)
                if lastErr == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Don't retry on context cancellation
                <span class="cov0" title="0">if ctx.Err() != nil </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>

                // Check if error is retryable
                <span class="cov0" title="0">if _, ok := lastErr.(*retryableError); !ok </span><span class="cov0" title="0">{
                        // Non-retryable error, return immediately
                        return lastErr
                }</span>

                <span class="cov0" title="0">c.log.Warn("chat request failed",
                        slog.Int("attempt", attempt),
                        slog.String("error", lastErr.Error()),
                )</span>
        }

        <span class="cov0" title="0">return fmt.Errorf("all retries exhausted: %w", lastErr)</span>
}

// doStreamRequest executes a single streaming HTTP request
func (c *Client) doStreamRequest(ctx context.Context, url string, body []byte, onToken func(string)) error <span class="cov0" title="0">{
        // Get access token
        token, err := c.tokenSrc.TokenSource.Token()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get access token: %w", err)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, http.MethodPost, url, bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+token.AccessToken)
        req.Header.Set("Content-Type", "application/json")
        req.Header.Set("Accept", "text/event-stream")

        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Check for non-streaming error responses
        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                respBody, _ := io.ReadAll(resp.Body)
                
                // Check if retryable
                if resp.StatusCode == http.StatusTooManyRequests ||
                        resp.StatusCode == http.StatusServiceUnavailable ||
                        resp.StatusCode &gt;= 500 </span><span class="cov0" title="0">{
                        return &amp;retryableError{
                                statusCode: resp.StatusCode,
                                body:       string(respBody),
                        }
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("API error %d: %s", resp.StatusCode, string(respBody))</span>
        }

        // Read SSE stream
        <span class="cov0" title="0">return c.parseSSEStream(resp.Body, onToken)</span>
}

// parseSSEStream parses the SSE stream from Vertex AI
func (c *Client) parseSSEStream(reader io.Reader, onToken func(string)) error <span class="cov0" title="0">{
        scanner := bufio.NewScanner(reader)
        // Increase buffer size for potentially large responses
        scanner.Buffer(make([]byte, 0, 64*1024), 1024*1024)

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, ":") </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse SSE data lines
                <span class="cov0" title="0">if strings.HasPrefix(line, "data: ") </span><span class="cov0" title="0">{
                        data := strings.TrimPrefix(line, "data: ")
                        
                        // Skip [DONE] marker if present
                        if data == "[DONE]" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">var streamResp streamGenerateResponse
                        if err := json.Unmarshal([]byte(data), &amp;streamResp); err != nil </span><span class="cov0" title="0">{
                                c.log.Warn("failed to parse streaming response",
                                        slog.String("data", data),
                                        slog.String("error", err.Error()),
                                )
                                continue</span>
                        }

                        // Extract text from candidates
                        <span class="cov0" title="0">for _, candidate := range streamResp.Candidates </span><span class="cov0" title="0">{
                                // Check for safety blocks
                                if candidate.FinishReason == "SAFETY" </span><span class="cov0" title="0">{
                                        return fmt.Errorf("response blocked due to safety filters")
                                }</span>
                                <span class="cov0" title="0">if candidate.FinishReason == "RECITATION" </span><span class="cov0" title="0">{
                                        return fmt.Errorf("response blocked due to recitation/copyright detection")
                                }</span>

                                <span class="cov0" title="0">for _, part := range candidate.Content.Parts </span><span class="cov0" title="0">{
                                        if part.Text != "" </span><span class="cov0" title="0">{
                                                onToken(part.Text)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error reading stream: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// calculateBackoff calculates the backoff delay for a given attempt
func (c *Client) calculateBackoff(attempt int) time.Duration <span class="cov8" title="1">{
        delay := float64(c.baseDelay) * math.Pow(2, float64(attempt-1))
        if delay &gt; float64(c.maxDelay) </span><span class="cov8" title="1">{
                delay = float64(c.maxDelay)
        }</span>
        <span class="cov8" title="1">return time.Duration(delay)</span>
}

// retryableError is an error that can be retried
type retryableError struct {
        statusCode int
        body       string
}

func (e *retryableError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("retryable API error %d: %s", e.statusCode, e.body)
}</span>

// IsAvailable checks if the client is properly configured
func (c *Client) IsAvailable() bool <span class="cov8" title="1">{
        return c.projectID != "" &amp;&amp; c.location != "" &amp;&amp; c.tokenSrc != nil
}</span>

// Model returns the configured model name
func (c *Client) Model() string <span class="cov8" title="1">{
        return c.model
}</span>
</pre>
		
		<pre class="file" id="file124" style="display: none">package logger

import (
        "context"
        "fmt"
        "io"
        "log/slog"
        "os"
        "path/filepath"
        "runtime"
        "strings"
        "sync"
        "time"

        "go.uber.org/fx"
)

const (
        mainLogFile  = "server.log"
        errorLogFile = "server.error.log"
</span>        debugLogFile = "server.debug.</span>log"
        httpLogFile  =<span class="cov0" title="0"> "server.http.log"
)
</span>
// getLogDir returns the </span>log directory path, using WORKSPACE_ROOT if set
func getLogDir() string <span class="cov8" title="1">{
        // Check for WORKSPACE_ROOT env var (set by workspace-cli)
        if root := os.Getenv("WORKSPACE_ROOT"); root != "" </span></span>{
                return filepath.Join(roo</span>t, "logs", "server")
        }</span>
        // Fall back to relative path from current working directory
        // Go up from apps/server-go to workspace root
        <span class="cov0" title="0">return filepath.Join("..", "..", "logs", "server")</span>
}

var Module = fx.Module("logger",
        fx.Provide(NewLogger),
        fx.Provide(NewHTTPLogger),
)

</span></span>// logFiles holds references to open log files for cleanup
ty</span>pe lo<span class="cov0" title="0">gFiles struct {
        main  *os.File
        e</span>rror *os.File
        debug *os.File
}<span class="cov0" title="0">

var (
        openFiles *lo</span>gFiles
        filesMu   sync.Mutex
)

// ensureLogDir creates the log dir<span class="cov8" title="1">ectory if it doesn't exist
func ensureLogDir() error {
        </span>return os.MkdirAll(getLogDir(), 0755)
}</span>

// openLogFile opens a log file <span class="cov8" title="1">for appending, creating if necessary
func openLogFile(filename string) (*os.File, error) {
        </span>path := filepath.Join(getLogDir(), filename)
        return os.OpenFile(path, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
}</span>

// customHandler implements slog.Handler with NestJS-compatible formatting
// Format: 2026-01-16T21:47:08.511Z [LEVEL] [Scope] file.go:123 - message
type customHandler struct {
        level     slog.Level
        addSource bool
        writers   []io.Writer
        attrs     []slog.Attr
        groups    []string
        mu        *sync.Mutex
}

func newCustomHandler(level slog.Level, addSource bool, writers ...io.Writer) *customHandler <span class="cov8" title="1">{
        return &amp;customHandler{
                level:     level,
                addSource: addSource,
                writers:   writers,
                mu:        &amp;sync.Mutex{},
        }
}</span>

func (h *customHandler) Enabled(_ context.Context, level slog.Level) bool <span class="cov0" title="0">{
        return level &gt;= h.level
}</span>

func (h *customHandler) Handle(_ context.Context, r slog.Record) error <span class="cov0" title="0">{
        // Format: 2026-01-16T21:47:08.511Z [LEVEL] [Scope] file.go:123 - message
        var buf strings.Builder

        // Timestamp in ISO 8601 format
        buf.WriteString(r.Time.UTC().Format("2006-01-02T15:04:05.000Z"))
        buf.WriteString(" ")

        // Level
        levelStr := strings.ToUpper(r.Level.String())
        buf.WriteString("[")
        buf.WriteString(levelStr)
        buf.WriteString("] ")

        // Extract scope from attributes
        scope := ""
        var otherAttrs []slog.Attr
        r.Attrs(func(a slog.Attr) bool </span><span class="cov0" title="0">{
                if a.Key == "scope" </span><span class="cov0" title="0">{
                        scope = a.Value.String()
                }</span> else<span class="cov0" title="0"> {
                        otherAttrs = append(otherAttrs, a)
                }</span>
                <span class="cov0" title="0">return true</span>
        })

        // Add inherited attrs
        <span class="cov0" title="0">for _, a := range h.attrs </span><span class="cov0" title="0">{
                if a.Key == "scope" &amp;&amp; scope == "" </span><span class="cov0" title="0">{
                        scope = a.Value.String()
                }</span> else<span class="cov0" title="0"> {
                        otherAttrs = append(otherAttrs, a)
                }</span>
        }

        // Scope (if present)
        <span class="cov0" title="0">if scope != "" </span><span class="cov0" title="0">{
                buf.WriteString("[")
                buf.WriteString(scope)
                buf.WriteString("] ")
        }</span>

        // Source location (if enabled)
        <span class="cov0" title="0">if h.addSource &amp;&amp; r.PC != 0 </span><span class="cov0" title="0">{
                fs := runtime.CallersFrames([]uintptr{r.PC})
                f, _ := fs.Next()
                if f.File != "" </span><span class="cov0" title="0">{
                        // Extract just the filename
                        _, filename := filepath.Split(f.File)
                        buf.WriteString(filename)
                        buf.WriteString(":")
                        buf.WriteString(fmt.Sprintf("%d", f.Line))
                        buf.WriteString(" ")
                }</span>
        }

        // Message
        <span class="cov0" title="0">buf.WriteString("- ")
        buf.WriteString(r.Message)

        // Additional attributes (excluding scope)
        if len(otherAttrs) &gt; 0 </span><span class="cov0" title="0">{
                for _, a := range otherAttrs </span><span class="cov0" title="0">{
                        buf.WriteString(" ")
                        buf.WriteString(a.Key)
                        buf.WriteString("=")
                        buf.WriteString(fmt.Sprintf("%v", a.Value.Any()))
                }</span>
        }

        <span class="cov0" title="0">buf.WriteString("\n")

        // Write to all writers
        h.mu.Lock()
        defer h.mu.Unlock()
        for _, w := range h.writers </span><span class="cov0" title="0">{
                w.Write([]byte(buf.String()))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *customHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov8" title="1">{
        newAttrs := make([]slog.Attr, len(h.attrs)+len(attrs))
        copy(newAttrs, h.attrs)
        copy(newAttrs[len(h.attrs):], attrs)
        return &amp;customHandler{
                level:     h.level,
                addSource: h.addSource,
                writers:   h.writers,
                attrs:     newAttrs,
                groups:    h.groups,
                mu:        h.mu,
        }
}</span>

func (h *customHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        newGroups := make([]string, len(h.groups)+1)
        copy(newGroups, h.groups)
        newGroups[len(h.groups)] = name
        return &amp;customHandler{
                level:     h.level,
                addSource: h.addSource,
                writers:   h.writers,
                attrs:     h.attrs,
                groups:    newGroups,
                mu:        h.mu,
        }
}</span>

// errorFilterHandler wraps a handler and only passes ERROR+ level logs
type errorFilterHandler struct {
        inner slog.Handler
}

func (h *errorFilterHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov0" title="0">{
        return level &gt;= slog.LevelError &amp;&amp; h.inner.Enabled(ctx, level)
}</span>

func (h *errorFilterHandler) Handle(ctx context.Context, r slog.Record) error <span class="cov0" title="0">{
        return h.inner.Handle(ctx, r)
}</span>

func (h *errorFilterHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov8" title="1">{
        return &amp;errorFilterHandler{inner: h.inner.WithAttrs(attrs)}
}</span>

func (h *errorFilterHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        return &amp;errorFilterHandler{inner: h.inner.WithGroup(name)}
}</span>

// multiHandler sends logs to multiple handlers
type multiHandler struct {
        handlers []slog.Handler
}

func (h *multiHandler) Enabled(ctx context.Context, level slog.Level) bool <span class="cov0" title="0">{
        for _, handler := range h.handlers </span><span class="cov0" title="0">{
                if handler.Enabled(ctx, level) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (h *multiHandler) Handle(ctx context.Context, r slog.Record) error <span class="cov0" title="0">{
        for _, handler := range h.handlers </span><span class="cov0" title="0">{
                if handler.Enabled(ctx, r.Level) </span><span class="cov0" title="0">{
                        if err := handler.Handle(ctx, r); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (h *multiHandler) WithAttrs(attrs []slog.Attr) slog.Handler <span class="cov8" title="1">{
        handlers := make([]slog.Handler, len(h.handlers))
        for i, handler := range h.handlers </span><span class="cov8" title="1">{
                handlers[i] = handler.WithAttrs(attrs)
        }</span>
        <span class="cov8" title="1">return &amp;multiHandler{handlers: handlers}</span>
}

func (h *multiHandler) WithGroup(name string) slog.Handler <span class="cov0" title="0">{
        handlers := make([]slog.Handler, len(h.handlers))
        for i, handler := range h.handlers </span><span class="cov0" title="0">{
                handlers[i] = handler.WithGroup(name)
        }</span>
        <span class="cov0" title="0">return &amp;multiHandler{handlers: handlers}</span>
}

// NewLogger creates a structured logger based on environment
// Logs are written to stdout and to files in logs/server/
func NewLogger() *slog.Logger <span class="cov8" title="1">{
        level := slog.LevelInfo
        isDebug := false

        // Check LOG_LEVEL env var
        if lvl := os.Getenv("LOG_LEVEL"); lvl != "" </span><span class="cov0" title="0">{
                switch strings.ToLower(lvl) </span>{
                case "debug":<span class="cov0" title="0">
                        level = slog.LevelDebug
                        isDebug = true</span>
                case "info":<span class="cov0" title="0">
                        level = slog.LevelInfo</span>
                case "warn", "warning":<span class="cov0" title="0">
                        level = slog.LevelWarn</span>
                case "error":<span class="cov0" title="0">
                        level = slog.LevelError</span>
                }
        }

        // Create log directory
        <span class="cov8" title="1">if err := ensureLogDir(); err != nil </span><span class="cov0" title="0">{
                // Fall back to stdout-only if we can't create log dir
                fmt.Fprintf(os.Stderr, "Warning: could not create log directory: %v\n", err)
                return createStdoutOnlyLogger(level, isDebug)
        }</span>

        <span class="cov8" title="1">var handlers []slog.Handler

        // 1. Stdout handler (always present)
        stdoutHandler := newCustomHandler(level, isDebug, os.Stdout)
        handlers = append(handlers, stdoutHandler)

        filesMu.Lock()
        defer filesMu.Unlock()

        openFiles = &amp;logFiles{}

        // 2. Main log file (INFO+)
        if mainFile, err := openLogFile(mainLogFile); err == nil </span><span class="cov8" title="1">{
                openFiles.main = mainFile
                mainHandler := newCustomHandler(slog.LevelInfo, true, mainFile)
                handlers = append(handlers, mainHandler)
        }</span>

        // 3. Error log file (ERROR+)
        <span class="cov8" title="1">if errorFile, err := openLogFile(errorLogFile); err == nil </span><span class="cov8" title="1">{
                openFiles.error = errorFile
                errorHandler := newCustomHandler(slog.LevelError, true, errorFile)
                handlers = append(handlers, &amp;errorFilterHandler{inner: errorHandler})
        }</span>

        // 4. Debug log file (DEBUG+, only if debug level is enabled)
        <span class="cov8" title="1">if isDebug </span><span class="cov0" title="0">{
                if debugFile, err := openLogFile(debugLogFile); err == nil </span><span class="cov0" title="0">{
                        openFiles.debug = debugFile
                        debugHandler := newCustomHandler(slog.LevelDebug, true, debugFile)
                        handlers = append(handlers, debugHandler)
                }</span>
        }

        // Combine all handlers
        <span class="cov8" title="1">logger := slog.New(&amp;multiHandler{handlers: handlers})
        slog.SetDefault(logger)

        return logger</span>
}

func createStdoutOnlyLogger(level slog.Level, addSource bool) *slog.Logger <span class="cov0" title="0">{
        handler := newCustomHandler(level, addSource, os.Stdout)
        logger := slog.New(handler)
        slog.SetDefault(logger)
        return logger
}</span>

// HTTPLogger is a specialized logger for HTTP request/response logging
type HTTPLogger struct {
        file   *os.File
        mu     sync.Mutex
        logger *slog.Logger
}

// NewHTTPLogger creates a logger specifically for HTTP requests
func NewHTTPLogger(logger *slog.Logger) *HTTPLogger <span class="cov0" title="0">{
        httpLogger := &amp;HTTPLogger{logger: logger}

        if err := ensureLogDir(); err != nil </span><span class="cov0" title="0">{
                logger.Warn("Could not create log directory for HTTP logs", "error", err)
                return httpLogger
        }</span>

        <span class="cov0" title="0">if file, err := openLogFile(httpLogFile); err == nil </span><span class="cov0" title="0">{
                httpLogger.file = file
        }</span> else<span class="cov0" title="0"> {
                logger.Warn("Could not open HTTP log file", "error", err)
        }</span>

        <span class="cov0" title="0">return httpLogger</span>
}

// LogRequest logs an HTTP request in the standard format
// Format: 2026-01-16T18:51:46.401Z IP METHOD /path STATUS DURATIONms "User-Agent" [req-id]
func (h *HTTPLogger) LogRequest(ip, method, path string, status int, duration time.Duration, userAgent, requestID string) <span class="cov0" title="0">{
        // Format timestamp
        timestamp := time.Now().UTC().Format("2006-01-02T15:04:05.000Z")

        // Format duration in milliseconds
        durationMs := duration.Milliseconds()

        // Build log line
        logLine := fmt.Sprintf("%s %s %s %s %d %dms \"%s\" [%s]\n",
                timestamp, ip, method, path, status, durationMs, userAgent, requestID)

        // Write to file if available
        if h.file != nil </span><span class="cov0" title="0">{
                h.mu.Lock()
                h.file.WriteString(logLine)
                h.mu.Unlock()
        }</span>
}

// Close closes all open log files
func CloseLogFiles() <span class="cov0" title="0">{
        filesMu.Lock()
        defer filesMu.Unlock()

        if openFiles != nil </span><span class="cov0" title="0">{
                if openFiles.main != nil </span><span class="cov0" title="0">{
                        openFiles.main.Close()
                }</span>
                <span class="cov0" title="0">if openFiles.error != nil </span><span class="cov0" title="0">{
                        openFiles.error.Close()
                }</span>
                <span class="cov0" title="0">if openFiles.debug != nil </span><span class="cov0" title="0">{
                        openFiles.debug.Close()
                }</span>
        }
}

// Scope creates a child logger with a scope attribute
func Scope(scope string) slog.Attr <span class="cov8" title="1">{
        return slog.String("scope", scope)
}</span>

// Error wraps an error as a slog attribute
func Error(err error) slog.Attr <span class="cov0" title="0">{
        return slog.Any("error", err)
}</span>
</pre>
		
		<pre class="file" id="file125" style="display: none">// Package mathutil provides mathematical utility functions for the Go server.
package mathutil

import "math"

// CalcMeanStd calculates the mean and standard deviation of a slice of float32 values.
// Returns (0, 1) for empty slices to avoid division by zero in normalization.
func CalcMeanStd(scores []float32) (mean, std float32) <span class="cov8" title="1">{
        if len(scores) == 0 </span><span class="cov8" title="1">{
                return 0, 1 // Avoid division by zero
        }</span>

        // Calculate mean
        <span class="cov8" title="1">var sum float32
        for _, s := range scores </span><span class="cov8" title="1">{
                sum += s
        }</span>
        <span class="cov8" title="1">mean = sum / float32(len(scores))

        // Calculate standard deviation
        var variance float32
        for _, s := range scores </span><span class="cov8" title="1">{
                diff := s - mean
                variance += diff * diff
        }</span>
        <span class="cov8" title="1">variance /= float32(len(scores))
        std = float32(math.Sqrt(float64(variance)))

        // Avoid division by zero in normalization
        if std == 0 </span><span class="cov8" title="1">{
                std = 1
        }</span>

        <span class="cov8" title="1">return mean, std</span>
}

// Sigmoid applies the sigmoid function to a float32 value.
// sigmoid(z) = 1 / (1 + e^(-z))
func Sigmoid(z float32) float32 <span class="cov8" title="1">{
        return float32(1.0 / (1.0 + math.Exp(float64(-z))))
}</span>

// ClampInt clamps an integer value to a range [min, max].
func ClampInt(value, min, max int) int <span class="cov8" title="1">{
        if value &lt; min </span><span class="cov8" title="1">{
                return min
        }</span>
        <span class="cov8" title="1">if value &gt; max </span><span class="cov8" title="1">{
                return max
        }</span>
        <span class="cov8" title="1">return value</span>
}

// ClampLimit validates a pagination limit, applying default and max constraints.
// If limit &lt;= 0, returns defaultVal. If limit &gt; maxVal, returns maxVal.
func ClampLimit(limit, defaultVal, maxVal int) int <span class="cov8" title="1">{
        if limit &lt;= 0 </span><span class="cov8" title="1">{
                return defaultVal
        }</span>
        <span class="cov8" title="1">if limit &gt; maxVal </span><span class="cov8" title="1">{
                return maxVal
        }</span>
        <span class="cov8" title="1">return limit</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package pgutils

import (
        "strings"
)

// PostgreSQL error codes
// See: https://www.postgresql.org/docs/current/errcodes-appendix.html
const (
        // Class 23  Integrity Constraint Violation
        CodeUniqueViolation     = "23505"
        CodeForeignKeyViolation = "23503"
        CodeNotNullViolation    = "23502"
        CodeCheckViolation      = "23514"
)

// IsUniqueViolation checks if the error is a PostgreSQL unique constraint violation (23505).
func IsUniqueViolation(err error) bool <span class="cov8" title="1">{
        return containsErrorCode(err, CodeUniqueViolation)
}</span>

// IsForeignKeyViolation checks if the error is a PostgreSQL foreign key violation (23503).
func IsForeignKeyViolation(err error) bool <span class="cov8" title="1">{
        return containsErrorCode(err, CodeForeignKeyViolation)
}</span>

// IsNotNullViolation checks if the error is a PostgreSQL not-null constraint violation (23502).
func IsNotNullViolation(err error) bool <span class="cov8" title="1">{
        return containsErrorCode(err, CodeNotNullViolation)
}</span>

// IsCheckViolation checks if the error is a PostgreSQL check constraint violation (23514).
func IsCheckViolation(err error) bool <span class="cov8" title="1">{
        return containsErrorCode(err, CodeCheckViolation)
}</span>

// containsErrorCode checks if the error message contains a PostgreSQL error code.
func containsErrorCode(err error, code string) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">errStr := err.Error()
        return len(errStr) &gt; 0 &amp;&amp; (strings.Contains(errStr, code) || strings.Contains(errStr, "SQLSTATE "+code))</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">// Package pgutils provides PostgreSQL utility functions for the Go server.
package pgutils

import (
        "strconv"
        "strings"
)

// FormatVector converts a float32 slice to PostgreSQL vector literal format.
// Example: []float32{0.1, 0.2, 0.3} -&gt; "[0.1,0.2,0.3]"
func FormatVector(v []float32) string <span class="cov8" title="1">{
        if len(v) == 0 </span><span class="cov8" title="1">{
                return "[]"
        }</span>

        <span class="cov8" title="1">var buf strings.Builder
        buf.Grow(len(v)*12 + 2) // Pre-allocate buffer for efficiency
        buf.WriteByte('[')

        for i, f := range v </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        buf.WriteByte(',')
                }</span>
                <span class="cov8" title="1">buf.WriteString(strconv.FormatFloat(float64(f), 'f', -1, 32))</span>
        }

        <span class="cov8" title="1">buf.WriteByte(']')
        return buf.String()</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package sse

// ChatEventType represents the type of SSE event in chat streaming.
type ChatEventType string

const (
        // EventMeta is the first event, containing conversation metadata.
        EventMeta ChatEventType = "meta"

        // EventToken is emitted for each streamed text token.
        EventToken ChatEventType = "token"

        // EventMCPTool is emitted for MCP tool invocations.
        EventMCPTool ChatEventType = "mcp_tool"

        // EventError is emitted when an error occurs during streaming.
        EventError ChatEventType = "error"

        // EventDone is the final event, signaling end of stream.
        EventDone ChatEventType = "done"
)

// MetaEvent is the first event in a chat stream containing metadata.
type MetaEvent struct {
        Type           string    `json:"type"`
        ConversationID string    `json:"conversationId"`
        Citations      []any     `json:"citations"`
        GraphObjects   []any     `json:"graphObjects,omitempty"`
        GraphNeighbors any       `json:"graphNeighbors,omitempty"`
}

// NewMetaEvent creates a new meta event.
func NewMetaEvent(conversationID string) MetaEvent <span class="cov8" title="1">{
        return MetaEvent{
                Type:           string(EventMeta),
                ConversationID: conversationID,
                Citations:      []any{},
        }
}</span>

// TokenEvent is emitted for each streamed text token.
type TokenEvent struct {
        Type  string `json:"type"`
        Token string `json:"token"`
}

// NewTokenEvent creates a new token event.
func NewTokenEvent(token string) TokenEvent <span class="cov8" title="1">{
        return TokenEvent{
                Type:  string(EventToken),
                Token: token,
        }
}</span>

// MCPToolEvent is emitted for MCP tool invocations.
type MCPToolEvent struct {
        Type   string `json:"type"`
        Tool   string `json:"tool"`
        Status string `json:"status"` // "started", "completed", "error"
        Result any    `json:"result,omitempty"`
        Error  string `json:"error,omitempty"`
}

// NewMCPToolEvent creates a new MCP tool event.
func NewMCPToolEvent(tool, status string, result any, errMsg string) MCPToolEvent <span class="cov8" title="1">{
        return MCPToolEvent{
                Type:   string(EventMCPTool),
                Tool:   tool,
                Status: status,
                Result: result,
                Error:  errMsg,
        }
}</span>

// ErrorEvent is emitted when an error occurs during streaming.
type ErrorEvent struct {
        Type  string `json:"type"`
        Error string `json:"error"`
}

// NewErrorEvent creates a new error event.
func NewErrorEvent(errMsg string) ErrorEvent <span class="cov8" title="1">{
        return ErrorEvent{
                Type:  string(EventError),
                Error: errMsg,
        }
}</span>

// DoneEvent is the final event signaling end of stream.
type DoneEvent struct {
        Type string `json:"type"`
}

// NewDoneEvent creates a new done event.
func NewDoneEvent() DoneEvent <span class="cov8" title="1">{
        return DoneEvent{
                Type: string(EventDone),
        }
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">// Package sse provides Server-Sent Events (SSE) utilities for HTTP streaming responses.
package sse

import (
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
)

// Writer provides a convenient way to write SSE events to an HTTP response.
// It handles header setup, JSON serialization, and flushing.
type Writer struct {
        w       http.ResponseWriter
        flusher http.Flusher
        mu      sync.Mutex
        started bool
        closed  bool
}

// NewWriter creates a new SSE writer from an http.ResponseWriter.
// It does not set headers or flush - call Start() to begin streaming.
func NewWriter(w http.ResponseWriter) *Writer <span class="cov8" title="1">{
        flusher, _ := w.(http.Flusher)
        return &amp;Writer{
                w:       w,
                flusher: flusher,
        }
}</span>

// Start sets the SSE headers and flushes them to the client.
// This should be called after request validation is complete.
// Returns an error if the response doesn't support flushing.
func (s *Writer) Start() error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.started </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">s.w.Header().Set("Content-Type", "text/event-stream")
        s.w.Header().Set("Cache-Control", "no-cache")
        s.w.Header().Set("Connection", "keep-alive")
        s.w.Header().Set("X-Content-Type-Options", "nosniff")
        s.w.WriteHeader(http.StatusOK)

        if s.flusher != nil </span><span class="cov8" title="1">{
                s.flusher.Flush()
        }</span>

        <span class="cov8" title="1">s.started = true
        return nil</span>
}

// WriteEvent writes a named event with JSON data.
// Format: event: {name}\ndata: {json}\n\n
func (s *Writer) WriteEvent(eventName string, data any) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.closed </span><span class="cov8" title="1">{
                return fmt.Errorf("SSE writer is closed")
        }</span>

        <span class="cov8" title="1">jsonData, err := json.Marshal(data)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("marshal SSE data: %w", err)
        }</span>

        <span class="cov8" title="1">if eventName != "" </span><span class="cov8" title="1">{
                if _, err := fmt.Fprintf(s.w, "event: %s\n", eventName); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if _, err := fmt.Fprintf(s.w, "data: %s\n\n", jsonData); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if s.flusher != nil </span><span class="cov8" title="1">{
                s.flusher.Flush()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// WriteData writes a data-only event (no event name).
// Format: data: {json}\n\n
func (s *Writer) WriteData(data any) error <span class="cov8" title="1">{
        return s.WriteEvent("", data)
}</span>

// WriteRaw writes a raw string as SSE data without JSON encoding.
// Format: data: {raw}\n\n
func (s *Writer) WriteRaw(data string) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.closed </span><span class="cov8" title="1">{
                return fmt.Errorf("SSE writer is closed")
        }</span>

        <span class="cov8" title="1">if _, err := fmt.Fprintf(s.w, "data: %s\n\n", data); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if s.flusher != nil </span><span class="cov8" title="1">{
                s.flusher.Flush()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// WriteComment writes an SSE comment (used for keep-alive).
// Format: : {comment}\n\n
func (s *Writer) WriteComment(comment string) error <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()

        if s.closed </span><span class="cov8" title="1">{
                return fmt.Errorf("SSE writer is closed")
        }</span>

        <span class="cov8" title="1">if _, err := fmt.Fprintf(s.w, ": %s\n\n", comment); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if s.flusher != nil </span><span class="cov8" title="1">{
                s.flusher.Flush()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Close marks the writer as closed. No more writes will be accepted.
func (s *Writer) Close() <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        s.closed = true
}</span>

// IsClosed returns whether the writer has been closed.
func (s *Writer) IsClosed() bool <span class="cov8" title="1">{
        s.mu.Lock()
        defer s.mu.Unlock()
        return s.closed
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
